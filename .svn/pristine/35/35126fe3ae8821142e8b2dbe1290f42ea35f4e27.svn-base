/**
*
* Namespace: CWN2
*
* Namespace CWN2, contiene tutti gli oggetti della libreria
*
*/
var CWN2 = {};

/**
*
* Namespace: CWN2.Button
*
* Contiene il catalogo dei bottoni disponibili
*
*/
CWN2.Button = {};

/**
*
* Namespace: CWN2.Widget
*
* Contiene il catalogo dei widgets disponibili
*
*/
CWN2.Widget = {};

/**
*
* Namespace: CWN2.Control
*
* Namespace CWN2.Control, raccoglie i controlli custom
*
*/
CWN2.Control = {};/**
 *
 * Class: CWN2.Util
 *
 * Namespace contenente metodi di utilitÃ 
 *
 *
 */

CWN2.Util = (function(){

    /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false , console:false  , opera:false  , google:false  */
    "use strict";

	/*
	*  PROPRIETA' PRIVATE 
	*/
	
	/*
	*  METODI PRIVATI 
	*/

    //  Ritorna il valore di un parametro nella queryString
    function getUrlParam(paramName) {

        CWN2.Util.log("CWN2.Util.getUrlParam");

        var results = new RegExp("[\\?&]" + paramName + "=([^&#]*)").exec(window.location.href);
//        if (!results) { return 0; }
//        return results[1] || 0;

        return results? decodeURIComponent(results[1]) : null;

    }

    //  Ritorna il valore di un parametro nella queryString
    function getUrlParamFromString(url,paramName) {

        CWN2.Util.log("CWN2.Util.getUrlParam");

        var results = new RegExp("[\\?&]" + paramName + "=([^&#]*)").exec(url);
        if (!results) { return 0; }
        return results[1] || 0;

    }

    function assert(condition, error){
            if (!condition){
            throw error;
        }
    }

    // Gestione Exception
    // level:
    // - 0 = warning (non viene mandato messaggio all'utente
    // - 1 = errore
    // - 2 = errore bloccante
    function handleException(exception){

        CWN2.Util.log(exception.message,exception.level);

        if (exception.level>0)
        {
            CWN2.Util.messageBox(exception.message);
        }

    }



    // Scrive un messaggio sulla console
    // level:
    // - undefined = info
    // - 0 = warn
    // - 1/2 = error

    function log(message,level) {

        if (!CWN2.debug) {
            return;
        }

        var action = "log";

        switch (level) {
            case undefined:
                action = "info";
                break;
            case 0:
                action = "warn";
                break;
            case 1: case 2:
                action = "error";
                break;
        }

        // console di firebug e IE8
        try {
            console[action]( message );
        } catch(e) {
            // console di opera
            try {
                opera.postError(message);
            }
            // nessuna console
            catch (e2) {
                // apertura finestra
                //var win = window.open("", "log", "status=yes, toolbar=yes, menubar=no, width=400, height=400, resizable=yes, scrollbars=yes");
                //win.document.write(message + "<br>");
            }
        }
    }

    //  Manda un alert di avviso all'utente
    function messageBox(msg) {
        if (Ext) {
            Ext.MessageBox.show({
              title: '',
              msg: msg,
              buttons: {ok: 'OK'}
            });
        } else {
            window.alert(msg);
        }
    }

    // Funzione per caricare un oggetto json remoto con protocollo JSONP.
    function getJSONP(url,urlParams,callBack) {

        CWN2.Util.log("CWN2.Util.getJSONP");

        // funzione richiamata in caso di errore http
        function onErrorCB(jqXHR, textStatus, errorThrown) {
            throw {
                name: "BadAjaxCall",
                message: "CWN2.Util.getJSONP - Non sono riuscito a caricare la url:\n" + url + "\nErrore: " + jqXHR.status + " - " + textStatus + " - " + errorThrown,
                level: 1
            };
        }

        $.ajax({
            url: url,
            dataType: "jsonp",
            data: urlParams,
            contentType: "application/javascript",
            type: "GET"
        }).done(function(json) {
            try {
                callBack(json);
            }
            catch (exception) {
                CWN2.Util.handleException(exception);
            }
        }).fail(function(jqXHR, textStatus, errorThrown) {
            if (jqXHR.statusText !== "OK") {
                try {
                    onErrorCB(jqXHR, textStatus, errorThrown);
                }
                catch (exception) {
                    CWN2.Util.handleException(exception);
                }
            }
        });

    }

    // Funzione per caricare un oggetto json remoto in maniera sincrona o asincrona.
    function getJSON(url,urlParams,aSync,callBack,args) {

        CWN2.Util.log("CWN2.Util.getJSON");


        function onErrorCB(textStatus, errorThrown, url) {
            throw {
                name: "BadAjaxCall",
                message: "CWN2.Util.getJSON: " + url + " - " + errorThrown,
                level: 1
            };
        }

        $.ajax({
            type: "GET",
            url: url,
            dataType: "json",
            success: function(json) {
                try {
                    callBack(json,args);
                }
                catch (exception) {
                    CWN2.Util.handleException(exception);
                }
            },
            error: function(jqXHR, textStatus, errorThrown) {
                try {
                    onErrorCB(textStatus,errorThrown,url);
                }
                catch (exception) {
                    CWN2.Util.handleException(exception);
                }

            },
            data: urlParams,
            async: aSync
        });

    }

    // Funzione per caricare un oggetto xml remoto in maniera sincrona o asincrona.
    function getXML(url,urlParams,aSync,callBack,args) {

        CWN2.Util.log("CWN2.Util.getXML");


        function onErrorCB(textStatus, errorThrown, url) {
            throw {
                name: "BadAjaxCall",
                message: "CWN2.Util.getXML: " + url + " - " + errorThrown,
                level: 1
            };
        }

        $.ajax({
            type: "GET",
            url: url,
            dataType: "xml",
            beforeSend: function (xhr, settings) {
                try { xhr.responseType = "msxml-document"; } catch(err){}
            },
            success: function(data) {
                try {
                    callBack(data,args);
                }
                catch (exception) {
                    CWN2.Util.handleException(exception);
                }
            },
            error: function(jqXHR, textStatus, errorThrown) {
                try {
                    onErrorCB(textStatus,errorThrown,url);
                }
                catch (exception) {
                    CWN2.Util.handleException(exception);
                }

            },
            data: urlParams,
            async: aSync
        });

    }

    // Funzione per fare il parsing xml
    // ritorna un xmlDoc
    function parseXML(xmlString) {

        CWN2.Util.log("CWN2.Util.parseXML");
        try {
            var xmlDoc = null;
            if (window.DOMParser && window.XSLTProcessor) {
                var parser = new DOMParser();
                xmlDoc = parser.parseFromString(xmlString,"text/xml");
            } else {
//                xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                xmlDoc = new ActiveXObject("Msxml2.DOMDocument.3.0");
                xmlDoc.async = false;
                xmlDoc.loadXML(xmlString);
            }
            return xmlDoc;
        } catch (exception) {
            throw {
                name: "xmlTransformation",
                message: "CWN2.Util.parseXml: errore parsing xml - " + exception.message ,
                level: 1
            };
        }
    }
    // Controlla se un punto appartiene al BBOX del territorio ligure
    function isPointInLig(x,y){

        CWN2.Util.log("CWN2.findManager.isPointInLig");

       if (!x || !y) {
           return false;
       }
        var minX = 7.4,
            minY = 43.7,
            maxX = 10.1,
            maxY = 44.8;

        return (x > minX) && (x < maxX) && (y > minY) && (y < maxY);

    }

    // controlla che il punto ricada dentro la finestra di maxExtent
    function isPointInMaxExtent(lat,lon,map,epsg) {

        if (!map) {
            return true;
        }
        if (!map.restrictedExtent) {
            return true;
        }

        var pointEpsg = epsg || "EPSG:4326";

        var point = new OpenLayers.LonLat(lon,lat);
        if (map.projection !== pointEpsg) {
            point.transform(
                new OpenLayers.Projection(pointEpsg),
                map.getProjectionObject()
            );
        }

        var minX = map.restrictedExtent.left,
            minY = map.restrictedExtent.bottom,
            maxX = map.restrictedExtent.right,
            maxY = map.restrictedExtent.top,
            x = point.lon,
            y = point.lat;

        return (x > minX) && (x < maxX) && (y > minY) && (y < maxY);

    }

    // Trasforma un bound in forma string da un sistema di coordinate ad un altro
    function transformStrBounds(fromProjStr,toProjStr,boundsStr){

        CWN2.Util.log("CWN2.Util.transformStrBounds");

        var fromProj = new OpenLayers.Projection(fromProjStr),
            toProj = new OpenLayers.Projection(toProjStr);

        var boundStrIn = boundsStr;
        // Hack per shift lungo asse Y e y
        if (fromProjStr === "EPSG:3003") {
            var boundArray = boundStrIn.split(",");
            boundArray[0] = parseInt(boundArray[0]) - parseInt(40);
            boundArray[2] = parseInt(boundArray[2]) - parseInt(40);
            boundArray[1] = parseInt(boundArray[1]) + parseInt(170);
            boundArray[3] = parseInt(boundArray[3]) + parseInt(170);
            boundStrIn = boundArray.join(",");
        }
        var bounds = new OpenLayers.Bounds.fromString(boundStrIn);
        return bounds.transform(fromProj, toProj).toString();

    }

    // Clona un oggetto JS
    function cloneObj(inObj){
        return jQuery.extend({}, inObj);
    }

	// Public API
	return {
	
        /**
        *  Function: getUrlParam
        *
        *  Ritorna il valore di un parametro nella queryString
        *
        *  Parameters:
        *  paramName - {String} Nome del parametro
        *
        *  Returns:
        *  {String} Valore del parametro (se non trovato ritorna 0)
        *
        */

		getUrlParam : getUrlParam,

        /**
        *  Function: getUrlParam
        *
        *  Ritorna il valore di un parametro nella queryString
        *
        *  Parameters:
         *  url - {String} Stringa contenente la URL
         *  paramName - {String} Nome del parametro
        *
        *  Returns:
        *  {String} Valore del parametro (se non trovato ritorna 0)
        *
        */

        getUrlParamFromString : getUrlParamFromString,

        /**
         *  Function: log
         *
         *  Scrive un messaggio sulla console
         *
         *  Parameters:
         *  msg - {String} Messaggio da scrivere
         *
         */

		log : log,

        /**
         *  Function: messageBox
         *
         *  Manda un alert di avviso all'utente
         *
         *  Parameters:
         *  msg - {string} Messaggio da scrivere sull'alert
         *
         */

        messageBox : messageBox,

        /**
         *  Function: assert
         *
         *  Assert per i controlli.
         *
         *  Controlla che l'espressione passata sia vera, altrimenti effettua la throw dell'errore
         *
         *  Parameters:
         *  test - {Expression} Condizione da verificare
         *  error - {Object} Oggetto errore
         *
         */

        assert : assert,

        /**
         * Function: handleException
         *
         * Gestione exception
         *
         * Parameters:
         * exception - {Object} Oggetto exception
         *
         */
        handleException: handleException,

        /**
        * Function: getJSON
        *
        * Funzione per caricare un oggetto json remoto in maniera sincrona o asincrona.
        *
        * Ritorna un oggetto javascript contentente la deserializzazione del json
        *
        * Parameters:
        * url - {String} Url del file o del servizio
        * urlParams - {Object} Oggetto map contenente i parametri da passare. Vedi http://api.jquery.com/jQuery.ajax/
        * aSync - {Boolean} Flag che indica se effettuare una richiesta asincrona
        * callBack {Function} Funzione da richiamare dopo il caricamento
        * args - {Object/Array} Aregomento o Array degli argumuments opzionali dal passare alla funzione di callback
        *
        * Returns:
        * {object} L'oggetto contenente la deserializzazione del JSON
        *
        */
		getJSON: getJSON,

        /**
        * Function: parseXML
        *
        * Funzione per fare il parsing di una stringa xml
        *
        * Ritorna un oggetto doc xml
        *
        * Parameters:
        * xmlString - {String} Stringa xml
        *
        * Returns:
        * {object} Oggetto xmlDoc
        *
        */
        parseXML: parseXML,


        /**
        * Function: getXML
        *
        * Funzione per caricare un oggetto xml remoto in maniera sincrona o asincrona.
        *
        * Ritorna un oggetto javascript contentente la deserializzazione del xml
        *
        * Parameters:
        * url - {String} Url del file o del servizio
        * urlParams - {Object} Oggetto map contenente i parametri da passare. Vedi http://api.jquery.com/jQuery.ajax/
        * aSync - {Boolean} Flag che indica se effettuare una richiesta asincrona
        * callBack {Function} Funzione da richiamare dopo il caricamento
        * args - {Object/Array} Aregomento o Array degli argumuments opzionali dal passare alla funzione di callback
        *
        * Returns:
        * {object} L'oggetto contenente la deserializzazione del JSON
        *
        */
        getXML: getXML,
        /**
         * Function: getJSONP
         *
         * Funzione per caricare un oggetto json remoto utilizzando il protocollo JSONP.
         *
         * Ritorna un oggetto javascript contentente la deserializzazione del json
         *
         * Parameters:
         * url - {String} Url del file o del servizio
         * urlParams - {Object} Oggetto map contenente i parametri da passare. Vedi http://api.jquery.com/jQuery.ajax/
         * callBack {Function} Funzione da richiamare dopo il caricamento
         *
         * Returns:
         * {object} L'oggetto contenente la deserializzazione del JSON
         *
         */
        getJSONP: getJSONP,


        /**
        *
        * Function: isPointInLig
        *
        * Controlla se un punto appartenga al BBOX del territorio ligure
        *
        * Parameters:
        * x - {number} Coordinata X
        * y - {number} Coordinata Y
        *
        * Returns:
        * {boolean} true/false
        *
        */
		isPointInLig: isPointInLig,


        /**
         *
         * Function: isPointInMaxExtent
         *
         * Controlla se un punto Ã¨ all'interno del maxExtent della mappa
         *
         * Parameters:
         * lat - {number} Latitudine WGS84
         * lon - {number} Longitudine WGS84
         *
         * Returns:
         * {boolean} true/false
         *
        */
        isPointInMaxExtent: isPointInMaxExtent,

        /**
         * Function: transformStrBounds
         *
         * Trasforma un bound in forma string da un sistema di coordinate ad un altro
         *
         * Parameters:
         * fromProjStr - {string} Codice EPSG del sistema di coordinate di partenza (es: "EPSG:3003")
         * toProjStr - {string} Codice EPSG del sistema di coordinate di arrivo
         *
         * Returns:
         * {string} Stringa del bound con coordinate separate da virgole
         *
         */
        transformStrBounds: transformStrBounds,

        /**
         * Function: cloneObj
         *
         * Clona oggetto JS (deep copy)
         *
         * Parameters:
         * inObj - {Object} Oggetto da clonare
         * Returns: {Object} Oggetto clonato
         *
         */
        cloneObj: cloneObj,

        /**
         * Function: toArray
         *
         * Converte Oggetto in Array
         *
         * Parameters:
         * obj - {Object} Oggetto da clonare
         *
         * Returns:
         * {Array} Array
         *
         */
        toArray: function(obj) {
            return Array.prototype.slice.call(obj);
        },

        /**
         * Function: bind
         *
         * Effettua la bind di una funzione ad uno scope
         *
         * Parameters:
         * scope - {Object} Oggetto da utilizzare come scope
         * fn - {Function} Funzione su cui effettuare la bind
         *
         * Returns:
         * {Function} Funzione con bind effettuato
         *
         */
        bind: function(scope, fn) {
            return function() {
                return fn.apply(scope, CWN2.Util.toArray(arguments));
            };
        },

        /**
         * Function: getArrayElementByAttribute
         *
         * Ritorna un elemento di un array contenente un attributo con un determinato valore
         *
         * Parameters:
         * array - {Array} array su cui cercare l'elemento
         * attributo - {string} Nome dell'attributo dell'elemento
         * value - {string} Valore dell'attributo
         *
         * Returns:
         * {Object} Oggetto
         *
         */
        getArrayElementByAttribute: function(array,attribute,value) {
            if (!array) {
                return null;
            }

            var i,
                len = array.length;

            for (i = 0; i < len; i++) {
                if (array[i][attribute] === value) {
                    return array[i];
                }
            }

            return null;
        },
        /**
         * Function: geoCode
         *
         * Effettua il geocode di un indirizzo utilizzando i servizi google
         *
         * Parameters:
         * address - {string} Indirizzo
         * properties - {Object} oggetto contenente le proprietÃ  da aggiungere all'oggetto properties della feature
         * callback - {function} funzione di callback
         *
         * Returns:
         * {GeoJSON Object}
         *
         */
        geoCode: function(address,properties,callback) {

            var geocoder = new google.maps.Geocoder();

            geocoder.geocode({ "address": address }, function(results, status) {
                if (status === google.maps.GeocoderStatus.OK) {

                    var x = results[0].geometry.location.lng();
                    var y = results[0].geometry.location.lat();
                    var feature = { "type": "FeatureCollection",
                         "features": [
                             { "type": "Feature",
                                 "geometry": {"type": "Point", "coordinates": [x, y]},
                                 "properties": {
                                     "address" : address
                                 }
                             }
                         ]
                    };
                    if (properties) {
                        for (var p in properties) {
                            if (properties.hasOwnProperty(p)) {
                                feature.features[0].properties[p] = properties[p];
                            }
                        }
                    }
                    callback(feature);
                } else {
                    if (status === google.maps.GeocoderStatus.ZERO_RESULTS) {
                        CWN2.Util.messageBox("Indirizzo '" + address + "' non trovato");
                    } else {
                        CWN2.Util.handleException({
                            name: "BadGeocoding",
                            message: "Errore di geocoding: " + status,
                            level: 1
                        });
                    }
                }
            });

        },

        /**
         * Function: unescapeHtmlEntities
         *
         * Decodifica caratteri html da una stringa contenente caratteri speciali codificati :
         * &amp; (&)
         * &quot; (")
         * &lt; (<)
         * &gt; (>)
         *
         * Parameters:
         * encodedString - {String} Stringa da decodificare
         *
         * Returns:
         * {String} - Stringa decodificata
         *
         * */
        unescapeHtmlEntities: function(encodedString) {
            encodedString= encodedString.replace(/\&amp;/g,'&');
            encodedString= encodedString.replace(/\&quot;/g,'\"');
            encodedString= encodedString.replace(/\&lt;/g,'<');
            encodedString= encodedString.replace(/\&gt;/g,'>');
            return encodedString;
        },

        /**
         * Function: loadMarker
         *
         * Carica un marker sul layer per le ricerche (findLayer)
         *
         * Parameters:
         * initConfig - {Object} Oggetto Configurazione
         *  - map - {CWN2.Map} MAppa su cui caricare il marker
         *  - x - {Number} Coordinata X del marker
         *  - y - {Number} Coordinata Y del marker
         *  - classes - {Object} Stile di vestizione del marker
         *  - label - {String} Etichetta
         *  - epsgCode - {String} Codice EPSG (nel formato "EPSG:3003")
         */
        loadMarker: function (initConfig){

            var classes,
                hiliteLayer,
                featureStr,
                feature,
                config,
                label,
                x,
                y,
                layerConfig,
                epsgCode,
                map,
                zoomLevel,
                setInitialExtent;

            map = initConfig.map;
            x = initConfig.x;
            y = initConfig.y;
            classes = initConfig.classes;
            label = initConfig.label;
            epsgCode = initConfig.epsgCode;
            zoomLevel = initConfig.zoomLevel;
            setInitialExtent = initConfig.setInitialExtent;

            if (epsgCode && epsgCode !== "EPSG:4326") {
                var point = new OpenLayers.LonLat(x,y);
                point.transform(
                    new OpenLayers.Projection(epsgCode),
                    new OpenLayers.Projection("EPSG:4326")
                );
                x = point.lon;
                y = point.lat;
            }

            layerConfig = {
                name: "findLayer",
                format: "GeoJSON",
                classes: classes
            };
            hiliteLayer = map.layerManager.createVectorLayer(layerConfig);

            // carico l'oggetto sul layer
            featureStr = "{ \"type\": \"FeatureCollection\",\"features\": [{ \"type\": \"Feature\",";
            featureStr += "\"geometry\": {\"type\": \"Point\", \"coordinates\": [" + x + "," + y + " ]},";
            featureStr += "\"properties\": {\"label\": \"" + label + "\"}}]}";
            feature = jQuery.parseJSON(featureStr);

            config = {
                layer: hiliteLayer,
                features: feature,
                url: null,
                epsgCode: epsgCode,
                options: {
                   zoom: initConfig.zoom,
                   clean: true,
                   zoomLevel : zoomLevel,
                   setInitialExtent : setInitialExtent
                }
            };

            CWN2.featureLoader.loadFeatures(config);

        },

        /**
         * Function: getWFSBound
         *
         * Ritorna il bound degli elementi attraverso un servizio WFS
         *
         * Parameters:
         * wfsUrl - {string} URL del servizio WFS
         * typeName - {string} nome della feature
         * sldFilter - {string} Filtro SLD
         * map - {OpenLayers.Map} Mappa OL
         * callback - {Function} Funzione di callback da richiamare
         *
         * Returns:
         * {OpenLayers.Bound}
         *
         */
        getWFSBound: function (wfsUrl,typeName,sldFilter,map,callback){

            CWN2.Util.getXML(
                wfsUrl,
                null,
                true,
                function (wfsResponse) {

                    if (wfsResponse) {
                        var json = $.xml2json(wfsResponse),
                            bbox = null,
                            srs = null,
                            bounds;
                        var exception = {};

                        // Gestione Exception server WFS
                        var serviceException = json["ServiceException"];
                        if (serviceException) {
                            exception.message = "CWN2.Util.getWFSBound - Service Exception: " + serviceException.text;
                            exception.level = 2;
                            CWN2.Util.handleException(exception);
                            return;
                        }
                        // Prendo il bbox
                        var boundedBy = json["boundedBy"] || json["gml:boundedBy"];
                        if (boundedBy) {
                            // Gestione not found
                            if (boundedBy["null"] || boundedBy["gml:null"]) {
                                exception.message = "CWN2.Util.getWFSBound - elemento non trovato";
                                exception.level = 2;
                                CWN2.Util.handleException(exception);
                                return;
                            }
                            if(boundedBy["Box"]) {
                                bbox = boundedBy["Box"]["coordinates"];
                                srs = boundedBy["Box"].srsName;
                            } else {
                                bbox = boundedBy["gml:Box"]["gml:coordinates"];
                                srs = boundedBy["gml:Box"].srsName;
                            }
                            if (bbox && srs) {
                                callback(OpenLayers.Bounds.fromString(CWN2.Util.transformStrBounds(srs, map.projection, bbox.replace(" ", ","))));
                                return;
                            }
                        }
                        // se non trovo bbox e srs
                        exception.message = "CWN2.Util.getWFSBound - bbox non ritornato dal servizio ";
                        exception.level = 1;
                        CWN2.Util.handleException(exception);
                    }

                }
            )
        },

        // Funzione per il decode di html
        htmlDecode: function (string, quote_style) {

            function get_html_translation_table (table, quote_style) {
              var entities = {},
                hash_map = {},
                decimal;
              var constMappingTable = {},
                constMappingQuoteStyle = {};
              var useTable = {},
                useQuoteStyle = {};

              // Translate arguments
              constMappingTable[0] = 'HTML_SPECIALCHARS';
              constMappingTable[1] = 'HTML_ENTITIES';
              constMappingQuoteStyle[0] = 'ENT_NOQUOTES';
              constMappingQuoteStyle[2] = 'ENT_COMPAT';
              constMappingQuoteStyle[3] = 'ENT_QUOTES';

              useTable = !isNaN(table) ? constMappingTable[table] : table ? table.toUpperCase() : 'HTML_SPECIALCHARS';
              useQuoteStyle = !isNaN(quote_style) ? constMappingQuoteStyle[quote_style] : quote_style ? quote_style.toUpperCase() : 'ENT_COMPAT';

              if (useTable !== 'HTML_SPECIALCHARS' && useTable !== 'HTML_ENTITIES') {
                throw new Error("Table: " + useTable + ' not supported');
                // return false;
              }

              entities['38'] = '&amp;';
              if (useTable === 'HTML_ENTITIES') {
                entities['160'] = '&nbsp;';
                entities['161'] = '&iexcl;';
                entities['162'] = '&cent;';
                entities['163'] = '&pound;';
                entities['164'] = '&curren;';
                entities['165'] = '&yen;';
                entities['166'] = '&brvbar;';
                entities['167'] = '&sect;';
                entities['168'] = '&uml;';
                entities['169'] = '&copy;';
                entities['170'] = '&ordf;';
                entities['171'] = '&laquo;';
                entities['172'] = '&not;';
                entities['173'] = '&shy;';
                entities['174'] = '&reg;';
                entities['175'] = '&macr;';
                entities['176'] = '&deg;';
                entities['177'] = '&plusmn;';
                entities['178'] = '&sup2;';
                entities['179'] = '&sup3;';
                entities['180'] = '&acute;';
                entities['181'] = '&micro;';
                entities['182'] = '&para;';
                entities['183'] = '&middot;';
                entities['184'] = '&cedil;';
                entities['185'] = '&sup1;';
                entities['186'] = '&ordm;';
                entities['187'] = '&raquo;';
                entities['188'] = '&frac14;';
                entities['189'] = '&frac12;';
                entities['190'] = '&frac34;';
                entities['191'] = '&iquest;';
                entities['192'] = '&Agrave;';
                entities['193'] = '&Aacute;';
                entities['194'] = '&Acirc;';
                entities['195'] = '&Atilde;';
                entities['196'] = '&Auml;';
                entities['197'] = '&Aring;';
                entities['198'] = '&AElig;';
                entities['199'] = '&Ccedil;';
                entities['200'] = '&Egrave;';
                entities['201'] = '&Eacute;';
                entities['202'] = '&Ecirc;';
                entities['203'] = '&Euml;';
                entities['204'] = '&Igrave;';
                entities['205'] = '&Iacute;';
                entities['206'] = '&Icirc;';
                entities['207'] = '&Iuml;';
                entities['208'] = '&ETH;';
                entities['209'] = '&Ntilde;';
                entities['210'] = '&Ograve;';
                entities['211'] = '&Oacute;';
                entities['212'] = '&Ocirc;';
                entities['213'] = '&Otilde;';
                entities['214'] = '&Ouml;';
                entities['215'] = '&times;';
                entities['216'] = '&Oslash;';
                entities['217'] = '&Ugrave;';
                entities['218'] = '&Uacute;';
                entities['219'] = '&Ucirc;';
                entities['220'] = '&Uuml;';
                entities['221'] = '&Yacute;';
                entities['222'] = '&THORN;';
                entities['223'] = '&szlig;';
                entities['224'] = '&agrave;';
                entities['225'] = '&aacute;';
                entities['226'] = '&acirc;';
                entities['227'] = '&atilde;';
                entities['228'] = '&auml;';
                entities['229'] = '&aring;';
                entities['230'] = '&aelig;';
                entities['231'] = '&ccedil;';
                entities['232'] = '&egrave;';
                entities['233'] = '&eacute;';
                entities['234'] = '&ecirc;';
                entities['235'] = '&euml;';
                entities['236'] = '&igrave;';
                entities['237'] = '&iacute;';
                entities['238'] = '&icirc;';
                entities['239'] = '&iuml;';
                entities['240'] = '&eth;';
                entities['241'] = '&ntilde;';
                entities['242'] = '&ograve;';
                entities['243'] = '&oacute;';
                entities['244'] = '&ocirc;';
                entities['245'] = '&otilde;';
                entities['246'] = '&ouml;';
                entities['247'] = '&divide;';
                entities['248'] = '&oslash;';
                entities['249'] = '&ugrave;';
                entities['250'] = '&uacute;';
                entities['251'] = '&ucirc;';
                entities['252'] = '&uuml;';
                entities['253'] = '&yacute;';
                entities['254'] = '&thorn;';
                entities['255'] = '&yuml;';
              }

              if (useQuoteStyle !== 'ENT_NOQUOTES') {
                entities['34'] = '&quot;';
              }
              if (useQuoteStyle === 'ENT_QUOTES') {
                entities['39'] = '&#39;';
              }
              entities['60'] = '&lt;';
              entities['62'] = '&gt;';


              // ascii decimals to real symbols
              for (decimal in entities) {
                if (entities.hasOwnProperty(decimal)) {
                  hash_map[String.fromCharCode(decimal)] = entities[decimal];
                }
              }

              return hash_map;
            }

          var hash_map = {},
            symbol = '',
            tmp_str = '',
            entity = '';
          tmp_str = string.toString();

          if (false === (hash_map = get_html_translation_table('HTML_ENTITIES', quote_style))) {
            return false;
          }

          // fix &amp; problem
          // http://phpjs.org/functions/get_html_translation_table:416#comment_97660
          delete(hash_map['&']);
          hash_map['&'] = '&amp;';

          for (symbol in hash_map) {
            entity = hash_map[symbol];
            tmp_str = tmp_str.split(entity).join(symbol);
          }
            tmp_str = tmp_str.split('&#039;').join("'");
            tmp_str = tmp_str.split('&#39;').join("'");

          return tmp_str;
        }

	};
}());

/**
*
* Class: CWN2.i18n
*
* Gestione multilinguismo
*
*/
CWN2.i18n = (function(){

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    var dict = {
        "Scala" : {
            "en" : "Scale"
        },
        "Coordinate:" : {
            "en" : "Coordinates:"
        },
        "Ricerche" : {
            "en" : "Find"
        },
        "Attenzione" : {
            "en" : "Attention"
        },
        "Nessun indirizzo indicato" : {
            "en" : "No Address"
        },
        "Il punto Ã¨ fuori dai limiti geografici della mappa" : {
            "en" : "Address is outside the map boundary"
        },
        "Indirizzo" : {
            "en" : "Address"
        },
        "Vai" : {
            "en" : "OK"
        },
        "Annulla" : {
            "en" : "Cancel"
        },
        "Aggiunta Livelli" : {
            "en" : "Add Layers"
        },
        "Zoom alla massima estensione" : {
            "en" : "Zoom to max extension"
        },
        "Zoom alla estensione iniziale" : {
            "en" : "Zoom to initial extension"
        },
        "Temi" : {
            "en" : "Themes"
        },
        "Aggiungi" : {
            "en" : "Add"
        },
        "Nessun livello selezionato" : {
            "en" : "No layer selected"
        },
        "Misure Areali" : {
            "en" : "Measure Area"
        },
        "Area" : {
            "en" : "Area"
        },
        "Misure Lineari" : {
            "en" : "Measure Line"
        },
        "Distanza" : {
            "en" : "Distance"
        },
        "Pan" : {
            "en" : "Pan"
        },
        "Togli Livelli" : {
            "en" : "Remove Layers"
        },
        "Seleziona i livelli da eliminare" : {
            "en" : "Select the layers to remove"
        },
        "Calcolo Percorsi" : {
            "en" : "Route Planner"
        },
        "Mezzo" : {
            "en" : "Mode"
        },
        "In auto" : {
            "en" : "Driving"
        },
        "A piedi" : {
            "en" : "Walking"
        },
        "Invio" : {
            "en" : "OK"
        },
        "Inverti direzione" : {
            "en" : "Swap"
        },
        "Seleziona punto di partenza sulla mappa" : {
            "en" : "Select start point on map"
        },
        "Seleziona punto di arrivo sulla mappa" : {
            "en" : "Select end point on map"
        },
        "Distanza totale" : {
            "en" : "Distance"
        },
        "Durata totale" : {
            "en" : "Duration"
        },
        "Calcola" : {
            "en" : "OK"
        },
        "Reset" : {
            "en" : "Reset"
        },
        "Zoom In" : {
            "en" : "Zoom In"
        },
        "Zoom Successivo" : {
            "en" : "Zoom Next"
        },
        "Zoom Out" : {
            "en" : "Zoom Out"
        },
        "Zoom Precedente" : {
            "en" : "Zoom Previous"
        },
        "Trasparenza" : {
            "en" : "Transparency"
        },
        "Sfondi" : {
            "en" : "Base Layer"
        },
        "Livelli" : {
            "en" : "Overlays"
        },
        "": {
            "en" : ""

        }

    };

    function get(string) {

//        console.log(string);

        if (dict[string]) {
            return dict[string][CWN2.i18n.language] || string;
        } else {
            return string;
        }

    }

    // Public API
    return {

           /**
            *  Property: dict
            *  Dizionario dei termini
           */

           dict: dict,

           /**
            *  Property: language
            *  Lingua
           */

           language: "it",

           /**
           *
           *  Function: get
           *
           *  Ritorna una stringa dal dizionario nella lingua impostata.
           *
           *  Parameters:
           *  string - {string} Stringa

           */
           get : get
	};

}());
/**
* 
* Class:  CWN2.appRegistry
*
* Contiene un registro delle applicazioni attive
*
*
*/
/*global CWN2:false, window:false, OpenLayers:false */
CWN2.appRegistry = (function(){

    "use strict";

	/*
	*  PROPRIETA' PRIVATE 
	*/

    var registry = {};

	// Public API
	return {
	
        /**
        *
        *  Function: add
        *
        *  Aggiunge una applicazione al registry.
        *
        *  Parameters:
        *  app - {Object} Oggetto CWN2.Application
        *
        */
        add : function(app) {
            if (!registry[app.id]) {
                registry[app.id] = app;
            }
        },

        /**
         *
         * Function: get
         *
         * Ritorna una applicazione dato un ID
         *
         * Parameters:
         * id -  {string} ID della applicazione
         *
        */
        get : function(id) {
            return registry[id];
        }


	};
}());

/**
* 
* Class:  CWN2.Application
*
* Contiene i metodi per inizializzare e gestire la applicazione
*
*
*/

CWN2.Application = function(initOptions) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    var appConfig = initOptions.appConfig;

    this.initOptions = initOptions;
    this.id = null;
    this.loadend = false;
    this.map = null;
    this.layout = null;
    this.configuration = null;
    this.extRequired = false;

    // imposto le variabili globali
    CWN2.Application.setGlobals(initOptions);

    CWN2.Util.log("CWN2.Application");

    // Carico la configurazione
    this.loadConfig(appConfig,initOptions);

};

/**
 *  Function: buildApp
*
*  Carica la configurazione
* Parameters:
* appConfig - {string / Object} Oggetto di configurazione o URL della configurazione
* initOptions - {Object} Oggetto contenente le opzioni di inizializzazione
*
*/
CWN2.Application.prototype.loadConfig = function(appConfig,initOptions) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    // Richiamo il metodo che costruisce l'applicazione
    if (typeof appConfig === "string") {
        CWN2.Util.getJSONP(
            appConfig,
            null,
            CWN2.Util.bind(this, function(appConfig) {
                this.buildApp(appConfig, initOptions);
            })
        );
    } else {
        this.buildApp(appConfig, initOptions);
    }
};


//region  Metodi pubblici statici

/**
 *
 * Function: checkServiceException
 *
 * Effettua il controllo che il servizio non abbia ritornato una eccezzione.
 * Metodo statico
 *
 * Parameters:
 * config -  {Object} oggetto configurazione
 *
*/
CWN2.Application.checkServiceException = function(config) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    if (config.exception) {
        throw {
            name:"ServiceError",
            message:"CWN2.Application: " + config.exception.message,
            level:2
        };
    }
};

/**
 *
 * Function: checkConfig
 *
 * Effettua dei controlli di base sulla configurazione.
 * Metodo statico
 *
 * Parameters:
 * config -  {Object} oggetto configurazione
 *
*/
CWN2.Application.checkConfig = function(config) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    CWN2.Util.assert(config,
        {
            name: "BadConfiguration",
            message: "CWN2.Application.checkConfig: configuration deve essere valorizzato",
            level: 2
        }
    );

    CWN2.Util.assert(config.application,
        {
            name: "BadConfiguration",
            message: "CWN2.Application.checkConfig: application deve essere valorizzato",
            level: 2
        }
    );

    CWN2.Util.assert(config.application.mapOptions,
        {
            name: "BadConfiguration",
            message: "CWN2.Application.checkConfig: mapOptions deve essere valorizzato",
            level: 2
        }
    );

    CWN2.Util.assert(config.application.layout,
        {
            name: "BadConfiguration",
            message: "CWN2.Application.checkConfig: layout deve essere valorizzato",
            level: 2
        }
    );

    CWN2.Util.assert(
        (
            (config.application.layout.type === "simple") ||
            (config.application.layout.type === "panel") ||
            (config.application.layout.type === "window") ||
            (config.application.layout.type === "viewport")
        ),
        {
            name: "BadConfiguration",
            message: "CWN2.Application.checkConfig: layout deve essere di tipo gestito (simple/panel/window/viewport)",
            level: 2
        }
    );

    CWN2.Util.assert(config.baseLayers,
        {
            name: "BadConfiguration",
            message: "CWN2.Application.checkConfig: baseLayers deve essere valorizzato",
            level: 2
        }
    );

    CWN2.Util.assert(config.baseLayers.length > 0,
        {
            name: "BadConfiguration",
            message: "CWN2.Application.checkConfig: baseLayers deve contenere almeno un layer",
            level: 2
        }
    );

};

/**
 *
 * Function: setGlobals
 *
 * Impostazione variabili globali - Metodo Statico
 *
 * Parameters:
 * initOptions -  {Object} Oggetto opzioni
 *
*/
CWN2.Application.setGlobals = function(initOptions) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    // variabile globale per il debug
    CWN2.debug = ((initOptions.debug)||(CWN2.Util.getUrlParam("debug") === "true"))? true : false;

    // imposto il proxy
    CWN2.proxy = initOptions.proxy || "";

    // imposto il proxy OL
    OpenLayers.ProxyHost = initOptions.proxy || "/CartoWebNet2/services/proxy/proxy.ashx?url=";

    // imposto il renderer SVG di OpenLayers sulla nuova versione
    OpenLayers.Layer.Vector.prototype.renderers = ["SVG2", "SVG", "VML", "Canvas"];

    // imposto la lingua
    CWN2.i18n.language = initOptions.language || "it";

    // ket per bing maps
    CWN2.BING_MAPS_KEY = "Agzh6x2xuNQ4qhwHW_yc0Yd8vhb-5pMRsAHjkneosLHLesOAGqxv35yqxZBlqqVa";


    OpenLayers.ImgPath = "http://srvcarto.regione.liguria.it/cartowebNet2/lib/OL/img/";

};

//endregion

//region  Metodi pubblici di istanza

/**
 *  Function: buildApp
*
*  Costruisce la applicazione
*  Prerequisito: Configurazione caricata
* Parameters:
* configuration - {Object} Oggetto di configurazione della applicazione
* initOptions - {Object} Oggetto contenente le opzioni di inizializzazione
*
*/
CWN2.Application.prototype.buildApp = function(configuration,initOptions) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    var layerManager;

    try {

        // controllo che il servizio non abbia ritornato un errore
        CWN2.Application.checkServiceException(configuration);

        // controllo la configurazione (controlli base)
        CWN2.Application.checkConfig(configuration);

        // imposto le proprieta' della applicazione
        this.setAppProperties(configuration);

        // impostazioni ExtJS
        if (this.extRequired) {
            // abilito i tooltip sui bottoni
            Ext.QuickTips.init();
            // imposto i bottoni per i messageBoxS
            if (CWN2.i18n.language === 'it') {
                Ext.MessageBox.buttonText = {yes: "Si", no: "No"};
            }
        }

        // registro la applicazione
        CWN2.appRegistry.add(this);

        // inizializzo il layer manager
        layerManager = new CWN2.LayerManager(configuration.baseLayers,configuration.layers,this.id);

        // costruisco la mappa OL
        this.map = new CWN2.Map(configuration.application.mapOptions,layerManager,this.id);

        // costruisco l'interfaccia
        if (initOptions.divID) {
            configuration.application.layout.divID = initOptions.divID;
        }
        this.layout = new CWN2.Layout(configuration.application.layout,this.id);

        // faccio zoom su initialExtent

        this.map.zoomToInitialExtent();

        // imposto il flag di fine caricamento
        this.loadend = true;

        // se impostato idMap carico la mappa da catalogo
        // altrimenti richiamo eventuale callback (che viene comunque chiamato nella loadMap)
        if (initOptions.idMap) {  
            this.loadMap(configuration, initOptions);
        } else {
        // se impostato idLayer carico i layer da catalogo
            if (initOptions.idLayer) {
                this.loadLayers(configuration, initOptions);
            } else {
                this.callback(configuration, initOptions);
            }
        }


    } catch (exception) {
        CWN2.Util.handleException(exception);
        return null;
    }
};


CWN2.Application.prototype.callback = function(configuration,initOptions) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    // richiamo eventuale callback
    if (configuration.application.onLoadCallback && configuration.application.onLoadCallback.name) {
        CWN2.OnLoadCallbacksRegistry[configuration.application.onLoadCallback.name](configuration.application.onLoadCallback.params,this);
    }
    else if (initOptions.callBack) {
        initOptions.callBack(this);
    }

};


/**
* Function: setAppProperties
*
* Imposta le proprietÃ  della applicazione.
*
* Parameters:
* configuration - {Object} Oggetto di configurazione della applicazione
*/
CWN2.Application.prototype.setAppProperties = function(configuration) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    // imposto la configurazione
    this.configuration = configuration;

    // imposto l'id della applicazione (utilizzata dai bottoni)
    this.id = configuration.application.id;

    // imposto il flag extRequired
    this.extRequired = configuration.application.layout.type !== "simple";

};

/**
 *  Function: showMapWindow
*
*  Mostra la finestra mappa.
*  Utilizzata da applicazioni con layout di tipo "window".
*
*/
CWN2.Application.prototype.showMapWindow = function() {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

   this.layout.layout.show();

};

/**
*
* Function: hiliteFeatures
*
* Evidenziazione dinamica feature di layer vettoriali.
*
* Utilizzata per applicazioni con integrata la cartografia (vedi EsempioWindow.js) o
* da bottoni della applicazione (p.es: ricerche/find/filtri, ecc...)
*
* Parameters:
* hiliteOptions - {Object} Oggetto di configurazione dell'hilite
*  - layerName - {String} Nome del layer
*  - filter - {Object} Oggetto configurazione del filtro
*  -  - type - {String}  Tipo di filtro (BY_ATTRIBUTE,SLD,CQL)
*  -  - attrName - {String} Nome dell'attributo (per filtro di tipo BY_ATTRIBUTE)
*  -  - items - {Array} Array di valori (per filtro di tipo BY_ATTRIBUTE)
*  -  - text - {String} Stringa contentente il filtro nel formato SLD o CQL
*  - options - {Object} Oggetto configurazione delle opzioni
*  -  - zoom - {Boolean} Flag per impostare lo zoom sulle feature caricate
*
*  Esempio:
*  (start code)
* var hiliteConf = {
*			"layerName": "Prova",
*			"filter" : {
*				"type": "BY_ATTRIBUTE",
*				"attrName": "ID",
*				"items": ["1","2"]
*			},
*			"options": {
*				"zoom": false
*			}
*		};
*   (end)
*
*/
CWN2.Application.prototype.hiliteFeatures = function(hiliteOptions) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    var olLayer = this.map.getLayerByName(hiliteOptions.layerName);
    if (olLayer) {
        hiliteOptions.layer = olLayer;
        CWN2.featureHiliter.hiliteFeatures(hiliteOptions);
    }

};

/**
*
* Function: resetHilite
*
* Azzeramento evidenziazione feature di layer vettoriali.
*
* Utilizzata per applicazioni con integrata la cartografia (vedi EsempioWindow.js) o da bottoni della applicazione (p.es: ricerche/find/filtri, ecc...)
*
*/
CWN2.Application.prototype.resetHilite = function() {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    var map = this.map;
    if (map) {
        CWN2.featureHiliter.resetHilite(map);
    }

};

/**
*
* Function: loadFeatures
*
* Carica le feature in formato GeoJSON in un layer di tipo OpenLayers.Layer.Vector
*
* Parameters:
* options - {Object} Oggetto di configurazione
*  - layerName - {String} Nome del layer
*  - features - {Object} Oggetto GeoJSON contenente le feature
*  - url - {String} URL del servizio/file con serve le feature
*  - options - {Object} Oggetto configurazione delle opzioni
*  - - zoom - {Boolean} Flag per impostare lo zoom sulle feature caricate
*  - - zoomLevel - {Integer} Se negativo effettua uno zoom all'indietro, se positivo e inferiore al livello di zoom attuale va a quel livello di zoom (zoom minimo)
*  - - clean - {Boolean} Flag per indicare se bisogna cancellare eventuali feature preesistenti
*
*  Esempio:
*  (start code)
* var config = {
*			"layerName": "Prova",
*           "features": features,
*           "url": null,
*			"options": {
 *				"zoom": false
 *				"clean": false
*			}
*		};
*   (end)
*
*/
CWN2.Application.prototype.loadFeatures = function(options) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    var olLayer = this.map.getLayerByName(options.layerName);
    if (olLayer) {
        options.layer = olLayer;
        CWN2.featureLoader.loadFeatures(options);
    }

};

/**
*
* Function: loadFeatureByAddress
*
* Carica le feature in formato GeoJSON in un layer di tipo OpenLayers.Layer.Vector
*
* Parameters:
* options - {Object} Oggetto di configurazione
*  - layerName - {String} Nome del layer
*  - features - {Object} Oggetto GeoJSON contenente le feature
*  - url - {String} URL del servizio/file con serve le feature
*  - options - {Object} Oggetto configurazione delle opzioni
*  - - zoom - {Boolean} Flag per impostare lo zoom sulle feature caricate
*  - - zoomLevel - {Integer} Se negativo effettua uno zoom all'indietro, se positivo e inferiore al livello di zoom attuale va a quel livello di zoom (zoom minimo)
*  - - clean - {Boolean} Flag per indicare se bisogna cancellare eventuali feature preesistenti
*
*  Esempio:
*  (start code)
* var config = {
*			"layerName": "Prova",
*           "address": " Genova, Liguria",
*			"options": {
*				"zoom": true
*				"zoomLevel": 16
*				"clean": true
*			}
*		};
*   (end)
*
*/
CWN2.Application.prototype.loadFeatureByAddress = function(options) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    var olLayer = this.map.getLayerByName(options.layerName);
    if (olLayer) {
        options.layer = olLayer;
        CWN2.featureLoader.loadFeatureByAddress(options);
    }

};

/**
*
* Function: selectFeature
*
* Selezione programmatica feature di un layer vettoriali.
*
* Se piÃ¹ feature soddisfano il criterio di selezione solo la prima viene selezionata.
*
* Se impostato il parametro options.hiliteOnly=true viene fatto solo l'highlight della feaure.
*
* Se impostato il parametro feature viene selezionata la feature,
* altrimenti viene fatta una ricerca della feature sul layer in base alla configurazione del parametro config.
*
*
* Parameters:
* options - {Object} Oggetto di configurazione dell'hilite
*  - layerName - {String} Nome del layer
*  - attrName - {String} Nome dell'attributo
*  - item - {String}/{Number} Valore
*  - options - {Object} Oggetto configurazione delle opzioni
*  -  - zoom - {Boolean} Flag per impostare lo zoom sulle feature caricate
*  -  - hiliteOnly - {Boolean} Flag per effettuare solo l'highlight della feature (default: false)
* feature - {OpenLayers.Feature} Feature da selezionare
*
*  Esempio:
*  (start code)
* var selectConf = {
*			"layerName": "Prova",
*			"attrName": "ID",
*				"items": "1"
*			},
*			"options": {
*				"zoom": false,
*				"hiliteOnly": false
*			}
*		};
*   (end)
*
*/
CWN2.Application.prototype.selectFeature = function(options) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    var olLayer = this.map.getLayerByName(options.layerName);
    if (olLayer) {
        options.layer = olLayer;
        CWN2.featureSelecter.selectFeature(options);
    }

};

/**
 *
 * Function: unselectFeature
 *
 * Deselezione programmatica feature di un layer vettoriali.
 *
 * Se piÃ¹ feature soddisfano il criterio di selezione solo la prima viene deselezionata.
 *
 * Se impostato il parametro options.hiliteOnly=true viene fatto solo l'unhighlight della feaure.
 *
 * Se impostato il parametro feature viene deselezionata la feature,
 * altrimenti viene fatta una ricerca della feature sul layer in base alla configurazione del parametro config
 *
 *
  * Parameters:
  * options - {Object} Oggetto di configurazione dell'hilite
  *  - layerName - {String} Nome del layer
  *  - attrName - {String} Nome dell'attributo
  *  - item - {String}/{Number} Valore
  *  - options - {Object} Oggetto configurazione delle opzioni
  *  -  - hiliteOnly - {Boolean} Flag per effettuare solo l'highlight della feature (default: false)
  * feature - {OpenLayers.Feature} Feature da selezionare
  *
  *  Esempio:
  *  (start code)
  * var selectConf = {
  *			"layerName": "Prova",
  *			"attrName": "ID",
  *				"items": "1"
  *			},
  *			"options": {
   *				"hiliteOnly": false
  *			}
  *		};
  *   (end)
  *
  */
CWN2.Application.prototype.unselectFeature = function(options) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    var olLayer = this.map.getLayerByName(options.layerName);
    if (olLayer) {
        options.layer = olLayer;
        CWN2.featureSelecter.unselectFeature(options);
    }

};

/**
*
* Function: loadMap
*
* Effettua il caricamento di una mappa definita in Catalogo SIT
*
*
* Parameters:
* configuration - {Object} Oggetto di configurazione della applicazione
* initOptions - {Object} Oggetto di inizializzazione
*
*/
CWN2.Application.prototype.loadMap = function (configuration, initOptions) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    var idMap = initOptions.idMap;
    var findOptions = initOptions.findOptions;
    var loadBaseLayers = initOptions.loadBaseLayers;


    if (!idMap || idMap === "null") {
        var exception = {};
        exception.message = "manca parametro mappa";
        exception.level = 1;
        CWN2.Util.handleException(exception);
        return;
    }

//    var layerConfigService = "/cartowebnet2/services/config/map/" + idMap;
    var layerConfigService = CWN2.proxy + "http://srvcarto.regione.liguria.it/cartowebnet2/services/config/map/" + idMap;
    if (loadBaseLayers) {
        layerConfigService += "?loadBaseLayers=true";
    }

    var app = this;

    CWN2.Util.getJSON(
        layerConfigService,
        null,
        true,
        function(mapConfig) {
            app.layout.setMapTitle(mapConfig.name);
            app.map.layerManager.addLayers(mapConfig.layers);
            if (mapConfig.extent) {
                setExtent(mapConfig.extent);
            }
            // se tipo mappa Ã¨ raster imposto lo sfondo bianco
            if (mapConfig.type && mapConfig.type == "R") {
                CWN2.Map.setBaseLayerOnMap("sfondo_bianco",app.id);
            }
            // se configurata find la effettuo
            if (findOptions) {
                if (findOptions.idList && findOptions.idList !== "null") {
                    app.findWMS(findOptions);
                } else {
                     exception = {};
                    exception.message = "Lista valori find non impostata";
                    exception.level = 0;
                    CWN2.Util.handleException(exception);
                }
            }
            // richiamo eventuale callback
            app.callback(configuration, initOptions);
        }
    );

};

/**
*
* Function: loadLayers
*
* Effettua il caricamento di layers definita in Catalogo SIT
*
*
* Parameters:
* configuration - {Object} Oggetto di configurazione della applicazione
* initOptions - {Object} Oggetto di inizializzazione
*
*/
CWN2.Application.prototype.loadLayers = function (configuration, initOptions) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    var idLayer = initOptions.idLayer;
    var findOptions = initOptions.findOptions;


    if (!idLayer || idLayer === "null") {
        var exception = {};
        exception.message = "manca parametro layer";
        exception.level = 1;
        CWN2.Util.handleException(exception);
        return;
    }

    var layerConfigService = CWN2.proxy + "http://srvcarto.regione.liguria.it/cartowebnet2/services/config/layer/" + idLayer;

    var app = this;

    CWN2.Util.getJSON(
        layerConfigService,
        null,
        true,
        function(layerConfig) {
            app.map.layerManager.addLayers(layerConfig);
            // se configurata find la effettuo
            if (findOptions) {
                if (findOptions.idList && findOptions.idList !== "null") {
                    app.findWMS(findOptions);
                } else {
                     exception = {};
                    exception.message = "Lista valori find non impostata";
                    exception.level = 0;
                    CWN2.Util.handleException(exception);
                }
            }
            // richiamo eventuale callback
            app.callback(configuration, initOptions);
        }
    );

};

/**
*
* Function: findWMS
*
* Effettua una find con evidenziazione su layer WMS
*
*
* Parameters:
* findOptions - {Object} Oggetto di configurazione dell'hilite
 *  - layerName - {String} Nome del layer
 *  - idField - {String} Nome del campo ID su cui fare il filtro
 *  - idList - {String} Lista dei valori separati da virgola
 *  - zoomLevel - {String} Livello di zoom massimo

*
*/
CWN2.Application.prototype.findWMS = function(findOptions) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";


    var layerName = findOptions.layerName,
        idField = findOptions.idField,
        idList = findOptions.idList,
        zoomLevel = findOptions.zoomLevel,
        map = this.map,
        layerConfig = map.layerManager.getLayerConfigByName(layerName),
        wmsUrl = layerConfig.wmsParams.url,
        typeName = layerConfig.wmsParams.name;

    if (!idList || idList === "null") {
        var exception = {};
        exception.message = "manca parametro idList";
        exception.level = 0;
        CWN2.Util.handleException(exception);
        return;
    }
    var idListArray = idList.split(',');

    // creo il filtro sld
    var sldFilter = CWN2.WmsSldHiliter.getFilter(idField,idListArray);

    var wfsUrl = this.initOptions.proxy + layerConfig.wmsParams.url + "VERSION=1.0.0&SERVICE=WFS&REQUEST=GetFeature&TYPENAME=" + typeName + "&Filter=" + sldFilter;

    // funzione di callback richiamata da Util.getWFSBound
    var hiliteFeature = function (bounds) {
        var hiliteLayerName = "_findWMS";
        var wmsSldHiliter = new CWN2.WmsSldHiliter(map,hiliteLayerName);
        var hiliteLayer = wmsSldHiliter.hiliteFeature(
            layerConfig,
            idField,
            idListArray,
            bounds,
            zoomLevel,
            function() {
                // imposto initial extent della mappa
                map.initialExtent = map.getExtent();
            });
    };

    var bounds = CWN2.Util.getWFSBound(
        wfsUrl,
        typeName,
        sldFilter,
        this.map,
        hiliteFeature);
};

/**
*
* Function: getButtonOptions
*
* Ritorna un oggetto contenente le opzioni di configurazione di un bottone
*
* Parameters:
* buttonID - {String} Id del bottone
*
*/
CWN2.Application.prototype.getButtonOptions = function(buttonId) {
    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    var groups = this.configuration.application.layout.toolbar.itemGroups,
        buttons = {};
    $.map(groups,function( val, i ) {
        $.map(val.items,function( val2, i2 ) {
            buttons[val2.name] = val2.options;
        });
    });
    return buttons[buttonId];
};

/**
*
* Function: setButtonOption
*
* Imposta una opzione di configurazione di un bottone
*
* Parameters:
 * buttonID - {String} Id del bottone
 * optionsName - {String} Nome della opzione
 * optionsValue - {String/Function/Object....} Valore della opzione
*
*/
CWN2.Application.prototype.setButtonOption = function(buttonId,optionName,optionsValue) {
    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    var groups = this.configuration.application.layout.toolbar.itemGroups;
    $.map(groups,function( val, i ) {
        $.map(val.items,function( val2, i2 ) {
            if (val2.name === buttonId) {
                val2.options[optionName] = optionsValue;
            }
        });
    });
};

/**
*
* Function: addToolbarItems
*
* Aggiunge item alla toolbar
*
* Parameters:
 * buttonID - {String} Id del bottone
 * optionsName - {String} Nome della opzione
 * optionsValue - {String/Function/Object....} Valore della opzione
*
*/
CWN2.Application.prototype.addToolbarItems = function(itemsConfig) {
    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    var toolbar = Ext.getCmp('cwn2-toolbar-'+this.id);
    toolbar.add(itemsConfig);


};

//endregion

/**
* 
* Class: CWN2.controlFactory
* 
 * Factory per creazione di controlli OL
 *
*/

CWN2.controlFactory = (function(){

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    // Crea un controllo OpenLayers basato su una determinata configurazione
    function create (controlConfig) {

        CWN2.Util.log("CWN2.controlFactory.create: " + controlConfig.name);

        // provo a creare il controllo
        // guardo prima tra i controlli di CWN2 e poi tra quelli OpenLayers
        // se non riesco mando un'eccezzione
        try {
            return new CWN2.Control[controlConfig.name](controlConfig.options);
        } catch (exception) {
            try {
                return new OpenLayers.Control[controlConfig.name](controlConfig.options);
            } catch (exception) {
                throw {
                    name: "BadOLControl",
                    message: "CWN2.controlFactory.create: control " + controlConfig.name + " non implementato",
                    level: 0
                };
            }
        }

    }

	/*
	*  Public API
	*/	
	
	return {
		
		/**
         *
		* Function: create
        *
        * Crea un controllo OpenLayers basato su una determinata configurazione.
        *
		* Parameters:
        * controlConfig - {Object} Oggetto che contiene la configurazione del controllo
        *
		* Returns:
        * {OpenLayers.Control} - Il controllo OL creato
		* 
		*/ 
		
		create: create
	
	};
}());/*
 *
 * Class: CWN2.Control.DeleteFeature
 *
 * Controllo OpenLayers Custom che permette di cancellare feature sulla mappa.
 *
 *
 */	

/*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/

CWN2.Control.DeleteFeature  = OpenLayers.Class(OpenLayers.Control.SelectFeature, {

    /**
    *
    * Constructor: CWN2.Control.DeleteFeature
    * Costruttore
    *
     * Parameters:
     * layer - {<OpenLayers.Layer.Vector>} Points will be added to this layer.
     * options - {Object} An optional object whose properties will be used
     *     to extend the control.
     *
    */
    initialize: function (layer, options) {


        var deleteControl = this;

        function showConfirmDialog(feature) {
            Ext.Msg.show({
               title:'Conferma',
               msg: 'Sei sicuro di voler cancellare la feature?',
               buttons: {ok: "Si", cancel: "No"},
               fn: function(btn){ manageResult(btn,feature);}
            });
        }

        function manageResult(btn,feature){
            if (btn === 'ok') {
                layer.destroyFeatures([feature]);
            } else {
                deleteControl.unselect(feature);
            }

        }

        OpenLayers.Control.SelectFeature.prototype.initialize.apply(this,
            [layer, {onSelect:showConfirmDialog}]);

    },



    CLASS_NAME: "CWN2.Control.DrawPoint"

});
/*
 *
 * Class: CWN2.Control.DrawLine
 *
 * Controllo OpenLayers Custom che permette di disegnare linee sulla mappa.
 *
 *
 */	

/*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/

CWN2.Control.DrawLine = OpenLayers.Class(OpenLayers.Control.DrawFeature, {

    // flag singleGeometry se impostato a true permette l'inserimento di una sola geometria
    singleFeature: false,

    /**
    *
    * Constructor: CWN2.Control.DrawPoint
    * Costruttore
    *
     * Parameters:
     * layer - {<OpenLayers.Layer.Vector>} Points will be added to this layer.
     * options - {Object} An optional object whose properties will be used
     *     to extend the control.
     *
    */
    initialize: function (layer, options) {

        OpenLayers.Control.DrawFeature.prototype.initialize.apply(this,
            [layer, OpenLayers.Handler.Path, options]);

        if (options && options.singleFeature) {
            this.singleFeature = true;
        }

    },

    /**
    *
    * Function: activate
    * Attiva il controllo, nel parametro params vengono impostati eventuali parametri da passare
    * alla funzione di callback
    *
    * Parameters:
    * params {Object} Oggetto contenente i parametri
    * da passare alla funzione di callback
    *
    */
    activate: function(params) {

        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";

        this.params = params;

        return OpenLayers.Control.prototype.activate.apply(this, arguments);

    },

    /**
     * Method: draw point
     */
    drawFeature: function (geometry) {
        var feature = new OpenLayers.Feature.Vector(geometry),
            proceed = this.layer.events.triggerEvent('sketchcomplete', {feature: feature});
        if (proceed !== false) {
            // se impostato singleGeometry rimuovo le feature
            if (this.singleFeature) {
                this.layer.removeAllFeatures();
            }
            feature.state = OpenLayers.State.INSERT;
            this.layer.addFeatures([feature]);
            this.featureAdded(feature);
            this.events.triggerEvent('featureadded', {feature : feature});
        }
    },


    CLASS_NAME: "CWN2.Control.DrawLine"

});
/*
 *
 * Class: CWN2.Control.DrawPoint
 *
 * Controllo OpenLayers Custom che permette di disegnare punti sulla mappa.
 *
 *
 */	

/*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/

CWN2.Control.DrawPoint = OpenLayers.Class(OpenLayers.Control.DrawFeature, {

    // flag singleGeometry se impostato a true permette l'inserimento di una sola geometria
    singleFeature: false,

    // funzione di callback da richiamare dopo ogni inserimento
    callback: null,

    /**
    *
    * Constructor: CWN2.Control.DrawPoint
    * Costruttore
    *
     * Parameters:
     * layer - {<OpenLayers.Layer.Vector>} Points will be added to this layer.
     * options - {Object} An optional object whose properties will be used
     *     to extend the control.
     *
    */
    initialize: function (layer, options) {

        OpenLayers.Control.DrawFeature.prototype.initialize.apply(this,
            [layer, OpenLayers.Handler.Point, options]);

        if (options && options.singleFeature) {
            this.singleFeature = true;
        }
        if (options && options.callback) {
            this.callback = options.callback;
        }


    },

    /**
    *
    * Function: activate
    * Attiva il controllo, nel parametro params vengono impostati eventuali parametri da passare
    * alla funzione di callback
    *
    * Parameters:
    * params {Object} Oggetto contenente i parametri
    * da passare alla funzione di callback
    *
    */
    activate: function(params) {

        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";

        this.params = params;

        return OpenLayers.Control.prototype.activate.apply(this, arguments);

    },

    /**
     * Method: draw point
     */
    drawFeature: function (geometry) {
        var feature = new OpenLayers.Feature.Vector(geometry),
            proceed = this.layer.events.triggerEvent('sketchcomplete', {feature: feature});
        if (proceed !== false) {
            // se impostato singleGeometry rimuovo le feature
            if (this.singleFeature) {
                this.layer.removeAllFeatures();
            }
            feature.state = OpenLayers.State.INSERT;
            this.layer.addFeatures([feature]);
            this.featureAdded(feature);
            this.events.triggerEvent('featureadded', {feature : feature});
            if (this.callback) {
                this.callback(geometry);
            }
        }
    },


    CLASS_NAME: "CWN2.Control.DrawPoint"

});
/*
 *
 * Class: CWN2.Control.DrawPolygon
 *
 * Controllo OpenLayers Custom che permette di disegnare polugoni sulla mappa.
 *
 *
 */	

/*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/

CWN2.Control.DrawPolygon = OpenLayers.Class(OpenLayers.Control.DrawFeature, {

    // flag singleGeometry se impostato a true permette l'inserimento di una sola geometria
    singleFeature: false,

    /**
    *
    * Constructor: CWN2.Control.DrawPoint
    * Costruttore
    *
     * Parameters:
     * layer - {<OpenLayers.Layer.Vector>} Points will be added to this layer.
     * options - {Object} An optional object whose properties will be used
     *     to extend the control.
     *
    */
    initialize: function (layer, options) {

        OpenLayers.Control.DrawFeature.prototype.initialize.apply(this,
            [layer, OpenLayers.Handler.Polygon, options]);

        if (options && options.singleFeature) {
            this.singleFeature = true;
        }

    },

    /**
    *
    * Function: activate
    * Attiva il controllo, nel parametro params vengono impostati eventuali parametri da passare
    * alla funzione di callback
    *
    * Parameters:
    * params {Object} Oggetto contenente i parametri
    * da passare alla funzione di callback
    *
    */
    activate: function(params) {

        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";

        this.params = params;

        return OpenLayers.Control.prototype.activate.apply(this, arguments);

    },

    /**
     * Method: draw point
     */
    drawFeature: function (geometry) {
        var feature = new OpenLayers.Feature.Vector(geometry),
            proceed = this.layer.events.triggerEvent('sketchcomplete', {feature: feature});
        if (proceed !== false) {
            // se impostato singleGeometry rimuovo le feature
            if (this.singleFeature) {
                this.layer.removeAllFeatures();
            }
            feature.state = OpenLayers.State.INSERT;
            this.layer.addFeatures([feature]);
            this.featureAdded(feature);
            this.events.triggerEvent('featureadded', {feature : feature});
        }
    },


    CLASS_NAME: "CWN2.Control.DrawLine"

});
/*
 *
 * Class: CWN2.Control.RegularPolygon
 *
 * Controllo OpenLayers Custom che permette di disegnare poligoni regolari sulla mappa.
 *
 *
 */	

/*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/

CWN2.Control.DrawRegularPolygon = OpenLayers.Class(OpenLayers.Control.DrawFeature, {

    // flag singleGeometry se impostato a true permette l'inserimento di una sola geometria
    singleFeature: false,

    /**
    *
    * Constructor: CWN2.Control.DrawPoint
    * Costruttore
    *
     * Parameters:
     * layer - {<OpenLayers.Layer.Vector>} Points will be added to this layer.
     * options - {Object} An optional object whose properties will be used
     *     to extend the control.
     *
    */
    initialize: function (layer, options) {

        // passare opzioni per handler
        // es: rettangolo
        // handlerOptions: {
        //    sides: 4,
        //    irregular: true
        // }
        OpenLayers.Control.DrawFeature.prototype.initialize.apply(this,
            [layer, OpenLayers.Handler.RegularPolygon, options]);

        if (options && options.singleFeature) {
            this.singleFeature = true;
        }

    },

    /**
    *
    * Function: activate
    * Attiva il controllo, nel parametro params vengono impostati eventuali parametri da passare
    * alla funzione di callback
    *
    * Parameters:
    * params {Object} Oggetto contenente i parametri
    * da passare alla funzione di callback
    *
    */
    activate: function(params) {

        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";

        this.params = params;

        return OpenLayers.Control.prototype.activate.apply(this, arguments);

    },

    deactivate: function(params) {

        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";

        this.params = params;

        return OpenLayers.Control.prototype.deactivate.apply(this, arguments);

    },

    /**
     * Method: draw feature
     */
    drawFeature: function (geometry) {
        var feature = new OpenLayers.Feature.Vector(geometry),
            proceed = this.layer.events.triggerEvent('sketchcomplete', {feature: feature});
        if (proceed !== false) {
            // se impostato singleGeometry rimuovo le feature
            if (this.singleFeature) {
                this.layer.removeAllFeatures();
            }
            feature.state = OpenLayers.State.INSERT;
            this.layer.addFeatures([feature]);
            this.featureAdded(feature);
            this.events.triggerEvent('featureadded', {feature : feature});
        }
    },


    CLASS_NAME: "CWN2.Control.DrawLine"

});

/**
 * Class: CWN2.Control.LayerSwitcher2
 * Questo controllo visualizza una semplice legenda contenente i livelli della mappa.
 * Permette di accendere/spegnere i livelli e di scegliere il livello base visibile
 *
 * Per creare il LayerSwitcher fuori dalla mappa passare l'id del div html come primo parametro del costruttore
 *
 * Per modificare lo stile e' necessario modificare gli stili delle classi CWN2ControlLayerSwitcher2 nel foglio di stile base.css
 *
 * Inherits from:
 *  - <OpenLayers.Control>
 */

/*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/

CWN2.Control.LayerSwitcher2 =
  OpenLayers.Class(OpenLayers.Control, {

    /**
     * Property: layerStates 
     * {Array(Object)} Basically a copy of the "state" of the map's layers 
     *     the last time the control was drawn. We have this in order to avoid
     *     unnecessarily redrawing the control.
     */
    layerStates: null,
    

  // DOM Elements
  
    /**
     * Property: layersDiv
     * {DOMElement} 
     */
    layersDiv: null,
    
    /** 
     * Property: baseLayersDiv
     * {DOMElement}
     */
    baseLayersDiv: null,

    /** 
     * Property: baseLayers
     * {Array(Object)}
     */
    baseLayers: null,
    
    
    /** 
     * Property: dataLbl
     * {DOMElement} 
     */
    dataLbl: null,
    
    /** 
     * Property: dataLayersDiv
     * {DOMElement} 
     */
    dataLayersDiv: null,

    /** 
     * Property: dataLayers
     * {Array(Object)} 
     */
    dataLayers: null,


    /** 
     * Property: minimizeDiv
     * {DOMElement} 
     */
    minimizeDiv: null,

    /** 
     * Property: maximizeDiv
     * {DOMElement} 
     */
    maximizeDiv: null,
    
    /**
     * APIProperty: ascending
     * {Boolean} 
     */
    ascending: false,
 
    /**
     * Constructor: OpenLayers.Control.LayerSwitcher
     * 
     * Parameters:
     * options - {Object}
     */
    initialize: function(options) {

        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";

        OpenLayers.Control.prototype.initialize.apply(this, arguments);
        this.layerStates = [];

    },

    /**
     * APIMethod: destroy 
     */    
    destroy: function() {
        
        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";

        //clear out layers info and unregister their events
        this.clearLayersArray("base");
        this.clearLayersArray("data");
        
        this.map.events.un({
            buttonclick: this.onButtonClick,
            addlayer: this.redraw,
            changelayer: this.redraw,
            removelayer: this.redraw,
            changebaselayer: this.redraw,
            scope: this
        });
        this.events.unregister("buttonclick", this, this.onButtonClick);
        
        OpenLayers.Control.prototype.destroy.apply(this, arguments);
    },

    /** 
     * Method: setMap
     *
     * Properties:
     * map - {<OpenLayers.Map>} 
     */
    setMap: function(map) {

        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";

        OpenLayers.Control.prototype.setMap.apply(this, arguments);

        this.map.events.on({
            addlayer: this.redraw,
            changelayer: this.redraw,
            removelayer: this.redraw,
            changebaselayer: this.redraw,
            scope: this
        });
        if (this.outsideViewport) {
            this.events.attachToElement(this.div);
            this.events.register("buttonclick", this, this.onButtonClick);
        } else {
            this.map.events.register("buttonclick", this, this.onButtonClick);
        }
    },

    /**
     * Method: draw
     *
     * Returns:
     * {DOMElement} A reference to the DIV DOMElement containing the 
     *     switcher tabs.
     */  
    draw: function() {
        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";

        OpenLayers.Control.prototype.draw.apply(this);
        // create layout divs
        this.loadContents();

        // set mode to minimize
        if(!this.outsideViewport) {
            this.minimizeControl();
        }

        // populate div with current info
        this.redraw();    

        return this.div;
    },

    /**
     * Method: onButtonClick
     *
     * Parameters:
     * evt - {Event}
     */
    onButtonClick: function(evt) {
        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";

        var button = evt.buttonElement;
        if (button === this.minimizeDiv) {
            this.minimizeControl();
        } else if (button === this.maximizeDiv) {
            this.maximizeControl();
        } else if (button._layerSwitcher === this.id) {
            if (button["for"]) {
                button = document.getElementById(button["for"]);
            }
            if (!button.disabled) {
                if (button.type === "radio") {
                    button.checked = true;
                    this.map.setBaseLayer(this.map.getLayer(button._layer));
                } else {
                    button.checked = !button.checked;
                    this.updateMap();
                }
            }
        }
    },

    /** 
     * Method: clearLayersArray
     * User specifies either "base" or "data". we then clear all the
     *     corresponding listeners, the div, and reinitialize a new array.
     * 
     * Parameters:
     * layersType - {String}  
     */
    clearLayersArray: function(layersType) {
        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";
        this[layersType + "LayersDiv"].innerHTML = "";
        this[layersType + "Layers"] = [];
    },


    /**
     * Method: checkRedraw
     * Checks if the layer state has changed since the last redraw() call.
     * 
     * Returns:
     * {Boolean} The layer state changed since the last redraw() call. 
     */
    checkRedraw: function() {
        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";

        var redraw = false;
        if ( !this.layerStates.length ||
             (this.map.layers.length !== this.layerStates.length) ) {
            redraw = true;
        } else {
            for (var i=0, len=this.layerStates.length; i<len; i++) {
                var layerState = this.layerStates[i];
                var layer = this.map.layers[i];
                if ( (layerState.name !== layer.name) ||
                     (layerState.inRange !== layer.inRange) ||
                     (layerState.id !== layer.id) ||
                     (layerState.visibility !== layer.visibility) ) {
                    redraw = true;
                    break;
                }    
            }
        }    
        return redraw;
    },
    
    /** 
     * Method: redraw
     * Goes through and takes the current state of the Map and rebuilds the
     *     control to display that state. Groups base layers into a 
     *     radio-button group and lists each data layer with a checkbox.
     *
     * Returns: 
     * {DOMElement} A reference to the DIV DOMElement containing the control
     */  
    redraw: function() {
        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";
        //if the state hasn't changed since last redraw, no need
        // to do anything. Just return the existing div.
        if (!this.checkRedraw()) { 
            return this.div; 
        } 

        //clear out previous layers 
        this.clearLayersArray("base");
        this.clearLayersArray("data");
        
        var containsOverlays = false,
            containsBaseLayers = false,
            layer,
            baseLayer,
            i;
        
        // Save state -- for checking layer if the map state changed.
        // We save this before redrawing, because in the process of redrawing
        // we will trigger more visibility changes, and we want to not redraw
        // and enter an infinite loop.
        var len = this.map.layers.length;
        this.layerStates = new Array(len);
        for (i = 0; i < len; i++) {
            layer = this.map.layers[i];
            this.layerStates[i] = {
                "name": layer.name,
                "visibility": layer.visibility,
                "inRange": layer.inRange,
                "id": layer.id
            };
        }    

        var layers = this.map.layers.slice();
        if (!this.ascending) { layers.reverse(); }
        for(i = 0, len = layers.length; i < len; i++) {
            layer = layers[i];
            baseLayer = layer.isBaseLayer;
            if (layer.displayInLayerSwitcher) {

                if (baseLayer) {
                    containsBaseLayers = true;
                } else {
                    containsOverlays = true;
                }    

                // only check a baselayer if it is *the* baselayer, check data
                //  layers if they are visible
                var checked = (baseLayer) ? (layer === this.map.baseLayer)
                                          : layer.getVisibility();
    
                // create input element
                var inputElem = document.createElement("input");
                inputElem.id = this.id + "_input_" + layer.name;

                inputElem.type = (baseLayer) ? "radio" : "checkbox";
                inputElem.name = (baseLayer) ? this.id + "_baseLayers" : layer.name;
                inputElem.value = layer.name;
                inputElem.checked = checked;
                inputElem.defaultChecked = checked;
                inputElem.className = "olButton";
                inputElem._layer = layer.id;
                inputElem._layerSwitcher = this.id;

                if (!baseLayer && !layer.inRange) {
                    inputElem.disabled = true;
                }
                
                // create icon
                var iconSpan = document.createElement("icon");
                var labelSpan = document.createElement("label");
                iconSpan._layer = layer.id;
                iconSpan._layerSwitcher = this.id;
                OpenLayers.Element.addClass(iconSpan, "iconSpan olButton");
                layer.legend ? iconSpan.innerHTML = "<img src='" + layer.legend.icon + "' width=15 height=15>" || layer.name : labelSpan.innerHTML =  layer.name;

                // create label
                labelSpan["for"] = inputElem.id;
                OpenLayers.Element.addClass(labelSpan, "labelSpan olButton");
                labelSpan._layer = layer.id;
                labelSpan._layerSwitcher = this.id;
                if (!baseLayer && !layer.inRange) {
                    labelSpan.style.color = "gray";
                }
                layer.legend ? labelSpan.innerHTML = layer.legend.label || layer.name : labelSpan.innerHTML =  layer.name;
                labelSpan.style.verticalAlign = (baseLayer) ? "bottom" : "baseline";

                // create line break
                var br = document.createElement("br");
    
                
                var groupArray = (baseLayer) ? this.baseLayers
                                             : this.dataLayers;
                groupArray.push({
                    "layer": layer,
                    "inputElem": inputElem,
                    "iconSpan": iconSpan,
                    "labelSpan": labelSpan
                });
                                                     
    
                var groupDiv = (baseLayer) ? this.baseLayersDiv
                                           : this.dataLayersDiv;
                groupDiv.appendChild(inputElem);
                groupDiv.appendChild(iconSpan);
                groupDiv.appendChild(labelSpan);
                groupDiv.appendChild(br);
            }
        }

        // if no overlays, dont display the overlay label
        this.dataLbl.style.display = (containsOverlays) ? "" : "none";        
        
        // if no baselayers, dont display the baselayer label
        this.baseLbl.style.display = (containsBaseLayers) ? "" : "none";        

        return this.div;
    },

    /** 
     * Method: updateMap
     * Cycles through the loaded data and base layer input arrays and makes
     *     the necessary calls to the Map object such that that the map's 
     *     visual state corresponds to what the user has selected in 
     *     the control.
     */
    updateMap: function() {

        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";

        var i,
            len,
            layerEntry;

        // set the newly selected base layer        
        for(i = 0, len = this.baseLayers.length; i < len; i++) {
            layerEntry = this.baseLayers[i];
            if (layerEntry.inputElem.checked) {
                this.map.setBaseLayer(layerEntry.layer, false);
            }
        }

        // set the correct visibilities for the overlays
        for(i = 0, len = this.dataLayers.length; i < len; i++) {
            layerEntry = this.dataLayers[i];
            layerEntry.layer.setVisibility(layerEntry.inputElem.checked);
        }

    },

    /** 
     * Method: maximizeControl
     * Set up the labels and divs for the control
     * 
     * Parameters:
     * e - {Event} 
     */
    maximizeControl: function(e) {
        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";
        // set the div's width and height to empty values, so
        // the div dimensions can be controlled by CSS
        this.div.style.width = "";
        this.div.style.height = "";

        this.showControls(false);

        if (e != null) {
            OpenLayers.Event.stop(e);                                            
        }
    },
    
    /** 
     * Method: minimizeControl
     * Hide all the contents of the control, shrink the size, 
     *     add the maximize icon
     *
     * Parameters:
     * e - {Event} 
     */
    minimizeControl: function(e) {
        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";
        // to minimize the control we set its div's width
        // and height to 0px, we cannot just set "display"
        // to "none" because it would hide the maximize
        // div
        this.div.style.width = "0px";
        this.div.style.height = "0px";

        this.showControls(true);

        if (e != null) {
            OpenLayers.Event.stop(e);                                            
        }
    },

    /**
     * Method: showControls
     * Hide/Show all LayerSwitcher controls depending on whether we are
     *     minimized or not
     * 
     * Parameters:
     * minimize - {Boolean}
     */
    showControls: function(minimize) {
        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";
        this.maximizeDiv.style.display = minimize ? "" : "none";
        this.minimizeDiv.style.display = minimize ? "none" : "";

        this.layersDiv.style.display = minimize ? "none" : "";
    },
    
    /** 
     * Method: loadContents
     * Set up the labels and divs for the control
     */
    loadContents: function() {
        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";
        // layers list div        
        this.layersDiv = document.createElement("div");
        this.layersDiv.id = this.id + "_layersDiv";
        OpenLayers.Element.addClass(this.layersDiv, "layersDiv");
        this.baseLbl = document.createElement("div");
        this.baseLbl.innerHTML = CWN2.i18n.get("Sfondi");
        OpenLayers.Element.addClass(this.baseLbl, "baseLbl");
        
        this.baseLayersDiv = document.createElement("div");
        OpenLayers.Element.addClass(this.baseLayersDiv, "baseLayersDiv");

        this.dataLbl = document.createElement("div");
        this.dataLbl.innerHTML = CWN2.i18n.get("Livelli");
        OpenLayers.Element.addClass(this.dataLbl, "dataLbl");
        
        this.dataLayersDiv = document.createElement("div");
        OpenLayers.Element.addClass(this.dataLayersDiv, "dataLayersDiv");

        if (this.ascending) {
            this.layersDiv.appendChild(this.baseLbl);
            this.layersDiv.appendChild(this.baseLayersDiv);
            this.layersDiv.appendChild(this.dataLbl);
            this.layersDiv.appendChild(this.dataLayersDiv);
        } else {
            this.layersDiv.appendChild(this.dataLbl);
            this.layersDiv.appendChild(this.dataLayersDiv);
            this.layersDiv.appendChild(this.baseLbl);
            this.layersDiv.appendChild(this.baseLayersDiv);
        }    
 
        this.div.appendChild(this.layersDiv);


        // maximize button div
        var img = OpenLayers.Util.getImageLocation("layer-switcher-maximize.png");
/*
        this.maximizeDiv = OpenLayers.Util.createAlphaImageDiv(
                                    "OpenLayers_Control_MaximizeDiv", 
                                    null, 
                                    null, 
                                    img, 
                                    "absolute");
*/
        this.maximizeDiv = OpenLayers.Util.createDiv();
        OpenLayers.Element.addClass(this.maximizeDiv, "maximizeDiv olButton");
        this.maximizeDiv.style.display = "none";
        
        this.div.appendChild(this.maximizeDiv);

        // minimize button div
        var img2 = OpenLayers.Util.getImageLocation("layer-switcher-minimize.png");
/*
        this.minimizeDiv = OpenLayers.Util.createAlphaImageDiv(
                                    "OpenLayers_Control_MinimizeDiv", 
                                    null, 
                                    null, 
                                    img, 
                                    "absolute");
*/
        this.minimizeDiv = OpenLayers.Util.createDiv();
        OpenLayers.Element.addClass(this.minimizeDiv, "minimizeDiv olButton");
        this.minimizeDiv.style.display = "none";

        this.div.appendChild(this.minimizeDiv);
    },
    
    CLASS_NAME: "CWN2.Control.LayerSwitcher2"
});
/**
 * Class: CWN2.Control.Zoom
 * Il controllo Zoom visualizza due bottoni sulla mappa per effettuare zoom in e zoom out.
 *
 * Per modificare lo stile agire sugli elementi #customZoom del foglio di stile base.css
 *
 * Inherits from:
 *  - <OpenLayers.Control.Zoom>
 */
/*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
CWN2.Control.Zoom = OpenLayers.Class(OpenLayers.Control.Zoom, {

    getOrCreateLinks: function(el) {
        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";

        var CUSTOM_ZOOM_IN_ID = "customZoomIn",
            CUSTOM_ZOOM_OUT_ID = "customZoomOut";


        this.zoomInId = CUSTOM_ZOOM_IN_ID;
        this.zoomOutId = CUSTOM_ZOOM_OUT_ID;

        el["class"] = null;
        el["id"] = "customZoom";

        var zoomIn = document.createElement("a");
        zoomIn.href = "#zoomIn";
        zoomIn.appendChild(document.createTextNode(this.zoomInText));
        zoomIn.id = CUSTOM_ZOOM_IN_ID;
        el.appendChild(zoomIn);
        OpenLayers.Element.addClass(zoomIn, "olButton");
        var zoomOut = document.createElement("a");
        zoomOut.href = "#zoomOut";
        zoomOut.appendChild(document.createTextNode(this.zoomOutText));
        zoomOut.id = CUSTOM_ZOOM_OUT_ID;
        el.appendChild(zoomOut);


        OpenLayers.Element.addClass(zoomOut, "olButton");
        return {
            zoomIn: zoomIn, zoomOut: zoomOut
        };

    },

    CLASS_NAME: "CWN2.Control.Zoom"
});
/**
 * Class: CWN2.Control.ZoomToInitialExtent
 * The ZoomToExtent control is a button that zooms out to the initial extent
 * of the map.
 * 
 * Inherits from:
 *  - <OpenLayers.Control>
 */
/*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
CWN2.Control.ZoomToInitialExtent = OpenLayers.Class(OpenLayers.Control, {

    /**
     * Property: type
     * {String} The type of <OpenLayers.Control> -- When added to a 
     *     <Control.Panel>, 'type' is used by the panel to determine how to 
     *     handle our events.
     */
    type: OpenLayers.Control.TYPE_BUTTON,
    
    /*
     * Method: trigger
     * Do the zoom.
     */
    trigger: function() {
        if (this.map) {
            this.map.zoomToInitialExtent();
        }    
    },

    CLASS_NAME: "OpenLayers.Control.ZoomToExtent"
});
/*
 *
 * Class: CWN2.Control.getMapCoordinatesOnClick
 *
 * Controllo OpenLayers Custom che permette di richiamare una funzione di callback sull evento click sulla mappa OL.
 *
 * In fase di attivazione del controllo e' possibile impostare i parametri da passare alla funzione di callback.
 *
 *  Esempio:
 *  (start code)
 *  var clickMapCtrl = new CWN2.Control.getMapCoordinatesOnClick({
 *      callback: setPointOnMap
 *  });
 *  clickMapCtrl.activate({
 *      type: "start"
 *  });
 *  (end)
 *
 */	

/*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/

CWN2.Control.getMapCoordinatesOnClick = OpenLayers.Class(OpenLayers.Control, {

    // funzione da richiamare al click
    callback: null,

    // opzioni: oggetto che viene passato alla funzione di callback
    params: {},

    /**
    *
    * Constructor: CWN2.Control.getMapCoordinatesOnClick
    * Costruttore
    *
    * Parameters:
    * callback - {Function} funzione di callback da richiamare al click
    *
    */
    initialize: function(callback) {

        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";

        // controllo che callback sia una funzione
        try {
            CWN2.Util.assert(
                (typeof callback === "function"),
                {
                    name: "NotFunction",
                    message: "CWN2.Control.getMapCoordinatesOnClick: parametro deve essere una funzione",
                    level: 1
                }
            );
        } catch (exception) {
            CWN2.Util.handleException(exception);
            return null;
        }

        this.callback = callback;

        OpenLayers.Control.prototype.initialize.apply(this, [callback]);

        var callbacks = {};
        callbacks["click"] = this.getInfoForClick;
        this.handler = new OpenLayers.Handler.Click(
            this,
            callbacks
        );

    },

    /**
    *
    * Function: activate
    * Attiva il controllo, nel parametro params vengono impostati eventuali parametri da passare
    * alla funzione di callback
    *
    * Parameters:
    * params {Object} Oggetto contenente i parametri
    * da passare alla funzione di callback
    *
    */
    activate: function(params) {

        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";

        this.params = params;

        return OpenLayers.Control.prototype.activate.apply(this, arguments);

    },

    // funzione richiamata al click
    // calcola le coordinate e richiama la funzione di callback passando le coordinate
    // ed eventuali parametri

    getInfoForClick: function(evt) {

        /*global CWN2:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/
        "use strict";

        var mapCoord,
            displayCoord,
            wgs84Coord;

        mapCoord = this.map.getLonLatFromPixel(evt.xy);
        displayCoord = mapCoord.clone();
        wgs84Coord = mapCoord.clone();

        if (this.map.getProjectionObject() !== this.map.displayProjection) {
            displayCoord = displayCoord.transform(
                this.map.getProjectionObject(),
                this.map.displayProjection
            );
        }

        if (this.map.projection !== "EPSG:4326") {
            wgs84Coord = wgs84Coord.transform(
                this.map.getProjectionObject(),
                new OpenLayers.Projection("EPSG:4326")
            );
        }

        if (typeof this.callback === "function") {
            this.callback(mapCoord,displayCoord,wgs84Coord,this.params);
        }
    },

    CLASS_NAME: "CWN2.Control.getMapCoordinatesOnClick"

});
/**
* 
* Class: CWN2.featureHiliter
* 
* Permette di effettuare l'evidenziazione delle feature vettoriali.
*
*/

CWN2.featureHiliter = (function(){

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";


	/*
      private properties
	*/
	
    var hilitedFeaturesRegistry = {};


	/*
      private methods
	*/


    // Evidenziazione dinamica feature di layer vettoriali
    function hiliteFeatures(hiliteConfig) {
        CWN2.Util.log("CWN2.featureHiliter.hiliteFeatures");

        try {
            CWN2.Util.assert(hiliteConfig,
                {
                    name: "BadParameter",
                    message: "CWN2.featureHiliter.hiliteFeatures: selectConfig deve essere valorizzato",
                    level: 1
                }
            );
            CWN2.Util.assert(hiliteConfig.layer,
                {
                    name: "BadParameter",
                    message: "CWN2.featureHiliter.hiliteFeatures: layer deve essere valorizzato",
                    level: 1
                }
            );
            CWN2.Util.assert(hiliteConfig.filter,
                {
                    name: "BadParameter",
                    message: "CWN2.featureHiliter.hiliteFeatures: filter deve essere valorizzato",
                    level: 1
                }
            );
            CWN2.Util.assert(hiliteConfig.filter.type === "BY_ATTRIBUTE",
                {
                    name: "BadParameter",
                    message: "CWN2.featureHiliter.hiliteFeatures: filter.type deve essere di tipo BY_ATTRIBUTE",
                    level: 1
                }
            );
            if (hiliteConfig.filter.type === "BY_ATTRIBUTE") {
                CWN2.Util.assert(hiliteConfig.filter.attrName,
                    {
                        name: "BadParameter",
                        message: "CWN2.featureHiliter.hiliteFeatures: attrName deve essere valorizzato se filterType = BY_ATTRIBUTE",
                        level: 1
                    }
                );
                CWN2.Util.assert(hiliteConfig.filter.items,
                    {
                        name: "BadParameter",
                        message: "CWN2.featureHiliter.hiliteFeatures: items deve essere valorizzato se filterType = BY_ATTRIBUTE",
                        level: 1
                    }
                );
                CWN2.Util.assert(hiliteConfig.filter.items instanceof Array,
                    {
                        name: "BadParameter",
                        message: "CWN2.featureHiliter.hiliteFeatures: items deve essere un array se filterType = BY_ATTRIBUTE",
                        level: 1
                    }
                );
            }
        } catch(exception) {
            CWN2.Util.handleException(exception);
            return;
        }

        var layer = hiliteConfig.layer,
            options = hiliteConfig.options || {"zoom" : true},
            zoom = options.zoom,
            maxZoomLevel = options.maxZoomLevel;

        // cerco nelle feature del layer quelle in configurazione
        // se il layer non si è ancora caricato lo faccio sull'evento "loadend"
        if (!layer.loadend) {
            layer.events.register("loadend", layer, function() {
                hilite(hiliteConfig);
            });
        } else {
            hilite(hiliteConfig);
        }

    }


    // cerca nelle feature del layer quelle in configurazione e le evidenzia
	function hilite(hiliteConfig) {

		// configurazione hilite
		var layer = hiliteConfig.layer,
            filterType = hiliteConfig.filter.type,
            attrName = hiliteConfig.filter.attrName,
            items = hiliteConfig.filter.items,
            foundFeatures,
            mapId = layer.map.id,
            options = hiliteConfig.options || {"zoom" : true},
            zoom = options.zoom,
            maxZoomLevel = options.maxZoomLevel;

		if (filterType==="BY_ATTRIBUTE") {
            var hiliteFeatureControl = layer.map.featureManager.hiliteFeatureControl;
            var hilitedFeatures = [];
            var len = items.length;
            for (var i = 0; i < len; i++) {
				foundFeatures = layer.getFeaturesByAttribute(attrName,items[i]);
                var len2 = foundFeatures.length;
                for (var f = 0; f < len2; f++) {
                    hilitedFeatures.push(foundFeatures[f]);
                    hiliteFeature(hiliteFeatureControl,foundFeatures[f]);
				}
			}
            setHilitedFeatures(mapId,hilitedFeatures);
		}

        // se impostato flag per zoom faccio lo zoom
        if (zoom) {
            layer.map.zoomToFeatures(getHilitedFeatures(mapId),maxZoomLevel);
        }
	}

    // Evidenzia una feature
    function hiliteFeature(hiliteFeatureControl,feature) {
        CWN2.Util.log("CWN2.featureHiliter.hiliteFeature");
        hiliteFeatureControl.highlight(feature);
    }


    // Azzeramento evidenziazione feature di layer vettoriali
    function resetHilite(map){
        CWN2.Util.log("CWN2.featureHiliter.resetHilite");

        var hilitedFeatures = getHilitedFeatures(map.id);

        if (!hilitedFeatures) {
            return;
        }
        // copio le features selezionate in un array di appoggio
        var appoSelected = [],
            numFeatures = hilitedFeatures.length,
            i,
            i2;

        if (numFeatures) {
            for (i = 0; i < numFeatures; i++) {
                appoSelected.push(hilitedFeatures[i]);
            }
        }

        // azzero l'array delle feature selezionate
        setHilitedFeatures(map.id,[]);

        // azzero la evidenziazione
        numFeatures = appoSelected.length;
        if (numFeatures) {
            var hiliteFeatureControl = map.featureManager.hiliteFeatureControl;
            for (i2 = 0; i2 < numFeatures; i2++) {
                hiliteFeatureControl.unhighlight(appoSelected[i2]);
            }
        }
    }

    // Ritorna le feature evidenziate
    function getHilitedFeatures(mapId) {

        return hilitedFeaturesRegistry[mapId];

    }

    // Ritorna le feature evidenziate
    function setHilitedFeatures(mapId,features) {

        hilitedFeaturesRegistry[mapId] = features;

    }


	/*
  Public API
	*/
	return {

        /**
        *
        * Function: hiliteFeatures
        *
        * Evidenziazione dinamica feature di layer vettoriali.
        *
        * Utilizzata per applicazioni con integrata la cartografia (vedi EsempioWindow.js) o
        * da bottoni della applicazione (p.es: ricerche/find/filtri, ecc...)
        *
        * Parameters:
        * hiliteConfig - {Object} Oggetto di configurazione dell'hilite
        *  - layerName - {String} Nome del layer
        *  - filter - {Object} Oggetto configurazione del filtro
        *  -  - type - {String}  Tipo di filtro (BY_ATTRIBUTE,SLD,CQL)
        *  -  - attrName - {String} Nome dell'attributo (per filtro di tipo BY_ATTRIBUTE)
        *  -  - items - {Array} Array di valori (per filtro di tipo BY_ATTRIBUTE)
        *  -  - text - {String} Stringa contentente il filtro nel formato SLD o CQL
        *  - options - {Object} Oggetto configurazione delle opzioni
        *  -  - zoom - {Boolean} Flag per impostare lo zoom sulle feature caricate
        *
        *  Esempio:
        *  (start code)
        * var hiliteConf = {
        *			"layerName": "Prova",
        *			"filter" : {
        *				"type": "BY_ATTRIBUTE",
        *				"attrName": "ID",
        *				"items": ["1","2"]
        *			},
        *			"options": {
        *				"zoom": false
        *			}
        *		};
        *   (end)
        *
        */
        hiliteFeatures : hiliteFeatures,

        /**
        *
        * Function: hiliteFeature
         *
         * Evidenziazione di una feature
         *
         * Utilizzata da OpenLayersExt: OpenLayers.Control.SelectFeature.prototype.unhighlight
         *
        * Parameters:
         * feature - {OpenLayers.Feature} feature da evidenziare
        */
        hiliteFeature : hiliteFeature,

        /**
        *
        * Function: resetHilite
        *
        * Azzeramento evidenziazione feature di layer vettoriali.
        *
        * Utilizzata per applicazioni con integrata la cartografia (vedi EsempioWindow.js) o da bottoni della applicazione (p.es: ricerche/find/filtri, ecc...)
        *
        */
		resetHilite : resetHilite,

        /**
        * Funzione che ritorna le feature attualmente evidenziate
        * Returns: {Array}
        * Parameters:
        * feature - {OpenLayers.Feature} feature da evidenziare
        */
        getHilitedFeatures: getHilitedFeatures

	};

}());
/**
*
* Class: CWN2.featureLoader
 *
 * Oggetto per il caricamento delle feature vettoriali
 *
*
*/

CWN2.featureLoader = (function(){

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

	/*
      private properties
    */

	/*
        private methods
	*/


    // Carica le feature in formato GeoJSON in un layer di tipo OpenLayers.Layer.Vector
    function loadFeatures(config) {
        CWN2.Util.log("CWN2.featureLoader.loadFeatures");

        var features,
            url,
            layer;

        // controlli configurazione
        try {
            CWN2.Util.assert(config,
                {
                    name: "BadParameter",
                    message: "CWN2.featureLoader.loadFeatures: oggetto di configurazione deve essere valorizzato",
                    level: 1
                }
            );
            CWN2.Util.assert(config.layer,
                {
                    name: "BadParameter",
                    message: "CWN2.featureLoader.loadFeatures: Layer non trovato",
                    level: 1
                }
            );
            CWN2.Util.assert(config.url || config.features,
                {
                    name: "BadParameter",
                    message: "CWN2.featureLoader.loadFeatures: url o features devono essere valorizzati",
                    level: 1
                }
            );
        } catch(e) { throw e; }

        // impostazione parametri
        layer = config.layer;
        features = config.features;
        url = config.url;


        // se impostato parametro layerLegendUrl
        // cambio la legenda del layer
        if (config.layerLegendUrl) {
            var styles = layer.styleMap.styles;
            for (var stile in styles) {
                var rule = styles[stile].rules[0];
                rule.symbolizer.externalGraphic = config.layerLegendUrl;
            }
        }


        // gestione simbologia custom per singola feature(immagine e dimensioni)
        if (config.customFeatureImg || config.customFeatureSize) {
            var externalGraphic = layer.styleMap.styles["default"].rules[0].symbolizer.externalGraphic,
                graphicTitle = layer.styleMap.styles["default"].rules[0].symbolizer.graphicTitle,
                graphicWidth = layer.styleMap.styles["default"].rules[0].symbolizer.graphicWidth ,
                graphicHeight = layer.styleMap.styles["default"].rules[0].symbolizer.graphicHeight,
                graphicOpacity = layer.styleMap.styles["default"].rules[0].symbolizer.graphicOpacity,
                graphicXOffset = layer.styleMap.styles["default"].rules[0].symbolizer.graphicXOffset,
                graphicYOffset = layer.styleMap.styles["default"].rules[0].symbolizer.graphicYOffset;
            if (config.customFeatureImg) {
                externalGraphic = "${img}";
            }
            if (config.customFeatureSize) {
                graphicWidth = "${width}";
                graphicHeight = "${height}";
            }
            var style = new OpenLayers.Style({
                externalGraphic: externalGraphic,
                graphicTitle: graphicTitle,
                graphicWidth: graphicWidth ,
                graphicHeight: graphicHeight,
                graphicOpacity: graphicOpacity,
                graphicXOffset: graphicXOffset,
                graphicYOffset: graphicYOffset
            });
            layer.styleMap = new OpenLayers.StyleMap(style);
        }

        // imposto il flag loadend sul layer a false
        // viene poi reimpostato alla fine del caricamento richiamando l'evento loadend
        layer.loadend=false;

        // caricamento feature
        try {
            // se impostate le feature carico direttamente
            if (features) {
                loadFeaturesCB(features,config);
            }
            if (url) {
                CWN2.Util.getJSONP(
                    url,
                    null,
                    function(features) {
                        loadFeaturesCB(features, config);
                    }
                );
            }
        }
        catch (exception) {
            CWN2.Util.handleException(exception);
        }

    }


    // Carica le feature in formato GeoJSON in un layer di tipo OpenLayers.Layer.Vector a partire da un indirizzo
    function loadFeatureByAddress(config) {
        CWN2.Util.log("CWN2.featureLoader.loadFeatureByAddress");

        // controlli configurazione
        try {
            CWN2.Util.assert(config,
                {
                    name: "BadParameter",
                    message: "CWN2.featureLoader.loadFeatureByAddress: oggetto di configurazione deve essere valorizzato",
                    level: 1
                }
            );
            CWN2.Util.assert(config.layer,
                {
                    name: "BadParameter",
                    message: "CWN2.featureLoader.loadFeatureByAddress: Layer non trovato",
                    level: 1
                }
            );
            CWN2.Util.assert(config.address,
                {
                    name: "BadParameter",
                    message: "CWN2.featureLoader.loadFeatureByAddress: indirizzo deve essere valorizzato",
                    level: 1
                }
            );
        } catch(e) { throw e; }

        // impostazione parametri
        var layer = config.layer,
            address = config.address,
            html = config.html,
            properties = {
                "infoPopUp": html,
                "label": address,
                "tooltip": address
            };

        // imposto il flag loadend sul layer a false
        // viene poi reimpostato alla fine del caricamento richiamando l'evento loadend
        layer.loadend=false;

        // geocoding e caricamento feature
        try {
            CWN2.Util.geoCode(
                address,
                properties,
                function(result) {
                    loadFeaturesCB(result, config);
                }
            );
        }
        catch (exception) {
            CWN2.Util.handleException(exception);
        }

    }

    // funzione di callback che carica le feature sul layer
	function loadFeaturesCB (features, config) {

        var options,
            zoom,
            zoomLevel,
            clean,
            layer,
            featureCollection,
            setInitialExtent;

        layer = config.layer;
        options = config.options || {"zoom" : true , "zoomLevel" : 16, "clean": false};

        zoom = options.zoom;
        zoomLevel = options.zoomLevel;
        clean = options.clean;
        setInitialExtent = options.setInitialExtent;

        try {
            // deserializzo GeoJSON
            featureCollection = createFeaturesByGeoJSON(layer, features);

            // se impostato il flag clean ripulisco il layer
            if (clean) {
                layer.destroyFeatures();
            }

            // carico le feature sul layer
            layer.addFeatures(featureCollection);

            layer.redraw();

            // se impostato flag per zoom faccio lo zoom
            if (zoom) {
                layer.map.zoomToFeatures(featureCollection,zoomLevel);
            }

            // se impostato flag per impostare initialExtent della mappa lo imposto
            if (setInitialExtent) {
                layer.map.setInitialExtent(layer.map.getExtent());
            }

        }
        catch (exception) {
            throw {
                name: "BadFeatureFormat",
                message: "CWN2.featureLoader.loadFeatures: Non sono riuscito a caricare le feature",
                level: 1
            };
        }


        // reimposto il loadend a true
        layer.events.triggerEvent("loadend");

    }

    // deserializza il GeoJSON in una featureCollection
    function createFeaturesByGeoJSON(layer, features) {
    // definisco il formato
        var format_geojson = new OpenLayers.Format.GeoJSON({
            "internalProjection": new OpenLayers.Projection(layer.map.projection),
            "externalProjection": layer.projection
        });
        // deserializzo il json nelle feature
        return format_geojson.read(features);
    }


	/*
        Public API
	*/
	return {

        /**
        *
        * Function: loadFeatures
        *
        * Carica le feature in formato GeoJSON in un layer di tipo OpenLayers.Layer.Vector
        *
        * Parameters:
        * loadConfig - {Object} Oggetto di configurazione
        *  - layer - {OpenLayers.Layer} Layer
        *  - features - {Object} Oggetto GeoJSON contenente le feature
		*  - url - {String} URL del servizio/file con serve le feature
        *  - options - {Object} Oggetto configurazione delle opzioni
        *  - - zoom - {Boolean} Flag per impostare lo zoom sulle feature caricate
        *  - - clean - {Boolean} Flag per indicare se bisogna cancellare eventuali feature preesistenti
        *
        *
        */
		loadFeatures : loadFeatures,

        /**
        *
        * Function: loadFeatureByAddress
        *
        * Effettua geocoding e caricamento di un indirizzo
        *
        * Parameters:
        * loadConfig - {Object} Oggetto di configurazione
        *  - layer - {OpenLayers.Layer} Layer
        *  - address - {String} Indirizzo da geocodificare
        *  - options - {Object} Oggetto configurazione delle opzioni
        *  - - zoom - {Boolean} Flag per impostare lo zoom sulle feature caricate
        *  - - zoomLevel - {Int} Livello di zoom
        *  - - clean - {Boolean} Flag per indicare se bisogna cancellare eventuali feature preesistenti
        *
        *
        */
		loadFeatureByAddress : loadFeatureByAddress

	};

}());
/**
* 
* Class: CWN2.InfoPopupManager
*
* Gestore delle funzioni per la info e le popup
*
*
*/
CWN2.InfoPopupManager = (function(){
    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    return {

        /**
         *
         * Function: onFeatureSelect
         *
         * Gestisce le operazioni di info e gestione popup.
         * Richiamato sulla select della feature
         *
         * Parameters:
         * feature - {OpenLayers.Feature} Feature
         *
         */
        onFeatureSelect: function(feature) {

            // Imposto la opzioni di configurazione
            var configOptions = CWN2.InfoPopupManager.getConfigOptions(feature);

            // Gestione infoPopUp
            if (configOptions.infoPopUp) {
                CWN2.InfoPopupManager.loadPopUp(feature,configOptions);
            } else {
                // Gestione infoUrl
                if (configOptions.infoUrl) {
                    CWN2.InfoPopupManager.info(feature,configOptions);
                }
            }

        },

        /**
         *
         * Function: onFeatureUnselect
         *
         * Gestisce le operazioni di info e gestione popup.
         * Richiamato sulla unselect della feature
         *
         * Parameters:
         * feature - {OpenLayers.Feature} Feature
         *
         */
        onFeatureUnselect: function(feature) {
            // se esiste una popup la chiudo
            CWN2.InfoPopupManager.destroyPopup(feature);
        },

        getConfigOptions: function(feature) {

            var infoAppo = {
                "infoLabelAttr" : null,
                "infoUrl" : null,
                "infoTarget" : null,
                "infoWidth" : null,
                "infoHeight" : null,
                "infoPopUp" : null
            },
            configOptions = {};

            configOptions.layerName = feature.layer.name;
            configOptions.layerConfig = feature.layer.map.layerManager.getLayerConfigByName(configOptions.layerName) || {};
            configOptions.infoOptions = configOptions.layerConfig.infoOptions || infoAppo;
            configOptions.infoLabelAttr = feature.attributes.infoLabelAttr || configOptions.infoOptions.infoLabelAttr;
            configOptions.infoUrl = feature.attributes.infoUrl || configOptions.infoOptions.infoUrl;
            configOptions.infoTarget = feature.attributes.infoTarget || configOptions.infoOptions.infoTarget;
            configOptions.infoWidth =  feature.attributes.infoWidth || configOptions.infoOptions.infoWidth;
            configOptions.infoHeight =  feature.attributes.infoHeight || configOptions.infoOptions.infoHeight;
            configOptions.infoPopUp = feature.attributes.infoPopUp || configOptions.infoOptions.infoPopUp;

            return configOptions;
        },

        info: function(feature,configOptions) {

            // attribute replacement {$attribute_name} - utilizzo la funzione OpenLayers.Style.createLiteral
            var infoUrl = OpenLayers.Style.createLiteral(configOptions.infoUrl, feature.attributes, feature);

            var map = feature.layer.map;


            if (configOptions.infoTarget) {
                if (configOptions.infoTarget === "panel") {
                    var id = "layerInfoMediaWin";
                    var mediaWin = new CWN2.ExtMediaWindow(infoUrl,configOptions.infoWidth,configOptions.infoHeight,id);
                    // gestisco la deselezione della feature quando chiudo la finestra
                    mediaWin.on("destroy",
                            function() {
                                map.featureManager.selectFeatureControl.unselect(this);
                            },
                            feature
                        );
                    mediaWin.show();
                }
                else {
                    var options = "status=yes, toolbar=yes, menubar=no, width=" + configOptions.infoWidth + ", height=" + configOptions.infoHeight + ", resizable=yes, scrollbars=yes";
                    window.open(infoUrl, configOptions.infoTarget, options);
                }
            } else {
                window.document.location.href = infoUrl;
            }

        },


        loadPopUp: function(feature,configOptions) {

            var infoPopUp = configOptions.infoPopUp,
                popUpWidth = 150,
                popUpHeight = 100,
                maxPopUpWidth = 300,
                maxPopUpHeight = 200,
                closeBox = true,
                popup;

            // costruisco l'html per il default
            if (infoPopUp==="default") {
                infoPopUp = CWN2.InfoPopupManager.buildDefaultPopup(configOptions);
            }

            // se cluster costruisco popup per il cluster
            if(feature.cluster) {
                if (feature.attributes.count > 1) {
                    infoPopUp = CWN2.InfoPopupManager.buildClusterPopup(configOptions,feature);
                } else {
                    feature.attributes = feature.cluster[0].attributes;
                    feature.attributes.count = 1;
                }
            }

            // attribute replacement {$attribute_name} - utilizzo la funzione OpenLayers.Style.createLiteral
            infoPopUp = OpenLayers.Style.createLiteral(infoPopUp, feature.attributes, feature);

            // decodifico eventuali encoding html (&amp;, ecc...)
            infoPopUp = CWN2.Util.unescapeHtmlEntities(infoPopUp);

            //costruisco la popup
            //var popup = new OpenLayers.Popup.Anchored(
            popup = new OpenLayers.Popup.FramedCloud(
                "featurePopup",
                 feature.geometry.getBounds().getCenterLonLat(),
                 new OpenLayers.Size(popUpWidth,popUpHeight),
                 infoPopUp,
                 null,
                 closeBox,
                function(evt) {
                    // 'this' is the popup.
                    this.feature.layer.map.featureManager.selectFeatureControl.unselect(this.feature);
                }
            );
            popup.maxSize = new OpenLayers.Size(maxPopUpWidth,maxPopUpHeight);

        // aggiungo alla feature e alla mappa
            // HACK per risolvere il seguente malfunzionamento
            // Se aggiungo un layer vettoriale mi si sputtanano le pop-up (non vengono cancellate sull'unselect, non funziona il tasto close).
            // il problema è legato al fatto che viene chiamato due volte la funzione onFeatureSelect e quindi create due popup sulla feature
            // Quindi creo la popup sulla feature solo se non esiste già
            if (!feature.popup) {
                feature.popup = popup;
                popup.feature = feature;
                popup.panMapIfOutOfView = true;
                // imposto lo sfondo delle popup
                popup.backgroundColor = "#BBCCFF";
                popup.opacity=0.9;
                // aggiungo la popup alla mappa
                feature.layer.map.addPopup(popup);
            }
        },

        buildDefaultPopup: function(configOptions) {

            var defaultPopUp = "<div class='defaultPopUpTitle'>" + configOptions.layerConfig.legend.label + "<br><br></div>";
            defaultPopUp += "<div class='defaultPopUpLabel'>${" + configOptions.infoLabelAttr + "}<br><br></div>";
            if (configOptions.infoUrl) {
                defaultPopUp += "<div class='defaultPopUpLink'><a href=" + configOptions.infoUrl;
                if(configOptions.infoTarget) {
                    defaultPopUp += " target='" + configOptions.infoTarget + "'";
                }
                defaultPopUp += ">Dettagli</a></div>";
            }
            return defaultPopUp;

        },

        buildClusterPopup: function(configOptions,feature) {
            var appId = feature.layer.map.appId;
            var layerName = feature.layer.name;
            var featureId = feature.id;

            var clusterPopUp = "<div class='defaultPopUpTitle'>" + configOptions.layerConfig.legend.label + "<br><br></div>";
            clusterPopUp += "<div class='defaultPopUpLabel'>" + feature.attributes.count + " Elementi<br><br></div>";
            clusterPopUp += "<div class='defaultPopUpLink'>"
            clusterPopUp += "<a href=javascript:CWN2.InfoPopupManager.zoomClusterPopup(" + appId + "," + feature.geometry.x + "," + feature.geometry.y + ",'" + layerName + "','" + featureId + "')>Zoom</a></div>" ;

            return clusterPopUp;
        },

        zoomClusterPopup: function(appId,x,y,layerName,featureId) {
            var map = CWN2.appRegistry.get(appId).map;
            var layer = map.getLayerByName(layerName);
            var feature = layer.getFeatureById(featureId);

            CWN2.InfoPopupManager.destroyPopup(feature);

            var zoomLevel = map.zoom + 2;
            map.zoomToPoint(x,y,zoomLevel);
        },

        destroyPopup: function(feature) {
            if (feature.popup) {
                var map = feature.layer.map;
                var popup = feature.popup;
                popup.feature = null;
                map.removePopup(feature.popup);
                feature.popup.destroy();
                feature.popup = null;
            }
        }


    };

}());

/**
* 
* Class: CWN2.FeatureManager
*
* Gestore dei controlli per le features vettoriali.
*
* Crea i controlli OL di tipo FeatureSelect per select/hilite/hover.
*
* Comprende le funzioni di callback richiamate sull'evento "featureselect"
*
*
*/
CWN2.FeatureManager = function(map) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    CWN2.Util.log("CWN2.LayerManager");

    this.hiliteFeatureControl = null;
    this.selectFeatureControl = null;
    this.hoverFeatureControl = null;

    // dizionario delle funzioni di callback registrate
    this.registeredCallbacks = {
        "onFeatureSelect" : [],
        "onFeatureUnselect" : [],
        "onFeatureOver" : [],
        "onFeatureOut" : []
    };


   /**
   *
   * Function: registerCallback
   *
   * Registra una  funzione di callback
   *
   * Parameters:
   * event - {String} evento
   * callback - {Function} funzione di callback
   *
   * Return:
   * {Boolean} true se la feature è tra quelle selezionate
   *
   */
    this.registerCallback = function(event,callback) {
        this.registeredCallbacks[event].push(callback);
    };

    /**
    *
    * Function: getRegisteredCallbacks
    *
    * Ritorna una funzione di callback associata ad un evento
    *
    * Parameters:
    * event - {String} evento
    *
    * Return:
    * {Function} funzione di callback
    *
    */
    this.getRegisteredCallbacks = function(event) {
        return this.registeredCallbacks[event];
    };

   // Attiva il controllo OL
    this.activateHiliteFeatureControl = function(vectLayerArray) {

        this.hiliteFeatureControl = new OpenLayers.Control.SelectFeature(vectLayerArray);
        this.hiliteFeatureControl.renderIntent = "hilite";
        this.hiliteFeatureControl.highlightOnly = true;
        this.hiliteFeatureControl.hover = true;
        this.hiliteFeatureControl.name = "hiliteFeatureControl";

        map.addControl(this.hiliteFeatureControl);
        this.hiliteFeatureControl.activate();

    };


    // Attiva il controllo OL
    this.activateHoverFeatureControl = function(vectLayerArray) {

        // funzione richiamata sull"evento mouseover della feature
        var onFeatureOver = function(feature,callbacks) {

            for(var i=0; i < callbacks.length; i++) {
                if (typeof callbacks[i] === "function") {
                    callbacks[i](feature);
                }
            }

        };

        // funzione richiamata sull'evento mouseout della feature
        var onFeatureOut = function(feature,callbacks) {

            for(var i=0; i < callbacks.length; i++) {
                if (typeof callbacks[i] === "function") {
                    callbacks[i](feature);
                }
            }

        };

        var featureOutCallbacks = this.getRegisteredCallbacks("onFeatureOut");
        var featureOverCallbacks = this.getRegisteredCallbacks("onFeatureOver");

        this.hoverFeatureControl = new OpenLayers.Control.SelectFeature(vectLayerArray, {
            hover: true,
            renderIntent: "hover",
            highlightOnly: true,
            eventListeners: {
                featurehighlighted:function(e){
                    onFeatureOver(e.feature,featureOverCallbacks);
                },
                featureunhighlighted:function(e){
                    onFeatureOut(e.feature,featureOutCallbacks);
                }
            }
        });


        this.hoverFeatureControl.name = "hoverFeatureControl";
        map.addControl(this.hoverFeatureControl);
        this.hoverFeatureControl.activate();

    };

    // Attiva il controllo OL
    this.activateSelectFeatureControl = function(vectLayerArray) {

        // funzione richiamata sull'evento select della feature
        var onFeatureSelect = function(feature,callbacks) {

            // Gestione Info e Popup
            CWN2.InfoPopupManager.onFeatureSelect(feature);

            // Richiamo delle funzioni di callback registrate
            for(var i=0; i < callbacks.length; i++) {
                if (typeof callbacks[i] === "function") {
                    callbacks[i](feature);
                }
            }

        };

        // funzione richiamata sull'evento unselect della feature
        var onFeatureUnselect = function(feature,callbacks) {

            // Gestione Info e Popup
            CWN2.InfoPopupManager.onFeatureUnselect(feature);

            // Richiamo delle funzioni di callback registrate
            for(var i=0; i < callbacks.length; i++) {
                if (typeof callbacks[i] === "function") {
                    callbacks[i](feature);
                }
            }

        };

        var featureSelectCallbacks = this.getRegisteredCallbacks("onFeatureSelect");
        var featureUnselectCallbacks = this.getRegisteredCallbacks("onFeatureUnselect");

        this.selectFeatureControl = new OpenLayers.Control.SelectFeature(vectLayerArray);
        this.selectFeatureControl.onSelect = function(feature) {
            onFeatureSelect(feature,featureSelectCallbacks);
        };
        this.selectFeatureControl.onUnselect = function(feature) {
            onFeatureUnselect(feature,featureUnselectCallbacks);
        };
        this.selectFeatureControl.name = "selectFeatureControl";

        map.addControl(this.selectFeatureControl);
        this.selectFeatureControl.activate();

    };

    /**
     *
     * Function: registerAction
     *
     * Registra le azioni collegate adi layer vettoriali
     *
     * Parameters:
     * layersConfig - {Array} Array di configurazione dei layer
     *
     */
    this.registerAction = function(layersConfig) {

        var len = layersConfig.length,
            i,
            j,
            event,
            callbackName,
            callback,
            exception;


        for (i = 0; i < len; i++) {
            if (layersConfig[i].actions && layersConfig[i].actions.length > 0) {
                for (j = 0; j < layersConfig[i].actions.length; j++) {
                    // controllo che esistano actions.event e actions.callback in configurazione
                    event = layersConfig[i].actions[j].event;
                    if (!event) {
                        exception = {
                            name: 'BadAction',
                            message: 'CWN2.FeatureManager.registerAction: event non definito',
                            level: 1
                        };
                        CWN2.util.handleException(exception);
                        return;
                    }
                    callbackName = layersConfig[i].actions[j].callback;
                    if (!callbackName) {
                        exception = {
                            name: 'BadAction',
                            message: 'CWN2.FeatureManager.registerAction: calback non definito',
                            level: 1
                        };
                        CWN2.util.handleException(exception);
                        return;
                    }
                    callback = CWN2.featureActionsRegistry[callbackName];
                    if (typeof callback !== "function") {
                        exception = {
                            name: 'BadCallbackName',
                            message: 'CWN2.FeatureManager.registerAction: funzione di callback ' + callbackName + ' non esiste',
                            level: 1
                        };
                        CWN2.util.handleException(exception);
                        return;
                    }

                    // registro la action
                    this.registerCallback(
                        layersConfig[i].actions[j].event,
                        callback
                    );
                }
            }
        }

    };

    this.updateControlLayer = function() {
        var vectLayers = map.getLayersByClass("OpenLayers.Layer.Vector");

        // levo i layer _info
        for (var i = 0; i < vectLayers.length; i++) {
            if (vectLayers[i].name.indexOf("_INFO") > 0) {
                vectLayers.splice(i,1);
            }
        }

        // ATTENZIONE:
        // NON MODIFICARE L'ORDINE DI AGGIORNAMENTO DEI CONTROLLI
        this.hoverFeatureControl.setLayer(vectLayers);
        this.hiliteFeatureControl.setLayer(vectLayers);
        this.selectFeatureControl.setLayer(vectLayers);
    };

    this.activateControls = function() {
        // ATTENZIONE:
        // NON MODIFICARE L'ORDINE DI AGGIORNAMENTO DEI CONTROLLI
        this.hoverFeatureControl.activate();
        this.hiliteFeatureControl.activate();
        this.selectFeatureControl.activate();
    };

    this.deactivateControls = function() {
        // ATTENZIONE:
        // NON MODIFICARE L'ORDINE DI AGGIORNAMENTO DEI CONTROLLI
        this.hoverFeatureControl.deactivate();
        this.hiliteFeatureControl.deactivate();
        this.selectFeatureControl.deactivate();
    };

    // carico l'array con i layer vettoriali
    var vectLayerArray = map.getLayersByClass("OpenLayers.Layer.Vector");

    // ATTENZIONE:
    // NON MODIFICARE L'ORDINE DI CREAZIONE DEI CONTROLLI
    // L'ULTIMO DEVE ESSERE QUELLO PER LA SELECT
    // NON MODIFICARE LA MODALITA' DI CREAZIONE DEI CONTROLLI DI HILITE E OVER
    this.activateHoverFeatureControl(vectLayerArray);
    this.activateHiliteFeatureControl(vectLayerArray);
    this.activateSelectFeatureControl(vectLayerArray);

    // registro le action sui layer vettoriali
    this.registerAction(map.layerManager.getLayersConfig());

};


/**
 *
 * Class: CWN2.featureActionsRegistry
 *
 * Oggetto che raccoglie le funzioni di callback associate agli eventi sulle feature
 *
 *
 */

CWN2.featureActionsRegistry = (function(){

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";


    // Funzione di test per verificare la registrazione del callback sull'evento mouseover
    function testOver(feature) {
        CWN2.Util.log(feature);
    }

    // Funzione di test per verificare la registrazione del callback sull'evento mouseout
    function testOut(feature) {
        CWN2.Util.log(feature);
    }

    // Funzione di test per verificare la registrazione del callback sull'evento select
    function testSelect(feature) {
        CWN2.Util.log("testSelect");
    }

    // Funzione di test per verificare la registrazione del callback sull'evento unselect
    function testUnselect(feature) {
        CWN2.Util.log("testUnselect");
    }

	/*
      Public API
	*/
	return {

        /**
        * Function: testOver
        * Funzione di test per verificare la registrazione del callback sull'evento mouseover
        *
        */
        testOver: testOver,

        /**
        * Function: testOut
        * Funzione di test per verificare la registrazione del callback sull'evento mouseout
        *
        */
        testOut: testOut,

        /**
        * Function: testSelect
        * Funzione di test per verificare la registrazione del callback sull'evento select
        *
        */
        testSelect: testSelect,

        /**
        * Function: testUnselect
        * Funzione di test per verificare la registrazione del callback sull'evento unselect
        *
        */
        testUnselect: testUnselect

	};

}());
/**
*
* Class: CWN2.featureSelecter
* 
 *
 * Oggetto per la selezione programmatica di feature
 *
*/

CWN2.featureSelecter = (function(){

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";


	/*
      private properties
	*/

	/*
      private methods
	*/

    function selectFeature(selectConfig,feature){

        try {
            CWN2.Util.assert(selectConfig,
                {
                    name: "BadParameter",
                    message: "CWN2.featureSelected.selectFeature: selectConfig deve essere valorizzato",
                    level: 1
                }
            );
            CWN2.Util.assert(selectConfig.layer,
                {
                    name: "BadParameter",
                    message: "CWN2.featureSelected.selectFeature: layer deve essere valorizzato",
                    level: 1
                }
            );
            CWN2.Util.assert(feature || selectConfig.attrName,
                {
                    name: "BadParameter",
                    message: "CWN2.featureSelected.selectFeature: attrName (oppure feature) deve essere valorizzato",
                    level: 1
                }
            );
            CWN2.Util.assert(
                ( feature ||
                        ( selectConfig.item !== null && selectConfig.item !== undefined )
                ),
                {
                    name: "BadParameter",
                    message: "CWN2.featureSelected.selectFeature: item (oppure feature) deve essere valorizzato",
                    level: 1
                }
            );
        } catch(e) { throw e; }


        // configurazione hilite
        var layer = selectConfig.layer,
            attrName = selectConfig.attrName,
            item = selectConfig.item,
            options = selectConfig.options || {"zoom" : false, "hiliteOnly": false},
            zoom = options.zoom,
            maxZoomLevel = options.maxZoomLevel,
            hiliteOnly = options.hiliteOnly,
            foundFeatures,
            foundFeature;

        if (feature) {
            foundFeature = feature;
        } else {
            // cerco nelle feature del layer quelle che soddisfano il criterio e seleziono la prima
            foundFeatures = layer.getFeaturesByAttribute(attrName,item);
            if (foundFeatures.length > 0) {
                foundFeature = foundFeatures[0];
            }
        }
        if (foundFeature) {
            if (hiliteOnly) {
                layer.map.featureManager.hoverFeatureControl.highlight(foundFeature);
            } else {
                var selectFeatureControl = layer.map.featureManager.selectFeatureControl;
                selectFeatureControl.unselectAll();
                selectFeatureControl.select(foundFeature);
            }
            // se impostato flag per zoom faccio lo zoom
            if (zoom) {
                layer.map.zoomToFeatures([foundFeature],maxZoomLevel);
            }
        }
    }

    function  unselectFeature(selectConfig,feature){

        //CWN2.Util.log("CWN2.featureSelected.unselectFeature");


        try {
            CWN2.Util.assert(selectConfig,
                {
                    name: "BadParameter",
                    message: "CWN2.featureSelected.unselectFeature: selectConfig deve essere valorizzato",
                    level: 1
                }
            );
            CWN2.Util.assert(selectConfig.layer,
                {
                    name: "BadParameter",
                    message: "CWN2.featureSelected.unselectFeature: layer deve essere valorizzato",
                    level: 1
                }
            );
            CWN2.Util.assert(feature || selectConfig.attrName,
                {
                    name: "BadParameter",
                    message: "CWN2.featureSelected.unselectFeature: attrName (oppure feature) deve essere valorizzato",
                    level: 1
                }
            );
            CWN2.Util.assert(feature || selectConfig.item,
                {
                    name: "BadParameter",
                    message: "CWN2.featureSelected.unselectFeature: item (oppure feature) deve essere valorizzato",
                    level: 1
                }
            );
        } catch(e) { throw e; }


        // configurazione hilite
        var layer = selectConfig.layer,
            attrName = selectConfig.attrName,
            item = selectConfig.item,
            options = selectConfig.options || {"hiliteOnly": false},
            hiliteOnly = options.hiliteOnly,
            foundFeatures,
            foundFeature,
            selectConfig2 = {};

        if (feature) {
            foundFeature = feature;
        } else {
            // cerco nelle feature del layer quelle che soddisfano il criterio e seleziono la prima
            foundFeatures = layer.getFeaturesByAttribute(attrName,item);
            if (foundFeatures.length > 0) {
                foundFeature = foundFeatures[0];
            }
        }


        if (foundFeature) {
            if (hiliteOnly) {
                layer.map.featureManager.hoverFeatureControl.unhighlight(foundFeature);
                if (foundFeature.isSelected()) {
                    selectConfig2.layer = selectConfig.layer;
                    selectConfig2.attrName = selectConfig.attrName;
                    selectConfig2.item = selectConfig.item;
                    selectConfig2.options = {"hiliteOnly": false};
                    selectFeature(selectConfig2,foundFeature);

                }
            } else {
                layer.map.featureManager.selectFeatureControl.unselect(foundFeature);
            }
        }
    }

	/*
      Public API
	*/
	return {


        /**
        *
        * Function: selectFeature
        *
        * Selezione programmatica feature di un layer vettoriali.
        *
        * Se più feature soddisfano il criterio di selezione solo la prima viene selezionata.
        *
        * Se impostato il parametro options.hiliteOnly=true viene fatto solo l'highlight della feaure.
        *
        * Se impostato il parametro feature viene selezionata la feature,
        * altrimenti viene fatta una ricerca della feature sul layer in base alla configurazione del parametro config.
        *
        *
        * Parameters:
        * config - {Object} Oggetto di configurazione dell'hilite
        *  - layerName - {String} Nome del layer
        *  - attrName - {String} Nome dell'attributo
        *  - item - {String}/{Number} Valore
        *  - options - {Object} Oggetto configurazione delle opzioni
        *  -  - zoom - {Boolean} Flag per impostare lo zoom sulle feature caricate
        *  -  - hiliteOnly - {Boolean} Flag per effettuare solo l'highlight della feature (default: false)
         * feature - {OpenLayers.Feature} Feature da selezionare
        *
        *  Esempio:
        *  (start code)
        * var selectConf = {
        *			"layerName": "Prova",
        *			"attrName": "ID",
        *				"items": "1"
        *			},
        *			"options": {
         *				"zoom": false,
         *				"hiliteOnly": false
        *			}
        *		};
        *   (end)
        *
        */

		selectFeature : selectFeature,

        /**
        *
        * Function: unselectFeature
        *
        * Deselezione programmatica feature di un layer vettoriali.
        *
        * Se più feature soddisfano il criterio di selezione solo la prima viene deselezionata.
        *
        * Se impostato il parametro options.hiliteOnly=true viene fatto solo l'unhighlight della feaure.
        *
        * Se impostato il parametro feature viene deselezionata la feature,
        * altrimenti viene fatta una ricerca della feature sul layer in base alla configurazione del parametro config
        *
        *
         * Parameters:
         * config - {Object} Oggetto di configurazione dell'hilite
         *  - layerName - {String} Nome del layer
         *  - attrName - {String} Nome dell'attributo
         *  - item - {String}/{Number} Valore
         *  - options - {Object} Oggetto configurazione delle opzioni
         *  -  - hiliteOnly - {Boolean} Flag per effettuare solo l'highlight della feature (default: false)
          * feature - {OpenLayers.Feature} Feature da selezionare
         *
         *  Esempio:
         *  (start code)
         * var selectConf = {
         *			"layerName": "Prova",
         *			"attrName": "ID",
         *				"items": "1"
         *			},
         *			"options": {
          *				"hiliteOnly": false
         *			}
         *		};
         *   (end)
         *
         */

        unselectFeature : unselectFeature


	};

}());
/**
*
* Class: CWN2.layerFactory
* 
 *
 * Factory per creazione di layers OpenLayers
 *
*/

CWN2.layerFactory = (function(){

    /*global CWN2:false, window:false, OpenLayers:false, google:false, VEMapStyle:false */
    "use strict";

    var BASE_RESOLUTIONS = [156543.03390625, 78271.516953125, 39135.7584765625, 19567.87923828125, 9783.939619140625, 4891.9698095703125, 2445.9849047851562, 1222.9924523925781, 611.4962261962891, 305.74811309814453, 152.87405654907226, 76.43702827453613, 38.218514137268066, 19.109257068634033, 9.554628534317017, 4.777314267158508, 2.388657133579254, 1.194328566789627, 0.5971642833948135, 0.29858214169740677, 0.14929107084870338];

    // array contenente i renderIntent gestiti con associata una stylemap di default
    var renderIntents = [
           {
               name: "default",
               defaultStyle: {
                   fillColor: "#ee9900",
                   fillOpacity: 0.4,
                   hoverFillColor: "white",
                   hoverFillOpacity: 0.8,
                   strokeColor: "#ee9900",
                   strokeOpacity: 1,
                   strokeWidth: 1,
                   strokeLinecap: "round",
                   strokeDashstyle: "solid",
                   hoverStrokeColor: "red",
                   hoverStrokeOpacity: 1,
                   hoverStrokeWidth: 0.2,
                   pointRadius: 6,
                   hoverPointRadius: 1,
                   hoverPointUnit: "%",
                   pointerEvents: "visiblePainted",
                   cursor: "inherit"
               }
           },
           {
               name: "hilite",
               defaultStyle: {
                   fillColor: "#66cccc",
                   fillOpacity: 0.2,
                   hoverFillColor: "white",
                   hoverFillOpacity: 0.8,
                   strokeColor: "#66cccc",
                   strokeOpacity: 1,
                   strokeLinecap: "round",
                   strokeWidth: 2,
                   strokeDashstyle: "solid",
                   hoverStrokeColor: "red",
                   hoverStrokeOpacity: 1,
                   hoverStrokeWidth: 0.2,
                   pointRadius: 6,
                   hoverPointRadius: 1,
                   hoverPointUnit: "%",
                   pointerEvents: "visiblePainted",
                   cursor: "inherit"
               }
           },
           {
               name: "select",
               defaultStyle: {
                   fillColor: "blue",
                   fillOpacity: 0.4,
                   hoverFillColor: "white",
                   hoverFillOpacity: 0.8,
                   strokeColor: "blue",
                   strokeOpacity: 1,
                   strokeWidth: 2,
                   strokeLinecap: "round",
                   strokeDashstyle: "solid",
                   hoverStrokeColor: "red",
                   hoverStrokeOpacity: 1,
                   hoverStrokeWidth: 0.2,
                   pointRadius: 6,
                   hoverPointRadius: 1,
                   hoverPointUnit: "%",
                   pointerEvents: "visiblePainted",
                   cursor: "pointer"
               }
           },
           {
               name: "hover",
               defaultStyle: {
                   fillColor: "blue",
                   fillOpacity: 0.4,
                   hoverFillColor: "white",
                   hoverFillOpacity: 0.8,
                   strokeColor: "blue",
                   strokeOpacity: 1,
                   strokeWidth: 2,
                   strokeLinecap: "round",
                   strokeDashstyle: "solid",
                   hoverStrokeColor: "red",
                   hoverStrokeOpacity: 1,
                   hoverStrokeWidth: 0.2,
                   pointRadius: 6,
                   hoverPointRadius: 1,
                   hoverPointUnit: "%",
                   pointerEvents: "visiblePainted",
                   cursor: "pointer"
               }
           },
           {
               name: "temporary",
               defaultStyle: {
                   fillColor: "#66cccc",
                   fillOpacity: 0.2,
                   hoverFillColor: "white",
                   hoverFillOpacity: 0.8,
                   strokeColor: "#66cccc",
                   strokeOpacity: 1,
                   strokeLinecap: "round",
                   strokeWidth: 2,
                   strokeDashstyle: "solid",
                   hoverStrokeColor: "red",
                   hoverStrokeOpacity: 1,
                   hoverStrokeWidth: 0.2,
                   pointRadius: 6,
                   hoverPointRadius: 1,
                   hoverPointUnit: "%",
                   pointerEvents: "visiblePainted",
                   cursor: "inherit"
               }
           },
           {
               name: "delete",
               defaultStyle: {
                   display: "none"
               }
           }
       ];

	// Impostazione opzioni di base per tutti i layer
	function setLayerOptions(layerConfig,map) {
		var layerOptions = {};
		layerOptions.projection = layerConfig.projection || map.projection;
		layerOptions.isBaseLayer = layerConfig.isBaseLayer;
		layerOptions.opacity = layerConfig.opacity || 1;
		layerOptions.attribution = layerConfig.attribution;
		layerOptions.transitionEffect = "resize";
		//layerOptions.transitionEffect = null;
		layerOptions.metadata = layerConfig.metadata;
		layerOptions.minScale = layerConfig.minScale || null;
		layerOptions.maxScale = layerConfig.maxScale || null;
		layerOptions.infoOptions = layerConfig.infoOptions;
		return layerOptions;
	}

    function isCluster(strategiesConfig) {
        if (strategiesConfig && strategiesConfig.length) {
            var len = strategiesConfig.length;
            for (var i = 0; i < len; i++) {
                if (strategiesConfig[i].name === "Cluster") {
                    return true;
                }
            }
        }
        return false;
    }

	// Creazione styleMap vettoriale
	function createVectorStyleMap(layerConfig) {

		var classes = [],
            StyleMapLiteral = {},
            j,
            len = renderIntents.length,
            style,
            rules,
            i,
            len2,
            classFilter,
            format,
            rule,
            clusterRule,
            noClusterRule;


        if (layerConfig.classes) {
            if (layerConfig.classes instanceof Array ) {
                classes = layerConfig.classes;
            } else {
                classes.push(layerConfig.classes);
            }
        }  else {
            return null;
        }


		for (j = 0, len; j < len; j++) {

			style = new OpenLayers.Style();
			rules = [];
            len2 = classes.length;

			for (i = 0; i < len2; i++) {

				classFilter = null;
				format = new OpenLayers.Format.CQL();

				if (classes[i].filter) {
					classFilter = format.read(classes[i].filter);
				}

                if (isCluster(layerConfig.strategies)) {
                    rules.push(buildSingleFeatureClusterRule(classes[i].styleMaps, renderIntents[j].name));
                    rules.push(buildClusterRule(classes[i].styleMaps, renderIntents[j].name));
                } else {
                    rules.push(buildRule(classes[i].styleMaps, classFilter, renderIntents[j].name));
                }

			}

			style.addRules(rules);

			StyleMapLiteral[renderIntents[j].name] = style;

		}

        //TODO: se non esiste il renderIntent "hover" lo imposto uguale al renderIntent "select"

        return new OpenLayers.StyleMap(StyleMapLiteral);

	}

    // Ritorna la rule (filtro e simbolizer) da utilizzare per le feature per un determinato renderIntent
    // Se lo stile non Ã¨ definito viene costruito uno style di default
	function buildRule(styleMaps,classFilter,renderIntent) {
        return new OpenLayers.Rule({
            symbolizer: getClassStyleByIntent(styleMaps,renderIntent) || getDefaultStyleByIntent(renderIntent),
            filter: classFilter
        });
	}


    // Ritorna la rule (filtro e simbolizer) da utilizzare per le feature in cluster
	function buildClusterRule(styleMaps,renderIntent) {
        var symbolizer = getClassStyleByIntent(styleMaps,renderIntent) || getDefaultStyleByIntent(renderIntent) ;

        if (symbolizer.externalGraphic) {
            symbolizer.graphicWidth = symbolizer.graphicWidth * 1.5;
            symbolizer.graphicHeight = symbolizer.graphicHeight * 1.5;
            symbolizer.graphicTitle = "${count} Elementi";
        } else {
            symbolizer.pointRadius = symbolizer.pointRadius * 1.5;
        }

        var filter = new OpenLayers.Filter.Comparison(
        {
            type: OpenLayers.Filter.Comparison.GREATER_THAN,
            property: "count",
            value: 1
        });

		if (symbolizer) {
			var rule = new OpenLayers.Rule({
				symbolizer: symbolizer,
				filter: filter
			});
		}
		return rule;
	}


    // Ritorna la rule (filtro e simbolizer) da utilizzare per le feature non in cluster
	function buildSingleFeatureClusterRule(styleMaps,renderIntent) {
        var symbolizer = getClassStyleByIntent(styleMaps,renderIntent) || getDefaultStyleByIntent(renderIntent) ;

        //symbolizer.graphicTitle = "${count} Elemento";

        var filter = new OpenLayers.Filter.Comparison(
                {
                    type: OpenLayers.Filter.Comparison.EQUAL_TO,
                    property: "count",
                    value: 1
                });

		if (symbolizer) {
			var rule = new OpenLayers.Rule({
				symbolizer: symbolizer,
				filter: filter
			});
		}
		return rule;
	}



	// Ritorna lo style (symbolizer) associato ad una stylemap per un determinato renderIntet
	function getClassStyleByIntent(styleMaps, renderIntent) {
        var len = styleMaps.length;
        for (var s = 0; s < len; s++) {
			if (styleMaps[s].renderIntent === renderIntent)
			{
				return CWN2.Util.cloneObj(styleMaps[s].style);
			}
		}
		return null;
	}

	// Ritorna lo style (symbolizer) di default associato ad un determinato renderIntet
	function getDefaultStyleByIntent(renderIntent,cluster) {
        var len = renderIntents.length;
        for (var s = 0; s < len; s++) {
			if (renderIntents[s].name === renderIntent)
			{
				return  CWN2.Util.cloneObj(renderIntents[s].defaultStyle);
			}
		}
		return null;
	}


    // Crea un Layer OpenLayers in base ad una determinata configurazione
    function create(layerConfig,map) {
        try {
            var layer = CWN2.layerFactory[layerConfig.type](layerConfig,map);
            layer.legend = layerConfig.legend;
            if (!layerConfig.legend) {
                layer.displayInLayerSwitcher = false;
            }
            // imnposto un attributo contenente la configurazione del layer
            layer.config = layerConfig;

            return layer;
        }
        catch (exception) {
            throw {
                name: "BadLayerConfig",
                message: "CWN2.layerFactory.create: Errore creazione layer " + layerConfig.name  + " di tipo " + layerConfig.type,
                level: 1
            };
        }
    }

    /*
    *
    * Metodi per creazione dei layer Openlayers dei vari tipi
    *
    */

    // google generico
    function createGoogleLayer(layerType,layerConfig) {

        var	olLayer = new OpenLayers.Layer.Google(
            layerConfig.name,
            {
                type: layerType,
                resolutions: BASE_RESOLUTIONS,
                serverResolutions: BASE_RESOLUTIONS,
                minZoomLevel: 0,
                maxZoomLevel: 19,
                alwaysInRange: true
            }
        );
        // abilito l'animazione del layer su zoom
        return olLayer;
    }

    // google stradario
    function google_roadmap(layerConfig) {
        CWN2.Util.log("CWN2.layerFactory.create google_roadmap");
        var layerType = google.maps.MapTypeId.ROADMAP;
        return createGoogleLayer(layerType,layerConfig);
    }

    // google satellite
    function google_satellite(layerConfig) {
        CWN2.Util.log("CWN2.layerFactory.create google_satellite");
        var layerType = google.maps.MapTypeId.SATELLITE;
        return createGoogleLayer(layerType,layerConfig);
    }

    // google ibrido
    function google_hybrid(layerConfig) {
        CWN2.Util.log("CWN2.layerFactory.create google_hybrid");
        var layerType = google.maps.MapTypeId.HYBRID;
        return createGoogleLayer(layerType,layerConfig);
    }

    // google terreno
    function google_terrain(layerConfig) {
        CWN2.Util.log("CWN2.layerFactory.create google_terrain");
        var layerType = google.maps.MapTypeId.TERRAIN;
        return createGoogleLayer(layerType,layerConfig);
    }



    // Sfondo Bianco
    function no_base(layerConfig) {
        CWN2.Util.log("CWN2.layerFactory.create Sfondo Bianco");
        var	olLayer = new OpenLayers.Layer(
            layerConfig.name,
            {
                resolutions: BASE_RESOLUTIONS,
                serverResolutions: BASE_RESOLUTIONS,
                alwaysInRange: true,
                isBaseLayer: true
            }
        );
        return olLayer;
    }

    // OpenStreetMap
    function OSM() {
        CWN2.Util.log("CWN2.layerFactory.create OSM");

        var olLayer = new OpenLayers.Layer.OSM("OSM", null, {
            transitionEffect: "resize"
        });
        return olLayer;
    }


    // TMS
    function TMS(layerConfig,map) {
        CWN2.Util.log("CWN2.layerFactory.create TMS");

        var mapBounds,
            minZoomLevel,
            maxZoomLevel,
            resolutions = [],
            BLANK_PNG = "http://srvcarto.regione.liguria.it/sfondi/none.png";

        if (layerConfig.bounds) {
            mapBounds = new OpenLayers.Bounds.fromString(layerConfig.bounds);
        } else {
            mapBounds = new OpenLayers.Bounds(-20037508, -20037508, 20037508, 20037508.34);
        }

        minZoomLevel = layerConfig.minZoomLevel || 7;
        maxZoomLevel = layerConfig.maxZoomLevel || 20;
        resolutions = BASE_RESOLUTIONS.slice(minZoomLevel,maxZoomLevel);

        function getTileURL(bounds) {
            var TMSLayer = this;
            var res = TMSLayer.map.getResolution();
            var x = Math.round((bounds.left - TMSLayer.maxExtent.left) / (res * TMSLayer.tileSize.w));
            var y = Math.round((bounds.bottom - TMSLayer.tileOrigin.lat) / (res * TMSLayer.tileSize.h));
            var z = BASE_RESOLUTIONS.indexOf(TMSLayer.map.resolution);


            if (mapBounds.intersectsBounds( bounds ) && z >= minZoomLevel && z <= maxZoomLevel ) {
                return TMSLayer.url + z + "/" + x + "/" + y + "." + TMSLayer.type;
            } else {
                return BLANK_PNG;
            }
        }

        var olLayer = new OpenLayers.Layer.TMS(
            layerConfig.name,
            layerConfig.url,
            {
                type: 'png',
                getURL: getTileURL,
                alpha: false,
                resolutions: resolutions,
                serverResolutions: BASE_RESOLUTIONS
            }
        );


        if (map.layerManager.isBaseLayerInConfig(layerConfig.name)){
            olLayer.setIsBaseLayer(true);
        } else {
            olLayer.setIsBaseLayer(false);
        }


        return olLayer;
    }

    // TMS
    function MapProxyTMS(layerConfig,map) {
        CWN2.Util.log("CWN2.layerFactory.create TMS");

        var olLayer = new OpenLayers.Layer.TMS(
            layerConfig.name,
            layerConfig.url,
            {
                layername: layerConfig.name,
                type: 'png',
                resolutions: BASE_RESOLUTIONS.slice(0,18),
                zoomOffset: -1,
                tileSize: new OpenLayers.Size(256, 256),
                minScale: layerConfig.minScale || null,
                maxScale: layerConfig.maxScale || null
            }
        );

        if (map.layerManager.isBaseLayerInConfig(layerConfig.name)){
            olLayer.setIsBaseLayer(true);
        } else {
            olLayer.setIsBaseLayer(false);
        }


        return olLayer;
    }

    // Bing Hybrid
    function bing_hybrid() {
        var	olLayer = new OpenLayers.Layer.Bing({
            name: "bing_hybrid",
            key: CWN2.BING_MAPS_KEY,
            type: "AerialWithLabels",
            resolutions: BASE_RESOLUTIONS
        });
        return olLayer;
    }

    // Bing Aerial
    function bing_aerial() {
        var	olLayer = new OpenLayers.Layer.Bing({
            name: "bing_aerial",
            key: CWN2.BING_MAPS_KEY,
            type: "Aerial",
            resolutions: BASE_RESOLUTIONS
        });
        return olLayer;
    }

    // Bing Road
    function bing_road() {
        var	olLayer = new OpenLayers.Layer.Bing({
            name: "bing_road",
            key: CWN2.BING_MAPS_KEY,
            type: "Road",
            resolutions: BASE_RESOLUTIONS
        });
        return olLayer;
    }

    var createStrategy = function(strategy) {
        if (strategy.name === "BBOX") {
            return new OpenLayers.Strategy.BBOX();
        }
        if (strategy.name === "Cluster") {
            var options = {};
            if (strategy.options && strategy.options.distance) {
                options.distance = strategy.options.distance;
            }
            if (strategy.options && strategy.options.threshold) {
                options.threshold = strategy.options.threshold;
            }
            return new OpenLayers.Strategy.Cluster(options);
        }

    };

    // Vettoriale
    function createStrategies(layerConfig) {
        var strategiesConfig = layerConfig.strategies;
        var strategiesArray = [];
        if (strategiesConfig) {
            var len = strategiesConfig.length;
            for (var i = 0; i < len; i++) {
                strategiesArray.push(createStrategy(strategiesConfig[i]));
            }
        } else {
            strategiesArray.push(new OpenLayers.Strategy.Fixed());
        }
        return strategiesArray;
    }

    function GeoJSON(layerConfig,map) {
        CWN2.Util.log("CWN2.layerFactory.create GeoJSON");

        // impostazione opzioni di base
        var layerOptions = setLayerOptions(layerConfig,map),
            olLayer;

        // se non Ã¨ impostato parametro la url
        // viene creato un layer senza feature che viene poi caricato successivamente
        if (layerConfig.url){

            // creo il protocollo
            layerOptions.protocol = new OpenLayers.Protocol.HTTP({
                format: new OpenLayers.Format.GeoJSON({ignoreExtraDims: true}),
                url: layerConfig.url
            });

            // creo le strategie
            layerOptions.strategies = createStrategies(layerConfig);

        }

        // creo il livello OL
        olLayer = new OpenLayers.Layer.Vector(
            layerConfig.name,
            layerOptions
        );


        // creo la StyleMap
        olLayer.styleMap = createVectorStyleMap(layerConfig);


        return olLayer;

    }

    // WFS
    function WFS(layerConfig,map) {
        CWN2.Util.log("CWN2.layerFactory.create WFS");

        // impostazione opzioni di base
        var layerOptions = setLayerOptions(layerConfig,map),
            olLayer;


        // creo il protocollo
        if (layerConfig.wfsParams.method = "GET") {
            var params = {
                request: "GetFeature",
                service: "wfs",
                version: "1.0.0"
            };
            params.typeName = layerConfig.wfsParams.featureType;
            if (layerConfig.wfsParams.filter) {
                params.filter = layerConfig.wfsParams.filter;
            }
            var options = {
                url: layerConfig.wfsParams.url,
                params: params,
                format: new OpenLayers.Format.GML({
                    featureNS: "http://ng.org/sf",
                    geometryName: "wkb_geometry"
                })
            };
            layerOptions.protocol = new OpenLayers.Protocol.HTTP(options);
        } else {
            layerOptions.protocol = new OpenLayers.Protocol.WFS(layerConfig.wfsParams);
        }

        layerOptions.strategies = createStrategies(layerConfig);


        // creo il livello OL
        olLayer = new OpenLayers.Layer.Vector(
            layerConfig.name,
            layerOptions
        );


        olLayer.styleMap = createVectorStyleMap(layerConfig);

        return olLayer;
    }

    // WMS
    function WMS(layerConfig,map) {
        CWN2.Util.log("CWN2.layerFactory.create WMS");

        // impostazione opzioni di base
        var layerOptions = setLayerOptions(layerConfig,map),
            wmsParams = {},
            olLayer;

        // impostazione parametri layer WMS
//        wmsParams.layers = layerConfig.wmsParams.name;
//        wmsParams.transparent = layerConfig.wmsParams.transparent;
//        if (layerConfig.wmsParams.format) {
//            wmsParams.format = layerConfig.wmsParams.format;
//        }

        layerConfig.wmsParams.layers = layerConfig.wmsParams.name;
        wmsParams = CWN2.Util.cloneObj(layerConfig.wmsParams);
        wmsParams.url = null;
        wmsParams.name = null;

        layerOptions.buffer = 0;
        layerOptions.singleTile = true;
        layerOptions.transitionEffect = null;

        // se base layer setto
        if (layerConfig.isBaseLayer) {
            layerOptions.resolutions = [78271.516953125, 39135.7584765625, 19567.87923828125, 9783.939619140625, 4891.9698095703125, 2445.9849047851562, 1222.9924523925781, 611.4962261962891, 305.74811309814453, 152.87405654907226, 76.43702827453613, 38.218514137268066, 19.109257068634033, 9.554628534317017, 4.777314267158508, 2.388657133579254, 1.194328566789627, 0.5971642833948135, 0.29858214169740677, 0.14929107084870338];
        }

        // creo il livello OL
        olLayer = new OpenLayers.Layer.WMS(
            layerConfig.name,
            layerConfig.wmsParams.url,
            wmsParams,
            layerOptions
        );

        olLayer.noMagic = true;
        if (!layerConfig.isBaseLayer) {
            olLayer.isBaseLayer = false;
        }


        // registro l'evento tileerror per gestire errori nei servizi WMS
        // mando un messaggio alla console
        olLayer.events.register("tileerror", olLayer, function() {
            var tile = arguments[0].tile;
            var url = tile.url;
            $.get(
                CWN2.proxy + url,
                function(data) {
                    var message = "";
                    if(url.indexOf("WIDTH=1&HEIGHT=1") < 0) {
                        try {
                            var errorText = data.childNodes[1].childNodes[1].textContent;
                            message += "WMS Server Error:\n";
                            message += "\nError Text: " + errorText;
                            message += "\nURL: " + url;
                        } catch (ex) {
                            message += "WMS Server Error\n";
                            message += "\nURL: " + url;
                        } finally {
                            var exception = {
                                name: "WMSServerError",
                                message: message,
                                level: 0
                            };
                            CWN2.Util.handleException(exception);
                        }
                    }
                },
                "xml"
            );
        });

        return olLayer;
    }

    function JSONP(layerConfig,map) {
        CWN2.Util.log("CWN2.layerFactory.create JSONP");

        // impostazione opzioni di base
        var layerOptions = setLayerOptions(layerConfig,map),
            olLayer;

        // se non Ã¨ impostato parametro la url
        // viene creato un layer senza feature che viene poi caricato successivamente
        if (layerConfig.url){

            // creo il protocollo
            layerOptions.protocol = new OpenLayers.Protocol.Script({
                format: new OpenLayers.Format.GeoJSON({ignoreExtraDims: true}),
                callbackTemplate: "OpenLayers.Protocol.Script.registry.${id}",
                url: layerConfig.url
            });

            // creo le strategie
            layerOptions.strategies = createStrategies(layerConfig);

        }

        // creo il livello OL
        olLayer = new OpenLayers.Layer.Vector(
            layerConfig.name,
            layerOptions
        );


        // creo la StyleMap
        olLayer.styleMap = createVectorStyleMap(layerConfig);



        return olLayer;

    }

	// Public API
	return {
		
		/**
		* 
		* Function: create
        * Crea un Layer OpenLayers in base ad una determinata configurazione
        *
		* Parameters:
        * layerConfig - {Object} Oggetto contenente la configurazione del layer
        *
		* Returns:
        * layer - {OpenLayers.Layer}
		* 
		*/ 
		create: create,

		/*
		*
        * Metodi per creazione dei layer Openlayers dei vari tipi
        *
        */

		google_roadmap: google_roadmap,
		google_satellite:google_satellite,
		google_hybrid: google_hybrid,
		google_terrain: google_terrain,
        bing_hybrid: bing_hybrid,
        bing_aerial: bing_aerial,
        bing_road: bing_road,
		no_base: no_base,
		OSM: OSM,
        TMS: TMS,
        MapProxyTMS: MapProxyTMS,
        GeoJSON: GeoJSON,
		WFS: WFS,
		WMS: WMS,
        JSONP: JSONP
		
	};
}());

/**
 *
 * Class: CWN2.LayerManager
 *
 * Oggetto per la gestione dei layer:
 *
* -	Inizializzare i repository dei layer
* -	Fornire informazioni sui layer disponibili ai moduli che lo richiedono, in particolare i metodi getBaseLayersConfig e getLayersConfig forniscono le configurazioni dei layer di base e overlay
* -	Aggiungere layer ai repository
* -	Rimuovere i layer dai repository
* -	Creazione di layer di servizio (per esempio per le operazioni di find o calcolo percorsi)
 *
 *
 */

CWN2.LayerManager = function(baseLayers,overlayLayers,appId) {

    /*global CWN2:false, Ext:false, window:false, OpenLayers:false */
    "use strict";

    CWN2.Util.log("CWN2.LayerManager");

    /*
        ProprietÃ  Pubbliche
     */
    this.overlayLayerStore = null;
    this.baseLayerStore = null;
    this.overlayLayersConfig = overlayLayers;
    this.baseLayersConfig = baseLayers;

    var app = CWN2.appRegistry.get(appId);

    /*
        Metodi
     */


    // imposta il flag isBaseLayer e la visibilitÃ  sui base layer
    this.setBaseLayers = function() {

        // imposto la proprietÃ  isBaseLayer a true per i baseLayers
        var visible,i, len = this.baseLayersConfig.length;
        visible = false;
        for (i = 0; i < len; i ++) {
            if (this.baseLayersConfig[i].visible) {
                visible = true;
            }
            this.baseLayersConfig[i].isBaseLayer = true;
        }

        // se non esiste nessun baseLayer visibile rendo visibile l'ultimo
        if (!visible) {
            this.baseLayersConfig[len - 1].visible = true;
        }

    };

    /**
    *
    * Function: getLayerConfigByName
    *
    * Ritorna la configurazione di un layer
    *
    * Parameters:
    * name - {String} Nome del layer
    *
    * Returns:
    * {Object} Configurazione del layer
    *
    */
    this.getLayerConfigByName = function(layerName) {
        var i,len = this.overlayLayersConfig.length;
        for (i = 0; i < len; i++) {
            if (this.overlayLayersConfig[i].name===layerName) {
                return this.overlayLayersConfig[i];
            }
        }
        return null;
    };

    /**
    *
    * Function: getLayerIndexByName
    *
    * Ritorna l'indice di un layer in configurazione
    *
    * Parameters:
    * name - {String} Nome del layer
    *
    * Returns:
    * {Integer}
    *
    */
    this.getLayerIndexByName = function(layerName) {
        var i , len = this.overlayLayersConfig.length;
        for (i = 0; i < len; i++) {
            if (this.overlayLayersConfig[i].name===layerName) {
                return i;
            }
        }
        return -1;
    };

    /**
    *
    * Function: isbaseLayerInConfig
    *
    * Indica se il baseLayer Ã¨ in configurazione
    *
    * Parameters:
    * name - {String} Nome del layer
    *
    * Returns:
    * {Boolean}
    *
    */
    this.isBaseLayerInConfig = function(layerName) {
        var i , len;
        len = this.baseLayersConfig.length;
        for (i = 0; i < len; i++) {
            if (layerName === this.baseLayersConfig[i].name) {
                return true;
            }
        }
        return false;
    };

    /**
    *
    * Function: isLayerInConfig
    *
    * Indica se il layer Ã¨ in configurazione
    *
    * Parameters:
    * name - {String} Nome del layer
    *
    * Returns:
    * {Boolean}
    */
    this.isLayerInConfig = function(layerName) {
        var i , len;
        len = this.overlayLayersConfig.length;
        for (i = 0; i < len; i++) {
            if (layerName === this.overlayLayersConfig[i].name) {
                return true;
            }
        }
        return false;
    };

    // costruisce lo store dei layer in base al tipo
    this.buildLayerStoreByType = function(type) {
        var layers = [],
        layersConfig,
        i,
        len,
        idStore = type + "-layer-store",
        layerStore;

        if (type === "overlay") {
            layersConfig = this.overlayLayersConfig;
        } else {
            layersConfig = this.baseLayersConfig;
        }

          if (layersConfig) {
              len = layersConfig.length;
            for (i = 0; i < len; i++) {
                if ((layersConfig[i].showInLegend === undefined) || (layersConfig[i].showInLegend === true)) {
                    layers.push(layersConfig[i]);
                }
            }
        }
        layers.reverse();


        layerStore = new Ext.data.JsonStore({
            id: idStore,
            data: layers,
            fields: [{
                name: "name", mapping: "name"
            },{
                name: "legend", mapping: "legend"
            }
            ]
        });

        if (type === "overlay") {
              this.overlayLayerStore = layerStore;
        } else {
              this.baseLayerStore = layerStore;
        }
    };

    // rimuove un layer dallo store
    this.removeLayerFromStore = function(layerName) {

        CWN2.Util.log("CWN2.LayerManager.removeLayerFromStore");

        var storeItems = this.overlayLayerStore.data.items,
            item,
            len2 = storeItems.length,
            rec;

        for (item = 0; item < len2; item++) {
            if (storeItems[item]) {
                if (storeItems[item].data.name === layerName) {
                    rec = this.overlayLayerStore.getAt(item);
                    this.overlayLayerStore.remove(rec);
                }
            }
        }
    };

    // aggiunge un layer allo store
    this.addLayerToStore = function(layerConfig) {

        CWN2.Util.log("CWN2.LayerManager.addLayerToStore");

        if ((layerConfig.showInLegend === undefined) || (layerConfig.showInLegend === true)) {
            if (this.overlayLayerStore) {
                var rec = new this.overlayLayerStore.recordType(layerConfig);
                this.overlayLayerStore.insert(0, rec);
            } else {
                this.initStore();
            }
        }
    };

    // aggiunge un base layer allo store
    this.addBaseLayerToStore = function(layerConfig) {

        CWN2.Util.log("CWN2.LayerManager.addBaseLayerToStore");

        if ((layerConfig.showInLegend === undefined) || (layerConfig.showInLegend === true)) {
            if (this.baseLayerStore) {
                var rec = new this.baseLayerStore.recordType(layerConfig);
                  this.baseLayerStore.insert(0, rec);
            } else {
                this.initStore();
            }
        }
    };

    /**
    *
    * Function: getOverlayLayersNameFromStore
    *
    * Ritorna un array con i nomi dei layer nello store
    *
    * Returns:
    * layerNames - {Array} Array contenente i nomi dei layer nello store
    *
    */
    this.getOverlayLayersNameFromStore = function() {

        CWN2.Util.log("CWN2.LayerManager.getOverlayLayersNameFromStore");

        if(this.overlayLayerStore) {
            var layersName = [],
                storeItems = this.overlayLayerStore.data.items,
                item,
                len2 = storeItems.length;

            for (item = 0; item < len2; item++) {
                layersName.push(storeItems[item].data.name);
            }

            return layersName;
        }

    };

    /**
    *
    * Function: getLayerStore
    *
    * Ritorna lo store dei layer
    *
    * Parameters:
    * type  - {String} Tipo di store ("base"/"overlay")
    *
    * Returns:
    * store - {Ext.data.JsonStore}
    *
    */
    this.getLayerStore = function(type) {

        CWN2.Util.log("CWN2.LayerManager.getLayerStore");

        if (type === "base") {
            return this.baseLayerStore;
        } else {
            return this.overlayLayerStore;
        }

    };

    function updateSelectControls(layers) {
// aggiorno il controllo per la selezione delle feature dei livelli vettoriali
        if (app.map) {
            // ATTENZIONE:
            // NON MODIFICARE L'ORDINE DI AGGIORNAMENTO DEI CONTROLLI
            app.map.featureManager.hoverFeatureControl.setLayer(layers);
            app.map.featureManager.hiliteFeatureControl.setLayer(layers);
            app.map.featureManager.selectFeatureControl.setLayer(layers);
        }
    }

    /**
    *
    * Function: addLayers
    *
    * Aggiunge i layer alla applicazione (aggiorna configurazione, store, mappa e legenda)
    *
    * Parameters:
    * layers - {Array/Object} Array oppure singolo oggetto contenente la configurazione dei layer
    *
    *
    */
    this.addLayers = function(layersIn) {

        CWN2.Util.log("CWN2.LayerManager.addLayers");

        CWN2.Util.assert(layersIn,
            {
                name: "BadParameter",
                message: "CWN2.LayerManager.addLayers: parametro deve essere valorizzato",
                level: 1
            }
        );

        var layers;

        if (layersIn instanceof Array) {
            layers = layersIn;
        } else {
            layers = [layersIn];
        }

        var i,
            len = layers.length,
            layer;

        // aggiungo i layer alla configurazione (se non sono giÃ  presenti)
        for (i = 0; i < len; i++) {
            layer = layers[i];
            if (!this.isLayerInConfig(layer.name)) {
                // aggiorno la configurazione
                this.overlayLayersConfig.push(layer);
                // aggiorno la mappa
                var olLayer = app.map.loadLayer(layer);
                // aggiorno gli store
                this.addLayerToStore(layer);
                if (layer.name.indexOf("_INFO") < 0) {
                    // registro le action sugli eventi delle feature per i livelli vettoriali
                    app.map.featureManager.registerAction([layer]);
                }
                // aggiorno il controllo per la getFeatureInfo dei livelli WMS se il layer Ã¨ interrogabile
                if (layer.type === "WMS" && layer.queryable) {
                    var infoWmsControl = app.map.getControl("infoWmsControl");
                    if (infoWmsControl) {
                        infoWmsControl.addLayers([olLayer]);
                    }
                }
            }
        }

        // aggiorno il controllo per la selezione delle feature dei livelli vettoriali
        if (app.map) {
            app.map.featureManager.updateControlLayer();
        }


    };

    /**
    *
    * Function: addBaseLayers
    *
    * Aggiunge i baseLayer alla applicazione (aggiorna configurazione, store, mappa e legenda)
    *
    * Parameters:
    * layers - {Array/Object} Array oppure singolo oggetto contenente la configurazione dei layer
    *
    *
    */
    this.addBaseLayers = function(layersIn) {

        CWN2.Util.log("CWN2.LayerManager.addBaseLayers");

        CWN2.Util.assert(layersIn,
            {
                name: "BadParameter",
                message: "CWN2.LayerManager.addBaseLayers: parametro deve essere valorizzato",
                level: 1
            }
        );

        var layers;

        if (layersIn instanceof Array) {
            layers = layersIn;
        } else {
            layers = [layersIn];
        }


        var i,
            len = layers.length,
            layer;


        // aggiungo i layer alla configurazione (se non sono giÃ  presenti)
        for (i = 0; i < len; i++) {
            layer = layers[i];
            if (!this.isBaseLayerInConfig(layer.name)) {
                layer.isBaseLayer = true;
                // aggiorno la configurazione
                this.baseLayersConfig.push(layer);
                // aggiorno la mappa
                app.map.loadLayer(layer);
                // aggiorno gli store
                this.addBaseLayerToStore(layer);
            }
        }

    };

    /**
    *
    * Function: remove
    *
    * Rimuove i layer dalla applicazione
    *
    * Parameters:
    * layersName - {Array} Array contenente i nomi dei layer
    *
    *
    */
    this.remove = function(layersName) {
        CWN2.Util.log("CWN2.LayerManager.remove");

        var layers = (Ext.isArray(layersName))? layersName : [layersName];

        var me = this;

        Ext.each(layers, function(layerName,i) {
            // aggiorno la configurazione
            var index = this.getLayerIndexByName(layerName);
            if (index !== -1){
                this.overlayLayersConfig.splice(index,1);
            }
            // aggiorno la mappa
            app.map.removeLayerByName(layerName);
            //Se il layer ha un hilite sld rimuovo anche il layer dell'hilite
            if (app.map.wmsSldHiliter && app.map.wmsSldHiliter.hilitedLayerName === layerName) {
                app.map.removeLayerByName(app.map.wmsSldHiliter.hiliteLayerName);
            }
            // aggiorno il controllo per la getFeatureInfo dei livelli WMS se il layer Ã¨ interrogabile
            var infoWmsControl = app.map.getControl("infoWmsControl");
            if (infoWmsControl) {
                var infoWmsControlLayers = infoWmsControl.layers;
                if (infoWmsControlLayers) {
                    for (var j = 0; j < infoWmsControlLayers.length; j++) {
                        if (infoWmsControlLayers[j].name === layerName) {
                            infoWmsControlLayers.splice(j,1);
                        }
                    }
                }
            }
            // aggiorno lo store dei layer
            me.removeLayerFromStore(layersName[i]);
        });


        if (app.map) {
            app.map.featureManager.updateControlLayer();
        }

    };

    /**
    *
    * Function: createVectorLayer
    *
    * Crea un layer vettoriale. Utilizzato da Find, CalcoloPercorsi per creare il layer delle evidenziazioni
    *
    * Parameters:
    * config - {Object} Oggetto configurazione della combo.
    *
    * - layerName - {String} Nome del layer
    * - format - {String} Formato del layer (GeoJSON/WFS)
    * - classes - {Array} Array delle classi
    * - infoOptions - {Object} Oggetto contentente le opzioni per la info
    * - legend - {Object} Oggetto contentente la configurazione della legenda
    *
    * Returns:
    * layer - {OpenLayers.Layer.Vector} Il layer vettoriale creato
    *
    */
    this.createVectorLayer = function(config) {

        CWN2.Util.log("CWN2.LayerManager.createVectorLayer");

        var format = config.format;
        var layerName = config.name;
        var classes = config.classes;
        var infoOptions = config.infoOptions;
        var legend = config.legend;
        var showInLegend = false;
        var projection = config.projection || "EPSG:4326";

        if (format !== "GeoJSON") {
            if(CWN2.debug) {
                CWN2.Util.log("ERRORE: CWN2.LayerManager.createVectorLayer: formato non supportato");
            }
            return null;
        }

        if (legend) {
            showInLegend = true;
        }

        // se non esiste creo il layer vettoriale
        if (!this.isLayerInConfig(layerName)) {
            var layerConfig = {
                "type": "GeoJSON",
                "name": layerName,
                "projection": projection,
                "isBaseLayer": false,
                "url": null,
                "visible": true,
                "showInLegend": showInLegend,
                "classes": classes,
                "infoOptions": infoOptions,
                "legend" : legend
            };
            this.addLayers(layerConfig);
        }

        // ritorno il layer
        return app.map.getLayerByName(layerName);

    };

    /**
    *
    * Function: createWMSLayer
    *
    * Crea un layer WMS. Utilizzato da Info per creare il layer delle evidenziazioni
    *
    * Parameters:
    * config - {Object} Oggetto configurazione del layer WMS.
    *
    *
    * Returns:
    * layer - {OpenLayers.Layer.WMS} Il layer WMS creato
    *
    */
    this.createWMSLayer = function(layerConfig) {

        CWN2.Util.log("CWN2.LayerManager.createWMSLayer");

        // se non esiste creo il layer WMS
        if (!this.isLayerInConfig(layerConfig.name)) {
            this.addLayers(layerConfig);
        }

        // ritorno il layer
        return app.map.getLayerByName(layerConfig.name);

    };

    // inizializza gli store dei layer
    this.initStore = function() {

        CWN2.Util.log("CWN2.LayerManager.initStore");

        // inizializzo gli store
        if (app.extRequired) {
            this.buildLayerStoreByType("base");
            this.buildLayerStoreByType("overlay");
        }

    };

    /**
    *
    * Function: getLayersConfig
    *
    * Ritorna la configurazione dei layer
    *
    * Returns:
    * config - {Array} Array contenente la configurazione del layer
    */
    this.getLayersConfig = function() {
        return this.overlayLayersConfig;
    };

    /**
    *
    * Function: getHiliteLayers
    *
    * Ritorna i layer di tipo hilite (hiliteLayer = true)
    *
    * Returns:
    * config - {Array} Array contenente i layer di hilite (nome e hilitedLayerName)
    */
    this.getHiliteLayers = function(hilitedLayerName) {

        var i,
            len = app.map.layers.length,
            hiliteLayers = [];

        for (i = 0; i < len; i++) {
            if (app.map.layers[i].hiliteLayer && app.map.layers[i].hilitedLayerName === hilitedLayerName) {
                hiliteLayers.push(app.map.layers[i]);
            }
        }

        return hiliteLayers;

    };
    /**
    *
    * Function: getBaseLayersConfig
    *
    * Ritorna la configurazione dei baseLayer
    *
    * Returns:
    * config - {Array} Array contenente la configurazione del layer
    */
    this.getBaseLayersConfig = function() {
        return this.baseLayersConfig;
    };

    /*
        Inizializzazione
    */

    CWN2.Util.assert(baseLayers,
        {
            name: "BadConfiguration",
            message: "CWN2.LayerManager.init: baseLayers deve essere valorizzato",
            level: 2
        }
    );

    CWN2.Util.assert(baseLayers.length > 0,
        {
            name: "BadConfiguration",
            message: "CWN2.LayerManager.init: baseLayers deve contenere almeno un layer",
            level: 2
        }
    );


    // Imposto le proprietÃ  dei baseLayer
    this.setBaseLayers();


    // inizializzo gli store
    if (app.extRequired) {
        this.buildLayerStoreByType("base");
        this.buildLayerStoreByType("overlay");
    }

};


/**
*
*
* Function: setLayerVisible
*
* Rende un layer visibile o invisibile in mappa - Metodo Statico
*
* Parameters:
* name - {String} Nome del layer
* visible - {Boolean} Flag che indica se renderlo visibile o invisibile
* appId - {String} Id CWN2.Application
*
*/
CWN2.LayerManager.setLayerVisible = function(name,visible,appId) {

    /*global CWN2:false, Ext:false, window:false, OpenLayers:false */
    "use strict";

    CWN2.Util.log("CWN2.LayerManager.setLayerVisible");

    var app = CWN2.appRegistry.get(appId),
        layer = app.map.getLayerByName(name),
        layerConfig = app.map.layerManager.getLayerConfigByName(name),
        i,
        hilitedLayer,
        hilitedLayerConfig;

    // guardo se ci sono layer di hilite collegati al layer in oggetto
    var hilitedLayers = app.map.layerManager.getHiliteLayers(name);

    if (layer) {
        layer.setVisibility(visible);
        for (i = 0; i < hilitedLayers.length; i++) {
            hilitedLayers[i].setVisibility(visible);
        }
    }

    if (layerConfig) {
        layerConfig.visible = visible;
    }

};/**
 * Class: CWN2.Layout
 *
 *
 * Costruisce il layout della applicazione
 *
 *
*/

/*
 * Constructor: CWN2.Layout
 *
 * Parameters:
 * layoutConfig - {Object} Hashtable con la configurazione del layout
 * appId - {string} Id della applicazione
 *
 */

CWN2.Layout = function(layoutConfig,appId) {

    /*global CWN2:false, Ext:false, window:false, OpenLayers:false */
    "use strict";

    /*
       ProprietÃ 
     */

    this.layout = null;
    this.mapPanel = null;




    /*
        Funzioni private
     */

    function buildPanels(layoutConfig,layout) {

        var panels = [],
               legendPanel,
               mapPanel;

        // pannello legenda
        if (layoutConfig.legend) {
               // creo una legenda di tipo simple
            legendPanel = new CWN2.SimpleLegendPanel(layoutConfig.legend,appId);
            panels.push(legendPanel);
        }

        // pannello mappa
        if (CWN2.MapPanel) {
            layout.mapPanel = new CWN2.MapPanel(layoutConfig,appId);
           panels.push(layout.mapPanel);
        }

        // header
        if (layoutConfig.header) {
            var style = layoutConfig.header.style || null;
            var titlePanel = new Ext.BoxComponent({
                id: "cwn2-layout-title",
                region: 'north',
                style: style,
                autoEl: {
                    tag: 'div',
                    html: layoutConfig.header.html
                }
            });
            if (layoutConfig.header.height) {
                titlePanel.setHeight(layoutConfig.header.height);
            }
            panels.push(titlePanel);
        }

        return panels;

    }


    CWN2.Util.log("CWN2.Layout");

    // costruisco i pannelli (map, legend, title)
    var panelItems = buildPanels(layoutConfig,this);

    // costruisco le opzioni di base
    var basicOptions = {
        defaults: {
            frame: true,
            split: true
        },
        id: "cwn2-container-" + appId,
        layout: "border",
        hideBorders: false,
        forceLayout: true,
        closeAction: "hide",
        items: panelItems
    };

    // construisco il layout
    switch (layoutConfig.type) {
        case "simple":
            CWN2.appRegistry.get(appId).map.render(layoutConfig.divID);
            break;
        case "viewport":
            this.layout =  new CWN2.ViewportLayout(layoutConfig,basicOptions);
            break;
        case "panel":
            this.layout =  new CWN2.PanelLayout(layoutConfig,basicOptions);
            break;
        case "window":
            this.layout =  new CWN2.WindowLayout(layoutConfig,basicOptions);
            break;
    }

};

CWN2.Layout.prototype.setMapTitle = function(title) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    Ext.getCmp("cwn2-map-panel-1").setTitle(title);

};



/**
 *
 * Class: OpenLayers.Control.LoadingPanel
 * In some applications, it makes sense to alert the user that something is 
 * happening while tiles are loading. This control displays a div across the 
 * map when this is going on.
 *
 * Inherits from:
 *  - <OpenLayers.Control>
 */
OpenLayers.Control.LoadingPanel = OpenLayers.Class(OpenLayers.Control, {


    /**
     * Property: counter
     * {Integer} A counter for the number of layers loading
     */ 
    counter: 0,

    /**
     * Property: maximized
     * {Boolean} A boolean indicating whether or not the control is maximized
    */
    maximized: false,

    /**
     * Property: visible
     * {Boolean} A boolean indicating whether or not the control is visible
    */
    visible: true,

    /**
     * Constructor: OpenLayers.Control.LoadingPanel
     * Display a panel across the map that says "loading".
     *
     * Parameters:
     * options - {Object} additional options.
     */
    initialize: function(options) {
         OpenLayers.Control.prototype.initialize.apply(this, [options]);
    },

    /**
     * Function: setVisible
     * Set the visibility of this control
     *
     * Parameters:
     * visible - {Boolean} should the control be visible or not?
    */
    setVisible: function(visible) {
        this.visible = visible;
        if (visible) {
            OpenLayers.Element.show(this.div);
        } else {
            OpenLayers.Element.hide(this.div);
        }
    },

    /**
     * Function: getVisible
     * Get the visibility of this control
     *
     * Returns:
     * {Boolean} the current visibility of this control
    */
    getVisible: function() {
        return this.visible;
    },

    /**
     * APIMethod: hide
     * Hide the loading panel control
    */
    hide: function() {
        this.setVisible(false);
    },

    /**
     * APIMethod: show
     * Show the loading panel control
    */
    show: function() {
        this.setVisible(true);
    },

    /**
     * APIMethod: toggle
     * Toggle the visibility of the loading panel control
    */
    toggle: function() {
        this.setVisible(!this.getVisible());
    },

    /**
     * Method: addLayer
     * Attach event handlers when new layer gets added to the map
     *
     * Parameters:
     * evt - {Event}
    */
    addLayer: function(evt) {
        if (evt.layer) {
            evt.layer.events.register("loadstart", this, this.increaseCounter);
            evt.layer.events.register("loadend", this, this.decreaseCounter);
        }
    },

    /**
     * Method: setMap
     * Set the map property for the control and all handlers.
     *
     * Parameters: 
     * map - {OpenLayers.Map} The control's map.
     */
    setMap: function(map) {
        OpenLayers.Control.prototype.setMap.apply(this, arguments);
        this.map.events.register("preaddlayer", this, this.addLayer);
        for (var i = 0; i < this.map.layers.length; i++) {
            var layer = this.map.layers[i];
            layer.events.register("loadstart", this, this.increaseCounter);
            layer.events.register("loadend", this, this.decreaseCounter);
        }
    },

    /**
     * Method: increaseCounter
     * Increase the counter and show control
    */
    increaseCounter: function() {
        this.counter++;
        if (this.counter > 0) { 
            if (!this.maximized && this.visible) {
                this.maximizeControl(); 
            }
        }
    },
    
    /**
     * Method: decreaseCounter
     * Decrease the counter and hide the control if finished
    */
    decreaseCounter: function() {
        if (this.counter > 0) {
            this.counter--;
        }
        if (this.counter == 0) {
            if (this.maximized && this.visible) {
                this.minimizeControl();
            }
        }
    },

    /**
     * Method: draw
     * Create and return the element to be splashed over the map.
     */
    draw: function() {
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        return this.div;
    },
     
    /**
     * Method: minimizeControl
     * Set the display properties of the control to make it disappear.
     *
     * Parameters:
     * evt - {Event}
     */
    minimizeControl: function(evt) {
        this.div.style.display = "none"; 
        this.maximized = false;
    
        if (evt != null) {
            OpenLayers.Event.stop(evt);
        }
    },
    
    /**
     * Method: maximizeControl
     * Make the control visible.
     *
     * Parameters:
     * evt - {Event}
     */
    maximizeControl: function(evt) {
        this.div.style.display = "block";
        this.maximized = true;
    
        if (evt != null) {
            OpenLayers.Event.stop(evt);
        }
    },

    /** 
     * Method: destroy
     * Destroy control.
     */
    destroy: function() {
        if (this.map) {
            this.map.events.unregister("preaddlayer", this, this.addLayer);
            if (this.map.layers) {
                for (var i = 0; i < this.map.layers.length; i++) {
                    var layer = this.map.layers[i];
                    layer.events.unregister("loadstart", this,
                        this.increaseCounter);
                    layer.events.unregister("loadend", this,
                        this.decreaseCounter);
                }
            }
        }
        OpenLayers.Control.prototype.destroy.apply(this, arguments);
    },     

    CLASS_NAME: "OpenLayers.Control.LoadingPanel"

});
/**
*
*
* Class: CWN2.Map
*
* Oggetto mappa - Eredita da OpenLayers.Map
*
*/

CWN2.Map = OpenLayers.Class(OpenLayers.Map, {



    /*
     * Constant: BASE_CONTROL_CONFIG
     * {Object} Hashtable dei controlli di base
     */
	BASE_CONTROL_CONFIG: [
		{
			"type": "control",
			"name": "ArgParser"
		},
		{
			"type": "control",
			"name": "Attribution"
		},
		{
			"type": "control",
			"name": "KeyboardDefaults"
		},
		{
			"type": "control",
			"name": "Navigation"
		},
		{
			"type": "control",
			"name": "LoadingPanel"
		}
	],

    /**
     * Property: mapOptions
     * {Object} Opzioni mappa - Oggetto configuration.application.mapOptions
     */
    mapOptions: null,

    /**
     * ProprietÃ  Privata: baseLayersConfig
     * {Array} Array delle configurazioni dei baseLayer
     */
    baseLayersConfig: null,

    /**
     * ProprietÃ  Privata: layersConfig
     * {Array} Array delle configurazioni dei layer
     */
    layersConfig: null,

    // Nome del base layer
    baseLayerName: null,

    // layer manager
    layerManager: null,

    // feature manager
    featureManager: null,

    previousExtent: null,

    // livello massimo di zoom ammesso per la mappa
    maxZoomLevel: null,

    appId: null,
    /*
     * Constructor: CWN2.Map
     *
     * Parameters:
     * configMapOptions - {Object} Hashtable of options
     * layerManager - {CWN2.LayerManager} Oggetto layerManager
     */


    initialize: function(configMapOptions,layerManager,appId) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        CWN2.Util.log("CWN2.Map");

        this.setMapOptions(configMapOptions);

        this.appId = appId;

        OpenLayers.Map.prototype.initialize.apply(this, [this.mapOptions]);

        this.load(configMapOptions,layerManager);

    },

    setMapOptions: function(configMapOptions) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        this.mapOptions = {};

        this.setProjection(configMapOptions);

        this.setExtent(configMapOptions);

        this.setUnits(configMapOptions);

        // azzero i controlli della mappa OL - altrimenti fa vedere il controllo PanZoom sempre
        this.mapOptions.controls = [];

    },

    setProjection: function(configMapOptions) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        if(configMapOptions.projection) {
            this.mapOptions.projection = configMapOptions.projection;
        } else {
            this.mapOptions.projection = "EPSG:3857";
        }

        // creo la displayProjection
        if(configMapOptions.displayProjection) {
            this.mapOptions.displayProjection = new OpenLayers.Projection(configMapOptions.displayProjection);
        } else {
            this.mapOptions.displayProjection = new OpenLayers.Projection(this.mapOptions.projection);
        }
    },

    setExtent: function(configMapOptions) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        this.mapOptions.maxExtent = OpenLayers.Bounds.fromString("-20037508, -20037508, 20037508, 20037508.34");

        if (configMapOptions.restrictedExtent) {
            this.mapOptions.restrictedExtent = new OpenLayers.Bounds.fromString(configMapOptions.restrictedExtent);
        }

        this.setMapOptionsInitialExtent(configMapOptions);

    },

    setMapOptionsInitialExtent: function(configMapOptions) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        var bound,
            exception,
            LIG_BOUND_STR,
            boundsStr,
            initialExtentParam,
            fromPrj;

        // Se definito in QueryString lo imposto
        // altrimenti se definito in config lo imposto
        // altrimenti lo imposto sulla liguria
        if (CWN2.Util.getUrlParam("initialExtent")) {
            this.mapOptions.initialExtent = this.calculateInitialExtent(this.getInitialExtentFromUrlParam());
        } else if (configMapOptions.initialExtent){
            this.mapOptions.initialExtent = this.calculateInitialExtent(configMapOptions.initialExtent);
        } else {
            this.mapOptions.initialExtent = this.calculateInitialExtent("830036,5402959,1123018,5597635");
        }

    },

    // deve essere impostato nella forma proj,x1,y1,x2,y2
    // esempio ?initialExtent=EPSG:3857,955508,5496093,1065424,5576964
    getInitialExtentFromUrlParam: function() {
        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        var initialExtentParam = CWN2.Util.getUrlParam("initialExtent").split(",");
        var fromPrj = initialExtentParam.splice(0,1)[0];
        var boundsStr = initialExtentParam.join(",");
        if (this.mapOptions.projection !== fromPrj) {
            boundsStr = CWN2.Util.transformStrBounds(fromPrj,this.mapOptions.projection,boundsStr);
        }
        return boundsStr;
    },

    calculateInitialExtent: function(boundsStr) {
        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        var bound = new OpenLayers.Bounds.fromString(boundsStr);

        if(this.restrictedExtent && !this.restrictedExtent.containsBounds(bound)) {
            var exception = {
                name: "BadInitialExtent",
                message: "CWN2.Map: initialExtent deve essere compreso in restrictedExtent",
                level: 0
            };
            CWN2.Util.handleException(exception);
            return this.maxExtent;
        } else {
            return bound;
        }

    },

    setUnits: function(configMapOptions) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        if (configMapOptions.units) {
            this.mapOptions.units = configMapOptions.units;
        } else {
            this.mapOptions.units = "m";
        }
    },

    load: function(configMapOptions,layerManager) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        this.maxZoomLevel = configMapOptions.maxZoomLevel || 19;
        this.layerManager = layerManager;
        this.baseLayersConfig = this.layerManager.getBaseLayersConfig();
        this.layersConfig = this.layerManager.getLayersConfig();


        // Carico i baseLayers
        this.loadLayers(this.baseLayersConfig);

        // Carico i layers
        this.loadLayers(this.layersConfig);

        // Imposto il base layer
        for (var i = 0; i < this.baseLayersConfig.length; i++) {
            if (this.baseLayersConfig[i].visible) {
                this.baseLayerName = this.baseLayersConfig[i].name;
                var baseLayer = this.getLayerByName(this.baseLayersConfig[i].name);
                this.setBaseLayer(baseLayer);
            }
        }

        // Inizializzo i controlli per la mappa OL
        this.initControls(configMapOptions);

        this.events.register("moveend", null, function() {
            if (this.restrictedExtent && this.zoom < this.getZoomForExtent(this.restrictedExtent)) {
                this.zoomToExtent(this.restrictedExtent);
            }
            if (this.maxZoomLevel && this.zoom > this.maxZoomLevel) {
                this.zoomTo(this.maxZoomLevel);
            }
        });

        // imposto il fractionalZoom
        //TODO non imposto fractional zoom perchÃ¨ non funziona con TMS
        //this.setFractionalZoom();


    },

    /**
    *
    * Function: setFractionalZoom
    *
    * Imposta fractionalZoom della mappa a true se non ci sono layer google
    *
     * Parameters:
     * baseLayersConfig - {Array} Array di oggetti configurazione dei layer di base
    *
    */

    setFractionalZoom: function() {

        "use strict";

        CWN2.Util.log("CWN2.Map.setFractionalZoom");

        var isNotFractionalLayer = false,
            i,
            len = this.baseLayersConfig.length;

        for (i = 0; i < len; i++) {
            if (this.baseLayersConfig[i].type.indexOf("google_") !== -1 || this.baseLayersConfig[i].type.indexOf("TMS") !== -1 ) {
                isNotFractionalLayer = true;
                break;
            }
        }
        if (!isNotFractionalLayer) {
            this.fractionalZoom = true;
        }

    },
    /**
    *
    * Function: loadLayers
    *
    * Aggiunge un array di livelli alla mappa
    *
    *
    * Parameters:
    * layersconfig - {Array} Array di oggetti configurazione dei layer
    *
    */

    loadLayers: function(layersConfig) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        CWN2.Util.log("CWN2.Map.loadLayers");

        // aggiungo i layers alla mappa OL
        if (layersConfig) {
            for (var i = 0; i < layersConfig.length; i++) {
                this.loadLayer(layersConfig[i]);
            }
        }

	},

    /**
    *
    * Function: loadLayer
    *
    * Aggiunge un livello alla mappa
    *
    * Parameters:
    * layerConfig - {Object} Oggetto configurazione del layer
    *
    */

    loadLayer: function(layerConfig) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        CWN2.Util.log("CWN2.Map.loadLayer");

         var layer;

         // creo il layer OL e lo aggiungo alla mappa
         try {
             layer = CWN2.layerFactory.create(layerConfig,this);
         }
         catch (exception) {
             CWN2.Util.handleException(exception);
         }

         if (layer) {
             this.addLayer(layer);
             // Imposto la visibilitÃ  del layer
             layer.setVisibility(layerConfig.visible);
             // Se il layer Ã¨ vettoriale registro l'evento loadend
             // Quando il layer Ã¨ caricato imposto l'attributo loadend a true;
             // Serve per gestire l'hilite delle features all'avvio della applicazione
             if (layer.CLASS_NAME==="OpenLayers.Layer.Vector") {
                 layer.loadend=false;
                 layer.events.on({
                     "loadend": function(){
                         layer.loadend = true;
                     },
                     scope: layer
                 });
             }
             return layer;
         }
	},


    /**
     *
     * Function: initControls
     *
     * Inizializza i controlli OpenLayers della mappa.
     *
     */

    initControls: function(configMapOptions) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        // inizializzo i controlli per la selezione delle feature dei livelli vettoriali
        this.featureManager = new CWN2.FeatureManager(this);

        // carico i controlli opzionali definiti in configurazione
        this.loadControls(configMapOptions.olControls);

        // Carico i controlli base
        // Se impostato noBaseControls a true non carica i controlli di base (mappa bloccata)
        if (!this.mapOptions.noBaseControls) {
            this.loadControls(this.BASE_CONTROL_CONFIG);
        }

        if (configMapOptions.disableScrollWheel) {
            var navControls = this.getControlsByClass("OpenLayers.Control.Navigation");
            for(var i = 0; i < navControls.length; ++i)
                navControls[i].disableZoomWheel();
        }

	},

    /**
    *
    * Function: loadControls
    *
    * Carica i controlli OL sulla mappa.
    *
    * Parameters:
    * controlsConfig - {Array} cArray oggetti configurazione dei controlli
    *
    */

    loadControls: function(controls) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        CWN2.Util.log("CWN2.Map.loadControls");

        // aggiungo i controlli alla mappa OL
        if (controls) {
            for (var i = 0; i < controls.length; i++) {
                this.loadControl(controls[i]);
            }
        }
	},

    /**
    *
    * Function: loadControl
    *
    * Carica un controllo OL sulla mappa.
    *
    * Parameters:
    * controlConfig - {Object} Oggetto di configurazione del controllo
    *
    */

    loadControl: function(controlConfig) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        CWN2.Util.log("CWN2.Map.loadControl");

        // creo il controllo OL e lo aggiungo alla mappa

        try {
            var olControl = CWN2.controlFactory.create(controlConfig);
            this.addControl(olControl);
            return olControl;
        }
        catch (exception) {
            CWN2.Util.handleException(exception);
            return null;
        }

	},

    /**
    * Function: isBaseLayer
    *
    * Ritorna true se il layer Ã¨ il layer base della mappa
    *
    * Parameters:
    * name - {string} Nome del layer
    *
    * Returns:
    * {Boolean}
    */

    isBaseLayer: function(name) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        return name === this.baseLayerName;

    },

    /**
    * Function: getLayerByName
    *
    * Ritorna il layer OL con un certo nome
    *
    * Parameters:
    * name - {String} Name of the layer
    *
    * Returns:
    * layer - {OpenLayers.Layer}
    *
    */
    getLayerByName: function(name) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        var layers = this.getLayersByName(name);
        if (layers.length > 0) {
            return layers[0];
        } else {
            return null;
        }
    },

    /**
     * Function: removeLayerByName
    *
    * Rimuove un layer dalla mappa
    *
    * Parameters:
     * name - {string} Name of the layer
    *
    */
    removeLayerByName: function(name) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        var layers = this.getLayerByName(name);
        if(layers) {
            this.removeLayer(layers);
        }

    },

    /**
    * Function: zoomToStringExtent
    *
    * Effettua lo zoom su un bound, eventualmente converte il bound nel sistema di coordinate della mappa
    *
    * Parameters:
    * boundsString - {string} Bound in formato "x1,y1,x2,y2"
    * epsgCode - {string} Codice EPSG in formato "EPSG:XXXX"
    *
    */
    zoomToStringExtent: function(boundsString,epsgCode) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        var boundStr = boundsString;

        // se boundsString Ã¨ in una proiezione diversa dalla mappa converto in proiezione mappa
        if ((epsgCode) && (this.projection !== epsgCode)) {
            boundStr = CWN2.Util.transformStrBounds(epsgCode,this.projection,boundsString);
        }

        var bounds = new OpenLayers.Bounds.fromString(boundStr);

        this.zoomToExtent(bounds);

    },

    /**
    * Function: zoomToInitialExtent
    *
    * Effettua lo zoom sull'initialExtent
    *
    */
    zoomToInitialExtent: function() {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        // devo richiamare due volte altrimenti non fa zoom ???
        this.zoomToExtent(this.initialExtent);
        this.zoomToExtent(this.initialExtent);
    },


    /**
    * Function: zoomToInitialExtent
    *
    * Effettua lo zoom sull'initialExtent
    *
    */
    zoomToPoint: function(x,y,zoomLevel) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";
        var geom = new OpenLayers.Geometry.Point(x,y);
        var bounds = geom.getBounds().clone();

        this.zoomToExtent(bounds, false);
        if (zoomLevel && this.zoom > zoomLevel) {
            if (!this.baseLayer.maxZoomLevel || zoomLevel < this.baseLayer.maxZoomLevel) {
                this.zoomTo(zoomLevel);
            }
        }

    },
    /**
    * Function: setInitialExtent
    *
    * Imposta l'initialExtent della mappa
    *
    */
    setInitialExtent: function(extent) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        this.initialExtent = extent;
    },

    /**
    * Function: zoomToFeatures
    *
    * Effettua uno zoom sulle feature
    *
    * Parameters:
    * features - {Array} Array di features openlayer
    * zoomLevel - {Number} Livello di zoom.
    *
    */
    zoomToFeatures : function(features,zoomLevel) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        var numFeatures,
            i,
            bounds;

        if(features && features.length) {
            numFeatures = features.length;
        }

        if (numFeatures) {
            bounds = features[0].geometry.getBounds().clone();
            for (i = 1; i < numFeatures; i++) {
                bounds.extend(features[i].geometry.getBounds());
            }

            this.zoomToExtent(bounds, false);


            // se zoomlevel Ã¨ negativo faccio zoom all'indietro
            if (zoomLevel && zoomLevel < 0) {
                this.zoomTo(this.zoom + zoomLevel)
            } else {
                if (zoomLevel && this.zoom > zoomLevel) {
                    this.zoomTo(zoomLevel);
                }
            }
        }
    },

    /**
    * Function: zoomToLonlat
    *
    * Effettua uno zoom su un punto ad un determinato zoomLevel
    *
    * Parameters:
    * xy - {lonlat} oggetto lonlat openlayer
    * zoom - {Number} Livello di zoom.
    *
    */
    zoomToLonlat : function(lonlat,zoom) {

        /*global CWN2:false, window:false, OpenLayers:false */
        "use strict";

        if (this.isValidZoomLevel(zoom)) {
            this.setCenter(lonlat, zoom);
        }
    },

	CLASS_NAME: "CWN2.Map"
});


/**
*
* Function: setBaseLayerOnMap
*
* Imposta il layer base su una mappa (metodo statico)
*
* Parameters:
* name - {String} Nome del layer
* appId - {String} ID della CWN2.Application
*
*/
CWN2.Map.setBaseLayerOnMap = function(name,appId) {

    /*global CWN2:false, window:false, OpenLayers:false */
    "use strict";

    var app = CWN2.appRegistry.get(appId);

    app.map.baseLayerName = name;

    var layer = app.map.getLayerByName(name);
    if (name === "sfondo_bianco") {
        app.map.baseLayer.setVisibility(false);
        //document.getElementById('radio_sfondo_bianco').checked = true;
    }
    else {
        if (layer) {
            app.map.setBaseLayer(layer);
            layer.setVisibility(true);
        }
    }

};



/*
 *  Class: OpenLayersExt.js
 *  
 *  Estensioni delle classi Openlayers.
 *
 *  Vengono implementati OVERRIDE di metodi OL per rimediare bug o personalizzare il comportamento
 *  
 */	



/*
 *  Function: OpenLayers.Layer.Vector.setOpacity
 *  
 *  Serve per rimediare un bug OL:
 *
 *  Se ho attivo il controllo SelectFeature su piÃ¹ di un livello vettoriale il metodo non funziona.
 *
 *  Bisogna intervenire non sul livello stesso (this) ma sul layer di tipo RootContainer e in
 *      particolare sul div che ha id = Layer.id + "_root"
 *  
 *  
 */	
OpenLayers.Layer.Vector.prototype.setOpacity = function(opacity) {


	//	CWN2.Util.log('Openlayers.Layer.Vector.setOpacity');

    if (opacity != this.opacity) {
        this.opacity = opacity;
        for(var i=0, len=this.div.childNodes.length; i<len; ++i) {
			if (this.div.childNodes[i].firstChild) {
				var element = this.div.childNodes[i].firstChild;
				OpenLayers.Util.modifyDOMElement(element, null, null, null, null, null, null, opacity);
			} else {
				var elementRoot = document.getElementById(this.id + "_root");
				if (elementRoot) {
					OpenLayers.Util.modifyDOMElement(elementRoot, null, null, null, null, null, null, opacity);
				}
			}
        }
        if (this.map != null) {
            this.map.events.triggerEvent("changelayer", {
                layer: this,
                property: "opacity"
            });
        }
    }
};


/*
 *  Function: OpenLayers.Control.SelectFeature.unhighlight
 *  
 *  Serve per rimediare un bug OL:
 *
  * Se ho attivi 2 controlli SelectFeature (di cui uno per l'highlight)
 *  quando deseleziono una feature dopo una interrogazione guardo se la feature
 *  Ã¨ tra quelle highlight e nel caso applico l'hilite relativo altrimenti il default
 *  
 *  
 */	
OpenLayers.Control.SelectFeature.prototype.unhighlight = function(feature) {

    //CWN2.Util.log('OpenLayers.Control.SelectFeature.prototype.unhighlight');

    var layer = feature.layer;
    // three cases:
    // 1. there's no other highlighter, in that case _prev is undefined,
    //    and we just need to undef _last
    // 2. another control highlighted the feature after we did it, in
    //    that case _last references this other control, and we just
    //    need to undef _prev
    // 3. another control highlighted the feature before we did it, in
    //    that case _prev references this other control, and we need to
    //    set _last to _prev and undef _prev
    if(feature._prevHighlighter == undefined) {
        delete feature._lastHighlighter;
    } else if(feature._prevHighlighter == this.id) {
        delete feature._prevHighlighter;
    } else {
        feature._lastHighlighter = feature._prevHighlighter;
        delete feature._prevHighlighter;
    }

    // guardo se la feature Ã¨ tra quelle hilited
    var hilited = false;
    var hilitedFeatures = CWN2.featureHiliter.getHilitedFeatures(layer.map.id);

    if (hilitedFeatures) {
        for(var j = hilitedFeatures.length-1; j >= 0; --j) {
            if (feature === hilitedFeatures[j]) {
                hilited = true;
            }
        }
    }

    if (hilited) {
        CWN2.featureHiliter.hiliteFeature(layer.map.featureManager.hiliteFeatureControl,feature);
    } else {
        layer.drawFeature(feature, feature.style || feature.layer.style ||
        "default");
    }

    this.events.triggerEvent("featureunhighlighted", {feature : feature});

};

/*
 *  Function: OpenLayers.Feature.isSelected
 *
 *
 *  Nuovo metodo: ritorna true se la feature Ã¨ tra quelle selezionate
 *
 */

OpenLayers.Feature.prototype.isSelected = function() {

    var selected = this.layer.selectedFeatures;

    for (var i = 0; i < selected.length; i++) {
        if (this === selected[i]) {
            return true;
        }
    }
    return false;

};




/*
 *  Function: OpenLayers.Control.WMSGetFeatureInfo.findLayers
 *
 *
 *  Override metodo findLayer: verifica che il layer sia nel range di scala
 *
 */

OpenLayers.Control.WMSGetFeatureInfo.prototype.findLayers = function() {

    var candidates = this.layers || this.map.layers;
    var layers = [];
    var layer, url;
    for(var i = candidates.length - 1; i >= 0; --i) {
        layer = candidates[i];
// INIZIO MODIFICHE - verifico che il layer sia nel range di scala
        if(layer instanceof OpenLayers.Layer.WMS &&
          (!this.queryVisible || layer.getVisibility()) &&
          layer.inRange) {
//            if(layer instanceof OpenLayers.Layer.WMS &&
//               (!this.queryVisible || layer.getVisibility())) {
// FINE MODIFICHE
            url = OpenLayers.Util.isArray(layer.url) ? layer.url[0] : layer.url;
            // if the control was not configured with a url, set it
            // to the first layer url
            if(this.drillDown === false && !this.url) {
                this.url = url;
            }
            if(this.drillDown === true || this.urlMatches(url)) {
                layers.push(layer);
            }
        }
    }
    return layers;
};

/*
 *  Function: OpenLayers.Control.WMSGetFeatureInfo.addLayers
 *
 *
 *  Nuova funzione: permette di aggiungere layers all'array dei layer interrogabili
 *
 * Parameters:
 * layers - {Array} Array dei layer OL da aggiungere
 *
 */

OpenLayers.Control.WMSGetFeatureInfo.prototype.addLayers = function(layers) {

    if (!this.layers) {
        this.layers = [];
    }
    for (var i = 0; i < layers.length; i++) {
        this.layers.push(layers[i])
    }

};

/**
 * Class: OpenLayers.Strategy.RuleCluster
 * Strategy for vector feature clustering according to a given rule.
 *
 * Inherits from:
 *  - <OpenLayers.Strategy.Cluster>
 */
OpenLayers.Strategy.RuleCluster = OpenLayers.Class(OpenLayers.Strategy.Cluster, {
    /**
     * the rule to use for comparison
     */
    rule: null,
    /**
     * Method: shouldCluster
     * Determine whether to include a feature in a given cluster.
     *
     * Parameters:
     * cluster - {<OpenLayers.Feature.Vector>} A cluster.
     * feature - {<OpenLayers.Feature.Vector>} A feature.
     *
     * Returns:
     * {Boolean} The feature should be included in the cluster.
     */
    shouldCluster: function(cluster, feature) {
        var superProto = OpenLayers.Strategy.Cluster.prototype;
        return this.rule.evaluate(cluster.cluster[0]) &&
               this.rule.evaluate(feature) &&
               superProto.shouldCluster.apply(this, arguments);
    },
    CLASS_NAME: "OpenLayers.Strategy.RuleCluster"
});

/*
 *  Function: OpenLayers.Strategy.Cluster.cluster
 *
 *
 *  Override metodo cluster: se un cluster Ã¨ formato da una sola feature eredita gli attributi della feature
 *
 */

OpenLayers.Strategy.Cluster.prototype.cluster = function(event) {

    if((!event || event.zoomChanged) && this.features) {
         var resolution = this.layer.map.getResolution();
         if(resolution != this.resolution || !this.clustersExist()) {
             this.resolution = resolution;
             var clusters = [];
             var feature, clustered, cluster;
             for(var i=0; i<this.features.length; ++i) {
                 feature = this.features[i];
                 if(feature.geometry) {
                     clustered = false;
                     for(var j=clusters.length-1; j>=0; --j) {
                         cluster = clusters[j];
                         if(this.shouldCluster(cluster, feature)) {
                             this.addToCluster(cluster, feature);
                             clustered = true;
                             break;
                         }
                     }
                     if(!clustered) {
                         clusters.push(this.createCluster(this.features[i]));
                     }
                 }
             }
             this.layer.removeAllFeatures();
             if(clusters.length > 0) {
                 if(this.threshold > 1) {
                     var clone = clusters.slice();
                     clusters = [];
                     var candidate;
                     for(var i=0, len=clone.length; i<len; ++i) {
                         candidate = clone[i];
                         if(candidate.attributes.count < this.threshold) {
                             Array.prototype.push.apply(clusters, candidate.cluster);
                         } else {
                             clusters.push(candidate);
                         }
                     }
                 }
                 // INIZIO MODIFICHE - se cluster contiene una sola feature copio gli attributi della feature nel cluster
                 for(var i=0, len=clusters.length; i<len; ++i) {
                     cluster = clusters[i];
                     if(cluster.attributes.count === 1) {
                         feature = cluster.cluster[0].clone();
                         cluster.attributes = feature.attributes;
                         cluster.attributes.count = 1;
                     }
                 }
                 // FINE MODIFICHE
                 this.clustering = true;
                 // A legitimate feature addition could occur during this
                 // addFeatures call.  For clustering to behave well, features
                 // should be removed from a layer before requesting a new batch.
                 this.layer.addFeatures(clusters);
                 this.clustering = false;
             }
             this.clusters = clusters;
         }
     }
};


