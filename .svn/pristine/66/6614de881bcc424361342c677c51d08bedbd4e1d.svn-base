/**
 * Created by parodi on 02/08/2016.
 */
/**
 *
 *
 *
 */

var GV = GV || {};

GV.Models = {};

GV.Buttons = {};

GV.Views = {};

/**
 * Created by parodi on 02/08/2016.
 */

GV.Util = function () {
    "use strict";

    // Public API
    return {

        /**
         *  Function: getUrlParam
         *
         *  Ritorna il valore di un parametro nella queryString
         *
         *  Parameters:
         *  paramName - {String} Nome del parametro
         *
         *  Returns:
         *  {String} Valore del parametro (se non trovato ritorna 0)
         *
         */

        getUrlParam: function (paramName) {
            var results = new RegExp("[\\?&]" + paramName + "=([^&#]*)").exec(window.location.href);
            GV.Util.log("GV.Util.getUrlParam");

            return results ? decodeURIComponent(results[1]) : null;
        },

        /**
         *  Function: getUrlParam
         *
         *  Ritorna il valore di un parametro nella queryString
         *
         *  Parameters:
         *  url - {String} Stringa contenente la URL
         *  paramName - {String} Nome del parametro
         *
         *  Returns:
         *  {String} Valore del parametro (se non trovato ritorna 0)
         *
         */

        getUrlParamFromString: function (url, paramName) {
            var results = new RegExp("[\\?&]" + paramName + "=([^&#]*)").exec(url);
            if (!results) {
                return 0;
            }
            return results[1] || 0;
        },

        /**
         *  Function: log
         *
         *  Scrive un messaggio sulla console
         *
         *  Parameters:
         *  msg - {String} Messaggio da scrivere
         *
         */

        log: function (message, level) {
            var action = "log";

            if (!GV.debug) {
                return;
            }

            switch (level) {
            case 0:
                action = "warn";
                break;
            case 1:
            case 2:
                action = "error";
                break;
            default:
                action = "info";
                break;
            }

            try {
                console[action](message);
            } catch (e) {
            }
        },

        /**
         *  Function: msgBox
         *
         *  Manda un alert di avviso all'utente
         *
         *  Parameters:
         *  msg - {string} Messaggio da scrivere sull'alert
         *
         */

        msgBox: function (msg) {
            window.alert(msg);
        },


        setUnderscoreTemplate: function () {
            if (_) {
                _.templateSettings = {
                    interpolate: /\{\{(.+?)\}\}/g
                };
            }
        },

        /**
         * Function: getJSON
         *
         * Funzione per caricare un oggetto json remoto in maniera sincrona o asincrona.
         *
         * Ritorna un oggetto javascript contentente la deserializzazione del json
         *
         * Parameters:
         * url - {String} Url del file o del servizio
         * urlParams - {Object} Oggetto map contenente i parametri da passare. Vedi http://api.jquery.com/jQuery.ajax/
         * aSync - {Boolean} Flag che indica se effettuare una richiesta asincrona
         * callBack {Function} Funzione da richiamare dopo il caricamento
         * args - {Object/Array} Aregomento o Array degli argumuments opzionali dal passare alla funzione di callback
         *
         * Returns:
         * {object} L'oggetto contenente la deserializzazione del JSON
         *
         */
        ajax: function (options, callback) {
            var defaultOptions = {
                jsonpCallback: 'getJson',
                type: "GET"
            };

            GV.Util.log("GV.Util.ajax");

            $.ajax(_.extend(defaultOptions, options)).done(function (json) {
                try {
                    if (callback) {
                        callback(json);
                    }
                }
                catch (exception) {
                    console.error(exception.message);
                }
            }).fail(function (jqXHR, textStatus, errorThrown) {
                if (jqXHR.statusText !== "OK") {
                    console.error("GV.Util.ajax - Non sono riuscito a caricare la url:\n" + url + "\nErrore: " + jqXHR.status + " - " + textStatus + " - " + errorThrown);
                }
            });

        },

        /**
         * Function: parseXML
         *
         * Funzione per fare il parsing di una stringa xml
         *
         * Ritorna un oggetto doc xml
         *
         * Parameters:
         * xmlString - {String} Stringa xml
         *
         * Returns:
         * {object} Oggetto xmlDoc
         *
         */
        parseXML: function (xmlString) {
            GV.Util.log("GV.Util.parseXML");
            try {
                var xmlDoc = null;
                if (window.DOMParser && window.XSLTProcessor) {
                    var parser = new DOMParser();
                    xmlDoc = parser.parseFromString(xmlString, "text/xml");
                } else {
                    xmlDoc = new ActiveXObject("Msxml2.DOMDocument.3.0");
                    xmlDoc.async = false;
                    xmlDoc.loadXML(xmlString);
                }
                return xmlDoc;
            } catch (exception) {
                throw {
                    name: "xmlTransformation",
                    message: "GV.Util.parseXml: errore parsing xml - " + exception.message,
                    level: 1
                };
            }
        },


        /**
         *
         * Function: isPointInLig
         *
         * Controlla se un punto appartenga al BBOX del territorio ligure
         *
         * Parameters:
         * x - {number} Coordinata X
         * y - {number} Coordinata Y
         *
         * Returns:
         * {boolean} true/false
         *
         */
        isPointInLig: function (x, y) {
            GV.Util.log("GV.Util.isPointInLig");

            if (!x || !y) {
                return false;
            }

            var minX = 7.4, minY = 43.7, maxX = 10.1, maxY = 44.8;

            return (x > minX) && (x < maxX) && (y > minY) && (y < maxY);
        },

        /**
         * Function: toArray
         *
         * Converte Oggetto in Array
         *
         * Parameters:
         * obj - {Object} Oggetto da clonare
         *
         * Returns:
         * {Array} Array
         *
         */
        toArray: function (obj) {
            return Array.prototype.slice.call(obj);
        },

        /**
         * Function: bind
         *
         * Effettua la bind di una funzione ad uno scope
         *
         * Parameters:
         * scope - {Object} Oggetto da utilizzare come scope
         * fn - {Function} Funzione su cui effettuare la bind
         *
         * Returns:
         * {Function} Funzione con bind effettuato
         *
         */
        bind: function (scope, fn) {
            return function () {
                return fn.apply(scope, GV.Util.toArray(arguments));
            };
        },

        /**
         * Function: getArrayElementByAttribute
         *
         * Ritorna un elemento di un array contenente un attributo con un determinato valore
         *
         * Parameters:
         * array - {Array} array su cui cercare l'elemento
         * attributo - {string} Nome dell'attributo dell'elemento
         * value - {string} Valore dell'attributo
         *
         * Returns:
         * {Object} Oggetto
         *
         */
        getArrayElementByAttribute: function (array, attribute, value) {
            if (!array) {
                return null;
            }

            var i,
                len = array.length;

            for (i = 0; i < len; i++) {
                if (array[i][attribute] === value) {
                    return array[i];
                }
            }

            return null;
        },
        /**
         * Function: geoCode
         *
         * Effettua il geocode di un indirizzo utilizzando i servizi google
         *
         * Parameters:
         * address - {string} Indirizzo
         * properties - {Object} oggetto contenente le proprietà da aggiungere all'oggetto properties della feature
         * callback - {function} funzione di callback
         *
         * Returns:
         * {GeoJSON Object}
         *
         */
        geoCode: function (address, properties, callback) {

            var geocoder = new google.maps.Geocoder();

            geocoder.geocode({"address": address}, function (results, status) {
                if (status === google.maps.GeocoderStatus.OK) {

                    var x = results[0].geometry.location.lng();
                    var y = results[0].geometry.location.lat();
                    var feature = {
                        "type": "FeatureCollection",
                        "features": [
                            {
                                "type": "Feature",
                                "geometry": {"type": "Point", "coordinates": [x, y]},
                                "properties": {
                                    "address": address
                                }
                            }
                        ]
                    };
                    if (properties) {
                        for (var p in properties) {
                            if (properties.hasOwnProperty(p)) {
                                feature.features[0].properties[p] = properties[p];
                            }
                        }
                    }
                    callback(feature);
                } else {
                    if (status === google.maps.GeocoderStatus.ZERO_RESULTS) {
                        GV.Util.msgBox("Indirizzo '" + address + "' non trovato");
                    } else {
                        console.error("Errore di geocoding: " + status);
                    }
                }
            });

        },

        getParamString: function (obj, existingUrl, uppercase) {
            var params = [];
            for (var i in obj) {
                params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
            }
            return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
        },

        template: function (str, data) {
            var templateRe = /\{ *([\w_\-]+) *\}/g;
            return str.replace(templateRe, function (str, key) {
                var value = data[key];

                if (value === undefined) {
                    throw new Error('No value provided for variable ' + str);

                } else if (typeof value === 'function') {
                    value = value(data);
                }
                return value;
            });
        },

        getZoomFromScaleDenom: function (scaleDenom) {
            return _.findIndex(GV.Globals.BASE_SCALES, function (scale) {
                return scaleDenom > scale;
            });
        },

        getScaleLabelsFromZoom: function (zoom) {
            return GV.Globals.BASE_SCALE_LABELS[zoom]
        },

        getScaleFromZoom: function (zoom) {
            return GV.Globals.BASE_SCALES[zoom]
        }

    };
}();/**
 * Created by parodi on 02/08/2016.
 */



GV.App = Marionette.Application.extend({

    initialize: function (options) {
        'use strict';
        var self = this;

        // Creo variabile globale GV.app
        GV.app = this;


        GV.debug = options.debug;
        this.proxy = options.proxy || GV.Globals.DEFAULT_PROXY;

        GV.Util.log('GV.App.initialize');
        GV.Util.log(options);

        if (!options) {
            GV.debug = true;
            GV.Util.log('GV.App: Mancano opzioni di configurazione', 2);
            return;
        }

        //GV.Util.setUnderscoreTemplate();

        // inizializzo collection rlMaps
        GV.rlMaps = new GV.Models.RlMaps();

        // inizializzo layerFactory
        GV.layerFactory = new GV.LayerFactory();

        //istanzio Layout Base
        this.layout = new GV.Views.Layout(options);
        this.map = this.layout.map;
        this.layout.render(options);

        // Gestione caricamento mappe/livelli da configurazione (options.config.maps)
        if (options.config && options.config.maps && options.config.maps.length > 0) {
            _.each(options.config.maps, function (mapConfig) {
                GV.rlMaps.add(new GV.Models.RlMap(mapConfig));
            });
        }

        // Gestione caricamento mappe RL da servizio
        if (options.idMap) {
            this.addRlMap(options.idMap, options);
        } else {
            if (options && options.callback) {
                options.callback(self);
            }
        }

        // avvio automatico applicazione
        this.start(options);
    },

    addRlMap: function (idMap, options) {
        'use strict';
        var self = this;
        $.ajax({
            url: GV.Globals.RL_MAP_CONFIG_SERVICE + idMap,
            dataType: 'jsonp'
        }).done(function (response) {
            var mapConfig = response.data;
            GV.rlMaps.add(new GV.Models.RlMap(mapConfig));
            if (options && options.callback) {
                options.callback(self);
            }
            //gestione extent
            if (mapConfig.extent_3857) {
                self.map.setInitialExtent(mapConfig.extent_3857);
            }
            //gestione titolo
            //TODO non su schermi piccoli
            if (options.setMapTitle) {
                $('#gv-container').append("<div id='gv-title'>" + mapConfig.name + "</div>");
            }
            //TODO: gestione find
        });
    }

});

/*
// funzione factory crea una variabile GV.app per accedere alla applicazione
GV.app = function (options) {
    'use strict';
    this.app = new GV.App(options);
    return this.app;
};
*/
/**
 * Created by parodi on 02/08/2016.
 */
/**
 *
 *
 *
 */

var GV = GV || {};

GV.Models = {};

GV.Buttons = {};

GV.Views = {};

/**
 * Created by parodi on 02/08/2016.
 */

GV.Globals = {
    DEFAULT_PROXY: '/geoservices/proxy/proxy.jsp?url=',

    RL_MAP_CONFIG_SERVICE: 'http://geoportale.regione.liguria.it/geoservices/REST/config/map/',
    RL_CREATE_SLD_SERVICE: 'http://geoportale.regione.liguria.it/geoservices/REST/config/create_sld/',

    RL_METADATA_URL: '/geoservices/REST/metadata/scheda_xml/',

    INFO_WMS_MAX_FEATURES: 10,

    BASE_SCALES: [
        591657550.500000,
        295828775.300000,
        147914387.600000,
        73957193.820000,
        36978596.910000,
        18489298.450000,
        9244649.227000,
        4622324.614000,
        2311162.307000,
        1155581.153000,
        577790.576700,
        288895.288400,
        144447.644200,
        72223.822090,
        36111.911040,
        18055.955520,
        9027.977761,
        4513.988880,
        2256.994440,
        1128.497220
    ],

    BASE_SCALE_LABELS: {
        8: '1:1.600.000',
        9: '1:800.000',
        10: '1:400.000',
        11: '1:200.000',
        12: '1:100.000',
        13: '1:50.000',
        14: '1:25.000',
        15: '1:12.500',
        16: '1:6.250',
        17: '1:3.125',
        18: '1:1.560',
        19: '1:800',
        20: '1:400'
    }


};/**
 * Created by parodi on 02/08/2016.
 */


GV.InfoWmsManager = function () {
    'use strict';
    return {
        _requestCount: 0,
        _numRequests: 0,
        _features: [],

        activate: function (map) {
            GV.Util.log('GV.infoWmsManager.activate');

            // Attivo evento click
            map.on('click', GV.infoWmsManager.request);
        },

        buildWMSOptions: function (url, layers, latlng) {
            var point = GV.app.map.latLngToContainerPoint(latlng, GV.app.map.getZoom()),
                size = GV.app.map.getSize(),
                bounds = GV.app.map.getBounds(),
                sw = GV.app.map.options.crs.project(bounds.getSouthWest()),
                ne = GV.app.map.options.crs.project(bounds.getNorthEast());

            var params = {
                request: 'GetFeatureInfo',
                service: 'WMS',
                crs: 'EPSG:3857',
                styles: '',
                version: '1.1.0',
                format: 'application/json',
                bbox: sw.x + ',' + sw.y + ',' + ne.x + ',' + ne.y,
                height: size.y,
                width: size.x,
                layers: layers,
                query_layers: layers,
                FEATURE_COUNT: 100,
                buffer: 10,
                info_format: 'application/json'
            };

            _.extend(params, {});
            params[params.version === '1.3.0' ? 'i' : 'x'] = point.x;
            params[params.version === '1.3.0' ? 'j' : 'y'] = point.y;

            //TODO gestione PROXY
            return GV.app.proxy + url + GV.Util.getParamString(params, url, true);
        },

        handleResponse: function(features) {
            GV.infoWmsManager._requestCount++;
            _.each(features, function (feature) {
                feature.layer = feature.id.split('.')[0];
            });
            Array.prototype.push.apply(GV.infoWmsManager._features, features);
            if (GV.infoWmsManager._requestCount === GV.infoWmsManager._numRequests) {
                $('.leaflet-container').css('cursor', 'default');
                //TODO gestire output
                console.log(GV.infoWmsManager._features);
                alert('GFI' + GV.infoWmsManager._features.length);
            }

            /*
             var feature = response.features[0];
             if (feature) {
             L.popup()
             .setLatLng(e.latlng)
             .setContent(L.Util.template("<h2>{COD_PROV}</h2>", feature.properties))
             .openOn(map);
             }
             */
        },

        request: function (e) {
            GV.infoWmsManager._requestCount = 0;
            GV.infoWmsManager._numRequests = 0;
            GV.infoWmsManager._features = [];

            // Ciclo sulle mappe caricate
            var rlMaps = GV.rlMaps.toJSON();
            _.each(rlMaps, function (rlMap) {
                var url = null,
                    layersArray = [];

                // Ciclo sui layer caricati sulla mappa leaflet
                _.each(rlMap.layers, function (layerConfig) {
                    if (layerConfig.idMap === rlMap.id && layerConfig.type === 'WMS' && layerConfig.queryable && layerConfig.visible && GV.app.map.layerInRange(layerConfig)) {
                        url = layerConfig.wmsParams.url;
                        layersArray.push(layerConfig.wmsParams.name);
                    }
                });

                var layers = layersArray.join(',');

                if (url && layersArray.length > 0) {
                    var wmsUrl = GV.infoWmsManager.buildWMSOptions(url, layers, e.latlng);
                    GV.infoWmsManager._numRequests++;
                    $('.leaflet-container').css('cursor', 'wait');
                    $.ajax({
                        url: wmsUrl,
                        dataType: 'json'
                    }).done(function (response) {
                        GV.infoWmsManager.handleResponse(response.features);
                    });
                }


            });
        }
    };

};

GV.LayerFactory = function () {
    "use strict";
    var esriLink = '<a href="http://www.esri.com/">Esri</a>';

    return {

        lastZIndex: 11,

        createPane: function (name, zIndex, map) {
            var tilePane = map.getPane('tilePane');
            var pane = map.createPane(name, tilePane);
            pane.style.zIndex = zIndex;
            return pane;
        },

        create: function (layerConfig, map) {
            var layer = this[layerConfig.type](layerConfig, map);
            layer.legend = layerConfig.legend;
            layer.config = layerConfig;
            return layer;
        },

        OSM: function (layerConfig) {
            layerConfig.legend = {
                label: "OpenStreetMap"
            };
            return L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Map data © <a href="http://openstreetmap.org">OpenStreetMap</a> contributors'
            });
        },

        ESRI_IMAGERY: function (layerConfig, map) {
            layerConfig.legend = {label: "ESRI Imagery"};
            layerConfig.name = layerConfig.type;
            //this.createPane(layerConfig.name, 1, map);
            var attr = 'DigitalGlobe, GeoEye, i-cubed, USDA, USGS, AEX, Getmapping, Aerogrid, IGN, IGP, swisstopo, and the GIS User Community';
            return L.tileLayer(
                'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                {
                    attribution: '&copy; ' + esriLink + ', ' + attr,
                    maxZoom: 19 //,pane: layerConfig.name
                }
            );
        },

        ESRI_STREETS: function (layerConfig, map) {
            layerConfig.legend = {label: "ESRI Streets"};
            layerConfig.name = layerConfig.type;
            //this.createPane(layerConfig.name, 1, map);
            var attr = 'USGS, NOAA';
            return L.tileLayer(
                'http://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',
                {
                    attribution: '&copy; ' + esriLink + ', ' + attr,
                    maxZoom: 19 //,pane: layerConfig.name
                }
            );
        },

        ESRI_TOPOGRAPHIC: function (layerConfig, map) {
            layerConfig.legend = {label: "ESRI Topographic"};
            layerConfig.name = layerConfig.type;
            //this.createPane(layerConfig.name, 1, map);
            var attr = 'USGS, NOAA';
            return L.tileLayer(
                'http://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}',
                {
                    attribution: '&copy; ' + esriLink + ', ' + attr,
                    maxZoom: 19 //,pane: layerConfig.name
                }
            );
        },

        ESRI_GRAY: function (layerConfig, map) {
            layerConfig.legend = {label: "ESRI Gray"};
            layerConfig.name = layerConfig.type;
            //this.createPane(layerConfig.name, 1, map);
            var attr = 'HERE, DeLorme, MapmyIndia, OpenStreetMap contributors';
            return L.tileLayer(
                'http://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}',
                {
                    attribution: '&copy; ' + esriLink + ', ' + attr,
                    maxZoom: 16 //,pane: layerConfig.name
                }
            );
        },

        ESRI_DARKGRAY: function (layerConfig, map) {
            layerConfig.legend = {label: "ESRI Dark Gray"};
            layerConfig.name = layerConfig.type;
            //this.createPane(layerConfig.name, 1, map);
            var attr = 'HERE, DeLorme, MapmyIndia, OpenStreetMap contributors';
            return L.tileLayer(
                'http://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Base/MapServer/tile/{z}/{y}/{x}',
                {
                    attribution: '&copy; ' + esriLink + ', ' + attr,
                    maxZoom: 16 //,pane: layerConfig.name
                }
            );
        },

        WMS: function (layerConfig, map) {
            GV.Util.log("GV.layerFactory - Creazione Layer WMS: " + layerConfig.name);
            GV.Util.log(layerConfig);

            //this.createPane(layerConfig.name, layerConfig.zIndex, map);

            var options = {
                'tiled': true,
                'transparent': true,
                'TILESORIGIN': '-20037508,-20037508',
                'FORMAT_OPTIONS': 'antialias:text'
            };

            var format = (layerConfig.geomType === 'VECTOR') ? 'image/png8' : (layerConfig.cacheMinZoomLevel) ? 'image/jpeg' : 'image/png',
                minZoom = (layerConfig.minScale) ? GV.Util.getZoomFromScaleDenom(layerConfig.minScale) : 8,
                maxZoom = (layerConfig.maxScale) ? GV.Util.getZoomFromScaleDenom(layerConfig.maxScale) : 20,
                url = layerConfig.wmsParams.url,
                name = layerConfig.name,
                opacity = layerConfig.opacity || 1,
                tileSize = (layerConfig.cacheMinZoomLevel) ? 256 : 1024;

            _.extend(options, {
                'layers': name,
                'format': format,
                'opacity': opacity,
                'minZoom': minZoom,
                'maxZoom': maxZoom,
                'tileSize': tileSize
                //,'pane': layerConfig.name
            });

            var layer = L.tileLayer.wms(url, options);

            layer.setZIndex(layerConfig.zIndex);

            layer.type = "WMS";
            layer.name = name;

            return layer;
        },

        JSON: function (layerConfig, map) {
            var url = layerConfig.url,
                name = layerConfig.name,
                wfsParams = layerConfig.wfsParams,
                classes = layerConfig.classes,
                tooltip = layerConfig.tooltip,
                popup = layerConfig.popup,
                dataType = layerConfig.dataType || 'jsonp';

            var options = {};

            if (classes && classes.length > 0) {
                if (layerConfig.geomSubType === 'POINT') {
                    options.pointToLayer = function (feature, latlng) {
                        var style;
                        _.each(classes, function (cls) {
                            if (cls.filter && cls.filter.key && cls.filter.value) {
                                if (feature.properties[cls.filter.key] == cls.filter.value) {
                                    style = cls.style;
                                }
                            } else {
                                style = cls.style;
                            }
                        });
                        if (style.iconUrl) {
                            var icon = L.icon({
                                iconUrl: style.iconUrl,
                                iconSize: style.iconSize,
                                iconAnchor: style.iconAnchor,
                                popupAnchor: style.popupAnchor
                            });
                            return L.marker(latlng, {icon: icon});
                        } else {
                            return L.circleMarker(latlng, style);
                        }
                    };
                } else {
                    options.style = function (feature) {
                        var style;
                        _.each(classes, function (cls) {
                            if (cls.filter && cls.filter.key && cls.filter.value) {
                                if (feature.properties[cls.filter.key] == cls.filter.value) {
                                    style = cls.style;
                                }
                            } else {
                                style = cls.style;
                            }
                        });
                        return style;
                    };
                }
                options.filter = function(feature, layer) {
                    var visible = false;
                    _.each(classes, function (cls) {
                        if (cls.filter && cls.filter.key && cls.filter.value) {
                            if (feature.properties[cls.filter.key] == cls.filter.value) {
                                visible = true;
                            }
                        }
                    });
                    return visible;
                };
            }

            if (tooltip || popup) {
                options.onEachFeature = function (feature, layer) {
                    if (tooltip) {
                        layer.options.title = GV.Util.template(tooltip, feature.properties);
                    }
                    if (popup) {
                        layer.bindPopup(GV.Util.template(popup, feature.properties));
                    }
                };
            }


            var layer = L.geoJson(null, options);
            layer.name = name;

            layer.setFilter = function(filters) {
                layer.filter = filters;
                if (filters) {
                    layer.eachLayer(function (marker) {
                        var opacity = 0;
                        _.each(filters, function (filter) {
                            if (marker.feature.properties[filter.key] == filter.value) {
                                opacity = layer.config.opacity || 1;
                            }
                        });
                        marker.setOpacity(opacity);
                    });
                } else {
                    layer.eachLayer(function (marker) {
                        var opacity = layer.config.opacity || 1;
                        marker.setOpacity(opacity);
                    });
                }
            };

            if (wfsParams && wfsParams.typeName && wfsParams.url) {
                var parameters = {
                    service: 'WFS',
                    version: '2.0.0',
                    request: 'GetFeature',
                    srsName: 'EPSG:4326',
                    outputFormat: 'text/javascript',
                    format_options: 'callback: getJson',
                    typeName: wfsParams.typeName
                };
                url = wfsParams.url + GV.Util.getParamString(parameters);
                dataType = 'jsonp';
            }

            $.ajax({
                url: url,
                dataType: dataType,
                jsonpCallback: 'getJson',
                success: function (data) {
                    layer.addData(data);
                }
            });


            return layer;

        }

    };

};
/**
 * Created by parodi on 02/08/2016.
 */
/*global GV:false, window:false, jQuery:false, $:false , console:false  , Marionette:false  , Backbone:false  , _:false , L:false  */
GV.Map = L.Map.extend({
    //https://github.com/mapbox/mapbox.js/blob/mb-pages/src/map.js

    // array delle mappe RL caricate
    rlMaps: [],

    layers: [],

    initialExtent: [],

    mapOptions: {
        zoomControl: false
    },

    initialize: function (options) {
        "use strict";

        this.setMapOptions(options);

        L.Map.prototype.initialize.call(this, 'gv-map', _.extend(L.Map.prototype.options, this.mapOptions));

        this.setInitialExtent();

        this.setInfoWms(options);

        this.setLayersInRange();
    },

    setMapOptions: function (options) {
        "use strict";

        if (options.config.application && options.config.application.layout && options.config.application.mapOptions) {
            _.extend(this.mapOptions, options.config.application.mapOptions);
        }
    },

    setInitialExtent: function () {
        "use strict";

        var extent = this.mapOptions.initialExtent || "830036,5402959,1123018,5597635";
        var extArray = extent.split(',');
        var swPoint = L.point(extArray[0], extArray[1]);
        var nePoint = L.point(extArray[2], extArray[3]);
        var swLatLng = L.Projection.SphericalMercator.unproject(swPoint);
        var neLatLng = L.Projection.SphericalMercator.unproject(nePoint);
        this.initialExtent = L.latLngBounds(swLatLng, neLatLng);
        this.fitBounds(this.initialExtent);
    },

    setInfoWms: function (options) {
        "use strict";
        if (this.mapOptions.infoWms) {
            GV.infoWmsManager = new GV.InfoWmsManager();
            GV.infoWmsManager.activate(this, options.config);
        }
    },

    setLayersInRange: function () {
        "use strict";
        this.on('zoom', function () {
            var layers = GV.rlMaps.getAllLayersConfig();
            _.each(layers, function (layer) {
                GV.rlMaps.setLayerAttribute(layer.name, 'inRange', this.layerInRange(layer));
            }, this);
        });
    },

    setLayerVisible: function (layerConfig, visible) {
        "use strict";
        if (visible) {
            this.loadLayers([layerConfig]);
        } else {
            this.removeLayer(this.getLayerByName(layerConfig.name));
        }
    },

    layerInRange: function (layerConfig) {
        "use strict";
        return (this.getScale() < layerConfig.minScale && this.getScale() > layerConfig.maxScale );
    },

    loadControls: function (options) {
        "use strict";
        if (options.config.application && options.config.application.layout && options.config.application.layout.controls) {
            var controls = options.config.application.layout.controls;
            var cntrl;
            this.controls = {};
            _.each(controls, function (control) {
                switch (control.name) {
                    case 'scaleControl':
                        cntrl = L.control.scale({imperial: false}).addTo(this);
                        this.controls[control] = cntrl;
                        break;
                    case 'zoomControl':
                        cntrl = L.control.zoom(control.options).addTo(this);
                        this.controls[control] = cntrl;
                        break;
                    default:
                        break;
                }
            }, this);
        }
    },

    loadBaseLayers: function (baseLayers) {
        "use strict";
        _.each(baseLayers, function (layerConfig) {
            var layer = GV.layerFactory.create(layerConfig, this);
            if (layer && layerConfig.visible) {
                layer.addTo(this);
            }
        }, this);
    },

    loadLayers: function (layers) {
        "use strict";
        _.each(layers, function (layerConfig) {
            if (!this.getLayerByName(layerConfig.name)) {
                var layer = GV.layerFactory.create(layerConfig, this);
                if (layer && layerConfig.visible && !this.getLayerByName(layerConfig.name)) {
                    layer.addTo(this);
                }
            }
        }, this);
    },

    getLayerByName: function (layerName) {
        "use strict";
        var foundLayer = null;
        this.eachLayer(function (layer) {
            if (layer.config && layer.config.name && layer.config.name === layerName) {
                foundLayer = layer;
            }
        });
        return foundLayer;
    },

    getScaleLabel: function () {
        'use strict';
        return GV.Util.getScaleLabelsFromZoom(this._zoom);
    },

    getScale: function () {
        'use strict';
        return GV.Util.getScaleFromZoom(this._zoom);
    }



});
/**
 * Created by parodi on 02/08/2016.
 */

GV.Util = function () {
    "use strict";

    // Public API
    return {

        /**
         *  Function: getUrlParam
         *
         *  Ritorna il valore di un parametro nella queryString
         *
         *  Parameters:
         *  paramName - {String} Nome del parametro
         *
         *  Returns:
         *  {String} Valore del parametro (se non trovato ritorna 0)
         *
         */

        getUrlParam: function (paramName) {
            var results = new RegExp("[\\?&]" + paramName + "=([^&#]*)").exec(window.location.href);
            GV.Util.log("GV.Util.getUrlParam");

            return results ? decodeURIComponent(results[1]) : null;
        },

        /**
         *  Function: getUrlParam
         *
         *  Ritorna il valore di un parametro nella queryString
         *
         *  Parameters:
         *  url - {String} Stringa contenente la URL
         *  paramName - {String} Nome del parametro
         *
         *  Returns:
         *  {String} Valore del parametro (se non trovato ritorna 0)
         *
         */

        getUrlParamFromString: function (url, paramName) {
            var results = new RegExp("[\\?&]" + paramName + "=([^&#]*)").exec(url);
            if (!results) {
                return 0;
            }
            return results[1] || 0;
        },

        /**
         *  Function: log
         *
         *  Scrive un messaggio sulla console
         *
         *  Parameters:
         *  msg - {String} Messaggio da scrivere
         *
         */

        log: function (message, level) {
            var action = "log";

            if (!GV.debug) {
                return;
            }

            switch (level) {
            case 0:
                action = "warn";
                break;
            case 1:
            case 2:
                action = "error";
                break;
            default:
                action = "info";
                break;
            }

            try {
                console[action](message);
            } catch (e) {
            }
        },

        /**
         *  Function: msgBox
         *
         *  Manda un alert di avviso all'utente
         *
         *  Parameters:
         *  msg - {string} Messaggio da scrivere sull'alert
         *
         */

        msgBox: function (msg) {
            window.alert(msg);
        },


        setUnderscoreTemplate: function () {
            if (_) {
                _.templateSettings = {
                    interpolate: /\{\{(.+?)\}\}/g
                };
            }
        },

        /**
         * Function: getJSON
         *
         * Funzione per caricare un oggetto json remoto in maniera sincrona o asincrona.
         *
         * Ritorna un oggetto javascript contentente la deserializzazione del json
         *
         * Parameters:
         * url - {String} Url del file o del servizio
         * urlParams - {Object} Oggetto map contenente i parametri da passare. Vedi http://api.jquery.com/jQuery.ajax/
         * aSync - {Boolean} Flag che indica se effettuare una richiesta asincrona
         * callBack {Function} Funzione da richiamare dopo il caricamento
         * args - {Object/Array} Aregomento o Array degli argumuments opzionali dal passare alla funzione di callback
         *
         * Returns:
         * {object} L'oggetto contenente la deserializzazione del JSON
         *
         */
        ajax: function (options, callback) {
            var defaultOptions = {
                jsonpCallback: 'getJson',
                type: "GET"
            };

            GV.Util.log("GV.Util.ajax");

            $.ajax(_.extend(defaultOptions, options)).done(function (json) {
                try {
                    if (callback) {
                        callback(json);
                    }
                }
                catch (exception) {
                    console.error(exception.message);
                }
            }).fail(function (jqXHR, textStatus, errorThrown) {
                if (jqXHR.statusText !== "OK") {
                    console.error("GV.Util.ajax - Non sono riuscito a caricare la url:\n" + url + "\nErrore: " + jqXHR.status + " - " + textStatus + " - " + errorThrown);
                }
            });

        },

        /**
         * Function: parseXML
         *
         * Funzione per fare il parsing di una stringa xml
         *
         * Ritorna un oggetto doc xml
         *
         * Parameters:
         * xmlString - {String} Stringa xml
         *
         * Returns:
         * {object} Oggetto xmlDoc
         *
         */
        parseXML: function (xmlString) {
            GV.Util.log("GV.Util.parseXML");
            try {
                var xmlDoc = null;
                if (window.DOMParser && window.XSLTProcessor) {
                    var parser = new DOMParser();
                    xmlDoc = parser.parseFromString(xmlString, "text/xml");
                } else {
                    xmlDoc = new ActiveXObject("Msxml2.DOMDocument.3.0");
                    xmlDoc.async = false;
                    xmlDoc.loadXML(xmlString);
                }
                return xmlDoc;
            } catch (exception) {
                throw {
                    name: "xmlTransformation",
                    message: "GV.Util.parseXml: errore parsing xml - " + exception.message,
                    level: 1
                };
            }
        },


        /**
         *
         * Function: isPointInLig
         *
         * Controlla se un punto appartenga al BBOX del territorio ligure
         *
         * Parameters:
         * x - {number} Coordinata X
         * y - {number} Coordinata Y
         *
         * Returns:
         * {boolean} true/false
         *
         */
        isPointInLig: function (x, y) {
            GV.Util.log("GV.Util.isPointInLig");

            if (!x || !y) {
                return false;
            }

            var minX = 7.4, minY = 43.7, maxX = 10.1, maxY = 44.8;

            return (x > minX) && (x < maxX) && (y > minY) && (y < maxY);
        },

        /**
         * Function: toArray
         *
         * Converte Oggetto in Array
         *
         * Parameters:
         * obj - {Object} Oggetto da clonare
         *
         * Returns:
         * {Array} Array
         *
         */
        toArray: function (obj) {
            return Array.prototype.slice.call(obj);
        },

        /**
         * Function: bind
         *
         * Effettua la bind di una funzione ad uno scope
         *
         * Parameters:
         * scope - {Object} Oggetto da utilizzare come scope
         * fn - {Function} Funzione su cui effettuare la bind
         *
         * Returns:
         * {Function} Funzione con bind effettuato
         *
         */
        bind: function (scope, fn) {
            return function () {
                return fn.apply(scope, GV.Util.toArray(arguments));
            };
        },

        /**
         * Function: getArrayElementByAttribute
         *
         * Ritorna un elemento di un array contenente un attributo con un determinato valore
         *
         * Parameters:
         * array - {Array} array su cui cercare l'elemento
         * attributo - {string} Nome dell'attributo dell'elemento
         * value - {string} Valore dell'attributo
         *
         * Returns:
         * {Object} Oggetto
         *
         */
        getArrayElementByAttribute: function (array, attribute, value) {
            if (!array) {
                return null;
            }

            var i,
                len = array.length;

            for (i = 0; i < len; i++) {
                if (array[i][attribute] === value) {
                    return array[i];
                }
            }

            return null;
        },
        /**
         * Function: geoCode
         *
         * Effettua il geocode di un indirizzo utilizzando i servizi google
         *
         * Parameters:
         * address - {string} Indirizzo
         * properties - {Object} oggetto contenente le proprietà da aggiungere all'oggetto properties della feature
         * callback - {function} funzione di callback
         *
         * Returns:
         * {GeoJSON Object}
         *
         */
        geoCode: function (address, properties, callback) {

            var geocoder = new google.maps.Geocoder();

            geocoder.geocode({"address": address}, function (results, status) {
                if (status === google.maps.GeocoderStatus.OK) {

                    var x = results[0].geometry.location.lng();
                    var y = results[0].geometry.location.lat();
                    var feature = {
                        "type": "FeatureCollection",
                        "features": [
                            {
                                "type": "Feature",
                                "geometry": {"type": "Point", "coordinates": [x, y]},
                                "properties": {
                                    "address": address
                                }
                            }
                        ]
                    };
                    if (properties) {
                        for (var p in properties) {
                            if (properties.hasOwnProperty(p)) {
                                feature.features[0].properties[p] = properties[p];
                            }
                        }
                    }
                    callback(feature);
                } else {
                    if (status === google.maps.GeocoderStatus.ZERO_RESULTS) {
                        GV.Util.msgBox("Indirizzo '" + address + "' non trovato");
                    } else {
                        console.error("Errore di geocoding: " + status);
                    }
                }
            });

        },

        getParamString: function (obj, existingUrl, uppercase) {
            var params = [];
            for (var i in obj) {
                params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
            }
            return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
        },

        template: function (str, data) {
            var templateRe = /\{ *([\w_\-]+) *\}/g;
            return str.replace(templateRe, function (str, key) {
                var value = data[key];

                if (value === undefined) {
                    throw new Error('No value provided for variable ' + str);

                } else if (typeof value === 'function') {
                    value = value(data);
                }
                return value;
            });
        },

        getZoomFromScaleDenom: function (scaleDenom) {
            return _.findIndex(GV.Globals.BASE_SCALES, function (scale) {
                return scaleDenom > scale;
            });
        },

        getScaleLabelsFromZoom: function (zoom) {
            return GV.Globals.BASE_SCALE_LABELS[zoom]
        },

        getScaleFromZoom: function (zoom) {
            return GV.Globals.BASE_SCALES[zoom]
        }

    };
}();/**
 * Created by parodi on 19/09/2016.
 */
GV.Buttons.fullscreen = function(btnOptions, map) {
    "use strict";

    return L.control.fullscreen(btnOptions);
};/**
 * Created by parodi on 19/09/2016.
 */
GV.Buttons.geocoder = function(btnOptions, map) {
    "use strict";

    return new L.Control.Geocoder(btnOptions);
};/**
 * Created by parodi on 19/09/2016.
 */
GV.Buttons.locate = function(btnOptions, map) {
    "use strict";

    return new L.Control.Locate(btnOptions);
};/**
 * Created by parodi on 19/09/2016.
 */
GV.Buttons.navbar = function(btnOptions, map) {
    "use strict";

    return L.control.navbar(btnOptions);
};/**
 * Created by parodi on 19/09/2016.
 */
GV.Buttons.print = function(btnOptions, map) {
    "use strict";

    return L.easyButton({
        position: btnOptions.position,
        leafletClasses: true,
        states: [{
            stateName: 'print',
            onClick: function (button, map){
                console.log('print');
            },
            title: 'Zoom alla estensione iniziale',
            icon: 'fa-print'
        }]
    });
};/**
 * Created by parodi on 19/09/2016.
 */
GV.Buttons.zoom = function(btnOptions, map) {
    "use strict";

    return L.control.zoom(btnOptions);
};(function(){

// This is for grouping buttons into a bar
// takes an array of `L.easyButton`s and
// then the usual `.addTo(map)`
    L.Control.EasyBar = L.Control.extend({

        options: {
            position:       'topleft',  // part of leaflet's defaults
            id:             null,       // an id to tag the Bar with
            leafletClasses: true        // use leaflet classes?
        },


        initialize: function(buttons, options){

            if(options){
                L.Util.setOptions( this, options );
            }

            this._buildContainer();
            this._buttons = [];

            for(var i = 0; i < buttons.length; i++){
                buttons[i]._bar = this;
                buttons[i]._container = buttons[i].button;
                this._buttons.push(buttons[i]);
                this.container.appendChild(buttons[i].button);
            }

        },


        _buildContainer: function(){
            this._container = this.container = L.DomUtil.create('div', '');
            this.options.leafletClasses && L.DomUtil.addClass(this.container, 'leaflet-bar easy-button-container leaflet-control');
            this.options.id && (this.container.id = this.options.id);
        },


        enable: function(){
            L.DomUtil.addClass(this.container, 'enabled');
            L.DomUtil.removeClass(this.container, 'disabled');
            this.container.setAttribute('aria-hidden', 'false');
            return this;
        },


        disable: function(){
            L.DomUtil.addClass(this.container, 'disabled');
            L.DomUtil.removeClass(this.container, 'enabled');
            this.container.setAttribute('aria-hidden', 'true');
            return this;
        },


        onAdd: function () {
            return this.container;
        },

        addTo: function (map) {
            this._map = map;

            for(var i = 0; i < this._buttons.length; i++){
                this._buttons[i]._map = map;
            }

            var container = this._container = this.onAdd(map),
                pos = this.getPosition(),
                corner = map._controlCorners[pos];

            L.DomUtil.addClass(container, 'leaflet-control');

            if (pos.indexOf('bottom') !== -1) {
                corner.insertBefore(container, corner.firstChild);
            } else {
                corner.appendChild(container);
            }

            return this;
        }

    });

    L.easyBar = function(){
        var args = [L.Control.EasyBar];
        for(var i = 0; i < arguments.length; i++){
            args.push( arguments[i] );
        }
        return new (Function.prototype.bind.apply(L.Control.EasyBar, args));
    };

// L.EasyButton is the actual buttons
// can be called without being grouped into a bar
    L.Control.EasyButton = L.Control.extend({

        options: {
            position:  'topleft',       // part of leaflet's defaults

            id:        null,            // an id to tag the button with

            type:      'replace',       // [(replace|animate)]
                                        // replace swaps out elements
                                        // animate changes classes with all elements inserted

            states:    [],              // state names look like this
                                        // {
                                        //   stateName: 'untracked',
                                        //   onClick: function(){ handle_nav_manually(); };
                                        //   title: 'click to make inactive',
                                        //   icon: 'fa-circle',    // wrapped with <a>
                                        // }

            leafletClasses:   true,     // use leaflet styles for the button
            tagName:          'button'
        },



        initialize: function(icon, onClick, title, id){

            // clear the states manually
            this.options.states = [];

            // add id to options
            if(id != null){
                this.options.id = id;
            }

            // storage between state functions
            this.storage = {};

            // is the last item an object?
            if( typeof arguments[arguments.length-1] === 'object' ){

                // if so, it should be the options
                L.Util.setOptions( this, arguments[arguments.length-1] );
            }

            // if there aren't any states in options
            // use the early params
            if( this.options.states.length === 0 &&
                typeof icon  === 'string' &&
                typeof onClick === 'function'){

                // turn the options object into a state
                this.options.states.push({
                    icon: icon,
                    onClick: onClick,
                    title: typeof title === 'string' ? title : ''
                });
            }

            // curate and move user's states into
            // the _states for internal use
            this._states = [];

            for(var i = 0; i < this.options.states.length; i++){
                this._states.push( new State(this.options.states[i], this) );
            }

            this._buildButton();

            this._activateState(this._states[0]);

        },

        _buildButton: function(){

            this.button = L.DomUtil.create(this.options.tagName, '');

            // the next three if statements should be collapsed into the options
            // when it's time for breaking changes.
            if (this.tagName === 'button') {
                this.button.type = 'button';
            }

            if (this.options.id ){
                this.button.id = this.options.id;
            }

            if (this.options.leafletClasses){
                L.DomUtil.addClass(this.button, 'leaflet-bar-part leaflet-interactive easy-button gv-bgcolor');
            }

            // don't let double clicks and mousedown get to the map
            L.DomEvent.addListener(this.button, 'dblclick', L.DomEvent.stop);
            L.DomEvent.addListener(this.button, 'mousedown', L.DomEvent.stop);

            // take care of normal clicks
            L.DomEvent.addListener(this.button,'click', function(e){
                L.DomEvent.stop(e);
                this._currentState.onClick(this, this._map ? this._map : null );
                this._map.getContainer().focus();
            }, this);

            // prep the contents of the control
            if(this.options.type == 'replace'){
                this.button.appendChild(this._currentState.icon);
            } else {
                for(var i=0;i<this._states.length;i++){
                    this.button.appendChild(this._states[i].icon);
                }
            }
        },


        _currentState: {
            // placeholder content
            stateName: 'unnamed',
            icon: (function(){ return document.createElement('span'); })()
        },



        _states: null, // populated on init



        state: function(newState){

            // activate by name
            if(typeof newState == 'string'){

                this._activateStateNamed(newState);

                // activate by index
            } else if (typeof newState == 'number'){

                this._activateState(this._states[newState]);
            }

            return this;
        },


        _activateStateNamed: function(stateName){
            for(var i = 0; i < this._states.length; i++){
                if( this._states[i].stateName == stateName ){
                    this._activateState( this._states[i] );
                }
            }
        },

        _activateState: function(newState){

            if( newState === this._currentState ){

                // don't touch the dom if it'll just be the same after
                return;

            } else {

                // swap out elements... if you're into that kind of thing
                if( this.options.type == 'replace' ){
                    this.button.appendChild(newState.icon);
                    this.button.removeChild(this._currentState.icon);
                }

                if( newState.title ){
                    this.button.title = newState.title;
                } else {
                    this.button.removeAttribute('title');
                }

                // update classes for animations
                for(var i=0;i<this._states.length;i++){
                    L.DomUtil.removeClass(this._states[i].icon, this._currentState.stateName + '-active');
                    L.DomUtil.addClass(this._states[i].icon, newState.stateName + '-active');
                }

                // update classes for animations
                L.DomUtil.removeClass(this.button, this._currentState.stateName + '-active');
                L.DomUtil.addClass(this.button, newState.stateName + '-active');

                // update the record
                this._currentState = newState;

            }
        },



        enable: function(){
            L.DomUtil.addClass(this.button, 'enabled');
            L.DomUtil.removeClass(this.button, 'disabled');
            this.button.setAttribute('aria-hidden', 'false');
            return this;
        },



        disable: function(){
            L.DomUtil.addClass(this.button, 'disabled');
            L.DomUtil.removeClass(this.button, 'enabled');
            this.button.setAttribute('aria-hidden', 'true');
            return this;
        },


        removeFrom: function (map) {

            this._container.parentNode.removeChild(this._container);
            this._map = null;

            return this;
        },

        onAdd: function(){
            var containerObj = L.easyBar([this], {
                position: this.options.position,
                leafletClasses: this.options.leafletClasses
            });
            this._container = containerObj.container;
            return this._container;
        }


    });

    L.easyButton = function(/* args will pass automatically */){
        var args = Array.prototype.concat.apply([L.Control.EasyButton],arguments);
        return new (Function.prototype.bind.apply(L.Control.EasyButton, args));
    };

    /*************************
     *
     * util functions
     *
     *************************/

// constructor for states so only curated
// states end up getting called
    function State(template, easyButton){

        this.title = template.title;
        this.stateName = template.stateName ? template.stateName : 'unnamed-state';

        // build the wrapper
        this.icon = L.DomUtil.create('span', '');

        L.DomUtil.addClass(this.icon, 'button-state state-' + this.stateName.replace(/(^\s*|\s*$)/g,''));
        this.icon.innerHTML = buildIcon(template.icon);
        this.onClick = L.Util.bind(template.onClick?template.onClick:function(){}, easyButton);
    }

    function buildIcon(ambiguousIconString) {

        var tmpIcon;

        // does this look like html? (i.e. not a class)
        if( ambiguousIconString.match(/[&;=<>"']/) ){

            // if so, the user should have put in html
            // so move forward as such
            tmpIcon = ambiguousIconString;

            // then it wasn't html, so
            // it's a class list, figure out what kind
        } else {
            ambiguousIconString = ambiguousIconString.replace(/(^\s*|\s*$)/g,'');
            tmpIcon = L.DomUtil.create('span', '');

            if( ambiguousIconString.indexOf('fa-') === 0 ){
                L.DomUtil.addClass(tmpIcon, 'fa '  + ambiguousIconString)
            } else if ( ambiguousIconString.indexOf('glyphicon-') === 0 ) {
                L.DomUtil.addClass(tmpIcon, 'glyphicon ' + ambiguousIconString)
            } else {
                L.DomUtil.addClass(tmpIcon, /*rollwithit*/ ambiguousIconString)
            }

            // make this a string so that it's easy to set innerHTML below
            tmpIcon = tmpIcon.outerHTML;
        }

        return tmpIcon;
    }

})();L.Control.Fullscreen = L.Control.extend({
    options: {
        position: 'topleft',
        title: {
            'false': 'Schermo intero',
            'true': 'Esci da Schermo intero'
        }
    },

    onAdd: function (map) {
        var container = L.DomUtil.create('div', 'leaflet-control-fullscreen leaflet-bar leaflet-control');

        this.link = L.DomUtil.create('a', 'ms ms-max-extent', container);
        this.link.href = '#';

        this._map = map;
        this._map.on('fullscreenchange', this._toggleTitle, this);
        this._toggleTitle();

        L.DomEvent.on(this.link, 'click', this._click, this);

        return container;
    },

    _click: function (e) {
        L.DomEvent.stopPropagation(e);
        L.DomEvent.preventDefault(e);
        this._map.toggleFullscreen(this.options);
    },

    _toggleTitle: function() {
        this.link.title = this.options.title[this._map.isFullscreen()];
    }
});

L.Map.include({
    isFullscreen: function () {
        return this._isFullscreen || false;
    },

    toggleFullscreen: function (options) {
        var container = this.getContainer();
        if (this.isFullscreen()) {
            if (options && options.pseudoFullscreen) {
                this._disablePseudoFullscreen(container);
            } else if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.webkitCancelFullScreen) {
                document.webkitCancelFullScreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            } else {
                this._disablePseudoFullscreen(container);
            }
        } else {
            if (options && options.pseudoFullscreen) {
                this._enablePseudoFullscreen(container);
            } else if (container.requestFullscreen) {
                container.requestFullscreen();
            } else if (container.mozRequestFullScreen) {
                container.mozRequestFullScreen();
            } else if (container.webkitRequestFullscreen) {
                container.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            } else if (container.msRequestFullscreen) {
                container.msRequestFullscreen();
            } else {
                this._enablePseudoFullscreen(container);
            }
        }

    },

    _enablePseudoFullscreen: function (container) {
        L.DomUtil.addClass(container, 'leaflet-pseudo-fullscreen');
        this._setFullscreen(true);
        this.invalidateSize();
        this.fire('fullscreenchange');
    },

    _disablePseudoFullscreen: function (container) {
        L.DomUtil.removeClass(container, 'leaflet-pseudo-fullscreen');
        this._setFullscreen(false);
        this.invalidateSize();
        this.fire('fullscreenchange');
    },

    _setFullscreen: function(fullscreen) {
        this._isFullscreen = fullscreen;
        var container = this.getContainer();
        if (fullscreen) {
            L.DomUtil.addClass(container, 'leaflet-fullscreen-on');
        } else {
            L.DomUtil.removeClass(container, 'leaflet-fullscreen-on');
        }
    },

    _onFullscreenChange: function (e) {
        var fullscreenElement =
            document.fullscreenElement ||
            document.mozFullScreenElement ||
            document.webkitFullscreenElement ||
            document.msFullscreenElement;

        if (fullscreenElement === this.getContainer() && !this._isFullscreen) {
            this._setFullscreen(true);
            this.fire('fullscreenchange');
        } else if (fullscreenElement !== this.getContainer() && this._isFullscreen) {
            this._setFullscreen(false);
            this.fire('fullscreenchange');
        }
    }
});

L.Map.mergeOptions({
    fullscreenControl: false
});

L.Map.addInitHook(function () {
    if (this.options.fullscreenControl) {
        this.fullscreenControl = new L.Control.Fullscreen(this.options.fullscreenControl);
        this.addControl(this.fullscreenControl);
    }

    var fullscreenchange;

    if ('onfullscreenchange' in document) {
        fullscreenchange = 'fullscreenchange';
    } else if ('onmozfullscreenchange' in document) {
        fullscreenchange = 'mozfullscreenchange';
    } else if ('onwebkitfullscreenchange' in document) {
        fullscreenchange = 'webkitfullscreenchange';
    } else if ('onmsfullscreenchange' in document) {
        fullscreenchange = 'MSFullscreenChange';
    }

    if (fullscreenchange) {
        var onFullscreenChange = L.bind(this._onFullscreenChange, this);

        this.whenReady(function () {
            L.DomEvent.on(document, fullscreenchange, onFullscreenChange);
        });

        this.on('unload', function () {
            L.DomEvent.off(document, fullscreenchange, onFullscreenChange);
        });
    }
});

L.control.fullscreen = function (options) {
    return new L.Control.Fullscreen(options);
};
(function (factory) {
    // Packaging/modules magic dance
    var L;
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['leaflet'], factory);
    } else if (typeof module !== 'undefined') {
        // Node/CommonJS
        L = require('leaflet');
        module.exports = factory(L);
    } else {
        // Browser globals
        if (typeof window.L === 'undefined'){
            throw 'Leaflet must be loaded first';
        }
        factory(window.L);
    }
}(function (L) {
    'use strict';
    L.Control.Geocoder = L.Control.extend({
        options: {
            showResultIcons: false,
            collapsed: true,
            expand: 'click',
            position: 'topright',
            placeholder: 'Ricerca Indirizzo...',
            errorMessage: 'Non trovato.'
        },

        _callbackId: 0,

        initialize: function (options) {
            L.Util.setOptions(this, options);
            if (!this.options.geocoder) {
                this.options.geocoder = new L.Control.Geocoder.Nominatim();
            }
        },

        onAdd: function (map) {
            var className = 'leaflet-control-geocoder',
                container = L.DomUtil.create('div', className + ' leaflet-bar'),
                icon = L.DomUtil.create('a', 'ms ms-zoom', container),
                form = this._form = L.DomUtil.create('form', className + '-form', container),
                input;

            icon.innerHTML = '';
            icon.href = 'javascript:void(0);';
            this._map = map;
            this._container = container;
            input = this._input = L.DomUtil.create('input');
            input.type = 'text';
            input.placeholder = this.options.placeholder;

            L.DomEvent.addListener(input, 'keydown', this._keydown, this);
            //L.DomEvent.addListener(input, 'onpaste', this._clearResults, this);
            //L.DomEvent.addListener(input, 'oninput', this._clearResults, this);

            this._errorElement = document.createElement('div');
            this._errorElement.className = className + '-form-no-error';
            this._errorElement.innerHTML = this.options.errorMessage;

            this._alts = L.DomUtil.create('ul', className + '-alternatives leaflet-control-geocoder-alternatives-minimized');

            form.appendChild(input);
            this._container.appendChild(this._errorElement);
            container.appendChild(this._alts);

            L.DomEvent.addListener(form, 'submit', this._geocode, this);

            if (this.options.collapsed) {
                if (this.options.expand === 'click') {
                    L.DomEvent.addListener(icon, 'click', function(e) {
                        // TODO: touch
                        if (e.button === 0 && e.detail !== 2) {
                            this._toggle();
                        }
                    }, this);
                } else {
                    L.DomEvent.addListener(icon, 'mouseover', this._expand, this);
                    L.DomEvent.addListener(icon, 'mouseout', this._collapse, this);
                    this._map.on('movestart', this._collapse, this);
                }
            } else {
                L.DomEvent.addListener(icon, 'click', function(e) {
                    this._geocode(e);
                }, this);
                this._expand();
            }

            L.DomEvent.disableClickPropagation(container);

            return container;
        },

        _geocodeResult: function (results) {
            L.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-throbber');
            if (results.length === 1) {
                this._geocodeResultSelected(results[0]);
            } else if (results.length > 0) {
                this._alts.innerHTML = '';
                this._results = results;
                L.DomUtil.removeClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');
                for (var i = 0; i < results.length; i++) {
                    this._alts.appendChild(this._createAlt(results[i], i));
                }
            } else {
                L.DomUtil.addClass(this._errorElement, 'leaflet-control-geocoder-error');
            }
        },

        markGeocode: function(result) {
            this._map.fitBounds(result.bbox);
            this._map.setZoom(17);

            if (this._geocodeMarker) {
                this._map.removeLayer(this._geocodeMarker);
            }

            this._geocodeMarker = new L.Marker(result.center)
                .bindPopup(result.html || result.name)
                .addTo(this._map)
                .openPopup();

            return this;
        },

        _geocode: function(event) {
            L.DomEvent.preventDefault(event);

            L.DomUtil.addClass(this._container, 'leaflet-control-geocoder-throbber');
            this._clearResults();
            this.options.geocoder.geocode(this._input.value, this._geocodeResult, this);

            return false;
        },

        _geocodeResultSelected: function(result) {
            if (this.options.collapsed) {
                this._collapse();
            } else {
                this._clearResults();
            }
            this.markGeocode(result);
        },

        _toggle: function() {
            if (this._container.className.indexOf('leaflet-control-geocoder-expanded') >= 0) {
                this._collapse();
            } else {
                this._expand();
            }
        },

        _expand: function () {
            L.DomUtil.addClass(this._container, 'leaflet-control-geocoder-expanded');
            this._input.select();
        },

        _collapse: function () {
            this._container.className = this._container.className.replace(' leaflet-control-geocoder-expanded', '');
            L.DomUtil.addClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');
            L.DomUtil.removeClass(this._errorElement, 'leaflet-control-geocoder-error');
        },

        _clearResults: function () {
            L.DomUtil.addClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');
            this._selection = null;
            L.DomUtil.removeClass(this._errorElement, 'leaflet-control-geocoder-error');
        },

        _createAlt: function(result, index) {
            var li = L.DomUtil.create('li', ''),
                a = L.DomUtil.create('a', '', li),
                icon = this.options.showResultIcons && result.icon ? L.DomUtil.create('img', '', a) : null,
                text = result.html ? undefined : document.createTextNode(result.name),
                clickHandler = function clickHandler(e) {
                    L.DomEvent.preventDefault(e);
                    this._geocodeResultSelected(result);
                };

            if (icon) {
                icon.src = result.icon;
            }

            li.setAttribute('data-result-index', index);

            if (result.html) {
                a.innerHTML = result.html;
            } else {
                a.appendChild(text);
            }

            L.DomEvent.addListener(li, 'click', clickHandler, this);

            return li;
        },

        _keydown: function(e) {
            var _this = this,
                select = function select(dir) {
                    if (_this._selection) {
                        L.DomUtil.removeClass(_this._selection, 'leaflet-control-geocoder-selected');
                        _this._selection = _this._selection[dir > 0 ? 'nextSibling' : 'previousSibling'];
                    }
                    if (!_this._selection) {
                        _this._selection = _this._alts[dir > 0 ? 'firstChild' : 'lastChild'];
                    }

                    if (_this._selection) {
                        L.DomUtil.addClass(_this._selection, 'leaflet-control-geocoder-selected');
                    }
                };

            switch (e.keyCode) {
                // Escape
                case 27:
                    if (this.options.collapsed) {
                        this._collapse();
                    }
                    break;
                // Up
                case 38:
                    select(-1);
                    L.DomEvent.preventDefault(e);
                    break;
                // Up
                case 40:
                    select(1);
                    L.DomEvent.preventDefault(e);
                    break;
                // Enter
                case 13:
                    if (this._selection) {
                        var index = parseInt(this._selection.getAttribute('data-result-index'), 10);
                        this._geocodeResultSelected(this._results[index]);
                        this._clearResults();
                        L.DomEvent.preventDefault(e);
                    }
            }
            return true;
        }
    });

    L.Control.geocoder = function(options) {
        return new L.Control.Geocoder(options);
    };

    L.Control.Geocoder.callbackId = 0;

    L.Control.Geocoder.jsonp = function(url, params, callback, context, jsonpParam) {
        var callbackId = '_l_geocoder_' + (L.Control.Geocoder.callbackId++);
        params[jsonpParam || 'callback'] = callbackId;
        window[callbackId] = L.Util.bind(callback, context);
        var script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = url + L.Util.getParamString(params);
        script.id = callbackId;
        document.getElementsByTagName('head')[0].appendChild(script);
    };

    L.Control.Geocoder.getJSON = function(url, params, callback) {
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = function () {
            if (xmlHttp.readyState != 4){
                return;
            }
            if (xmlHttp.status != 200 && xmlHttp.status != 304){
                callback('');
                return;
            }
            callback(JSON.parse(xmlHttp.response));
        };
        xmlHttp.open( "GET", url + L.Util.getParamString(params), true);
        xmlHttp.setRequestHeader("Accept", "application/json");
        xmlHttp.send(null);
    };

    L.Control.Geocoder.template = function (str, data, htmlEscape) {
        return str.replace(/\{ *([\w_]+) *\}/g, function (str, key) {
            var value = data[key];
            if (value === undefined) {
                value = '';
            } else if (typeof value === 'function') {
                value = value(data);
            }
            return L.Control.Geocoder.htmlEscape(value);
        });
    };

    // Adapted from handlebars.js
    // https://github.com/wycats/handlebars.js/
    L.Control.Geocoder.htmlEscape = (function() {
        var badChars = /[&<>"'`]/g;
        var possible = /[&<>"'`]/;
        var escape = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            '\'': '&#x27;',
            '`': '&#x60;'
        };

        function escapeChar(chr) {
            return escape[chr];
        }

        return function(string) {
            if (string == null) {
                return '';
            } else if (!string) {
                return string + '';
            }

            // Force a string conversion as this will be done by the append regardless and
            // the regex test will do this transparently behind the scenes, causing issues if
            // an object's to string has escaped characters in it.
            string = '' + string;

            if (!possible.test(string)) {
                return string;
            }
            return string.replace(badChars, escapeChar);
        };
    })();

    L.Control.Geocoder.Nominatim = L.Class.extend({
        options: {
            serviceUrl: '//nominatim.openstreetmap.org/',
            geocodingQueryParams: {
                countrycodes:'it',
                viewbox: '7.49958,44.791951,10.06312,43.730645',
                bounded: 1
            },
            reverseQueryParams: {},
            htmlTemplate: function(r) {
                var a = r.address,
                    parts = [];

                if (a.road || a.building) {
                    parts.push('{building} {road} {house_number}');
                }

                if (a.city || a.town || a.village) {
                    parts.push('<span class="' + (parts.length > 0 ? 'leaflet-control-geocoder-address-detail' : '') +
                    '">{postcode} {city} {town} {village}</span>');
                }

                if (a.state || a.country) {
                    parts.push('<span class="' + (parts.length > 0 ? 'leaflet-control-geocoder-address-context' : '') +
                    '">{state} {country}</span>');
                }

                var display = r.display_name.replace('Genoa,','').replace('Italia','').replace('Liguria,','')
                return L.Control.Geocoder.template(display.split(',').join('<br/>'), a, true);

                //return L.Control.Geocoder.template(parts.join('<br/>'), a, true);

            }
        },

        initialize: function(options) {
            L.Util.setOptions(this, options);
        },

        geocode: function(query, cb, context) {
            L.Control.Geocoder.jsonp(this.options.serviceUrl + 'search/', L.extend({
                    q: query + ' Liguria',
                    limit: 10,
                    format: 'json',
                    addressdetails: 1
                }, this.options.geocodingQueryParams),
                function(data) {
                    var results = [];
                    for (var i = data.length - 1; i >= 0; i--) {
                        var bbox = data[i].boundingbox;
                        for (var j = 0; j < 4; j++) bbox[j] = parseFloat(bbox[j]);
                        results[i] = {
                            icon: data[i].icon,
                            name: data[i].display_name,
                            html: this.options.htmlTemplate ?
                                this.options.htmlTemplate(data[i])
                                : undefined,
                            bbox: L.latLngBounds([bbox[0], bbox[2]], [bbox[1], bbox[3]]),
                            center: L.latLng(data[i].lat, data[i].lon),
                            properties: data[i]
                        };
                    }
                    cb.call(context, results);
                }, this, 'json_callback');
        },

        reverse: function(location, scale, cb, context) {
            L.Control.Geocoder.jsonp(this.options.serviceUrl + 'reverse/', L.extend({
                lat: location.lat,
                lon: location.lng,
                zoom: Math.round(Math.log(scale / 256) / Math.log(2)),
                addressdetails: 1,
                format: 'json'
            }, this.options.reverseQueryParams), function(data) {
                var result = [],
                    loc;

                if (data && data.lat && data.lon) {
                    loc = L.latLng(data.lat, data.lon);
                    result.push({
                        name: data.display_name,
                        html: this.options.htmlTemplate ?
                            this.options.htmlTemplate(data)
                            : undefined,
                        center: loc,
                        bounds: L.latLngBounds(loc, loc),
                        properties: data
                    });
                }

                cb.call(context, result);
            }, this, 'json_callback');
        }
    });

    L.Control.Geocoder.Google = L.Class.extend({
        options: {
            service_url: 'https://maps.googleapis.com/maps/api/geocode/json'
        },

        initialize: function(key) {
            this._key = key;
        },

        geocode: function(query, cb, context) {
            var params = {
                address: query
            };
            if(this._key && this._key.length)
            {
                params['key'] = this._key
            }

            L.Control.Geocoder.getJSON(this.options.service_url, params, function(data) {
                var results = [],
                    loc,
                    latLng,
                    latLngBounds;
                if (data.results && data.results.length) {
                    for (var i = 0; i <= data.results.length - 1; i++) {
                        loc = data.results[i];
                        latLng = L.latLng(loc.geometry.location);
                        latLngBounds = L.latLngBounds(L.latLng(loc.geometry.viewport.northeast), L.latLng(loc.geometry.viewport.southwest));
                        results[i] = {
                            name: loc.formatted_address,
                            bbox: latLngBounds,
                            center: latLng
                        };
                    }
                }

                cb.call(context, results);
            });
        },

        reverse: function(location, scale, cb, context) {
            var params = {
                latlng: encodeURIComponent(location.lat) + ',' + encodeURIComponent(location.lng)
            };
            if(this._key && this._key.length)
            {
                params['key'] = this._key
            }
            L.Control.Geocoder.getJSON(this.options.service_url, params, function(data) {
                var results = [],
                    loc,
                    latLng,
                    latLngBounds;
                if (data.results && data.results.length) {
                    for (var i = 0; i <= data.results.length - 1; i++) {
                        loc = data.results[i];
                        latLng = L.latLng(loc.geometry.location);
                        latLngBounds = L.latLngBounds(L.latLng(loc.geometry.viewport.northeast), L.latLng(loc.geometry.viewport.southwest));
                        results[i] = {
                            name: loc.formatted_address,
                            bbox: latLngBounds,
                            center: latLng
                        };
                    }
                }

                cb.call(context, results);
            });
        }
    });

    return L.Control.Geocoder;
}));

/*!
 Copyright (c) 2016 Dominik Moritz

 This file is part of the leaflet locate control. It is licensed under the MIT license.
 You can find the project at: https://github.com/domoritz/leaflet-locatecontrol
 */
(function (factory, window) {
    // see https://github.com/Leaflet/Leaflet/blob/master/PLUGIN-GUIDE.md#module-loaders
    // for details on how to structure a leaflet plugin.

    // define an AMD module that relies on 'leaflet'
    if (typeof define === 'function' && define.amd) {
        define(['leaflet'], factory);

        // define a Common JS module that relies on 'leaflet'
    } else if (typeof exports === 'object') {
        if (typeof window !== 'undefined' && window.L) {
            module.exports = factory(L);
        } else {
            module.exports = factory(require('leaflet'));
        }
    }

    // attach your plugin to the global 'L' variable
    if(typeof window !== 'undefined' && window.L){
        window.L.Control.Locate = factory(L);
    }
} (function (L) {
    var LocateControl = L.Control.extend({
        options: {
            /** Position of the control */
            position: 'topleft',
            /** The layer that the user's location should be drawn on. By default creates a new layer. */
            layer: undefined,
            /**
             * Automatically sets the map view (zoom and pan) to the user's location as it updates.
             * While the map is following the user's location, the control is in the `following` state,
             * which changes the style of the control and the circle marker.
             *
             * Possible values:
             *  - false: never updates the map view when location changes.
             *  - 'once': set the view when the location is first determined
             *  - 'always': always updates the map view when location changes.
             *              The map view follows the users location.
             *  - 'untilPan': (default) like 'always', except stops updating the
             *                view if the user has manually panned the map.
             *                The map view follows the users location until she pans.
             */
            setView: 'untilPan',
            /** Keep the current map zoom level when setting the view and only pan. */
            keepCurrentZoomLevel: false,
            /**
             * The user location can be inside and outside the current view when the user clicks on the
             * control that is already active. Both cases can be configures separately.
             * Possible values are:
             *  - 'setView': zoom and pan to the current location
             *  - 'stop': stop locating and remove the location marker
             */
            clickBehavior: {
                /** What should happen if the user clicks on the control while the location is within the current view. */
                inView: 'stop',
                /** What should happen if the user clicks on the control while the location is outside the current view. */
                outOfView: 'setView',
            },
            /** If set, a circle that shows the location accuracy is drawn. */
            drawCircle: true,
            /** If set, the marker at the users' location is drawn. */
            drawMarker: true,
            /** The class to be used to create the marker. For example L.CircleMarker or L.Marker */
            markerClass: L.CircleMarker,
            /** Accuracy circle style properties. */
            circleStyle: {
                color: '#136AEC',
                fillColor: '#136AEC',
                fillOpacity: 0.15,
                weight: 2,
                opacity: 0.5
            },
            /** Inner marker style properties. */
            markerStyle: {
                color: '#136AEC',
                fillColor: '#2A93EE',
                fillOpacity: 0.7,
                weight: 2,
                opacity: 0.9,
                radius: 5
            },
            /**
             * Changes to accuracy circle and inner marker while following.
             * It is only necessary to provide the properties that should change.
             */
            followCircleStyle: {},
            followMarkerStyle: {
                // color: '#FFA500',
                // fillColor: '#FFB000'
            },
            /** The CSS class for the icon. For example fa-location-arrow or fa-map-marker */
            icon: 'fa fa-map-marker',
            iconLoading: 'fa fa-spinner fa-spin',
            /** The element to be created for icons. For example span or i */
            iconElementTag: 'span',
            /** Padding around the accuracy circle. */
            circlePadding: [0, 0],
            /** Use metric units. */
            metric: true,
            /** This event is called in case of any location error that is not a time out error. */
            onLocationError: function(err, control) {
                alert(err.message);
            },
            /**
             * This even is called when the user's location is outside the bounds set on the map.
             * The event is called repeatedly when the location changes.
             */
            onLocationOutsideMapBounds: function(control) {
                control.stop();
                alert(control.options.strings.outsideMapBoundsMsg);
            },
            /** Display a pop-up when the user click on the inner marker. */
            showPopup: true,
            strings: {
                title: "Show me where I am",
                metersUnit: "meters",
                feetUnit: "feet",
                popup: "You are within {distance} {unit} from this point",
                outsideMapBoundsMsg: "You seem located outside the boundaries of the map"
            },
            /** The default options passed to leaflets locate method. */
            locateOptions: {
                maxZoom: Infinity,
                watch: true,  // if you overwrite this, visualization cannot be updated
                setView: false // have to set this to false because we have to
                               // do setView manually
            }
        },

        initialize: function (options) {
            // set default options if nothing is set (merge one step deep)
            for (var i in options) {
                if (typeof this.options[i] === 'object') {
                    L.extend(this.options[i], options[i]);
                } else {
                    this.options[i] = options[i];
                }
            }

            // extend the follow marker style and circle from the normal style
            this.options.followMarkerStyle = L.extend({}, this.options.markerStyle, this.options.followMarkerStyle);
            this.options.followCircleStyle = L.extend({}, this.options.circleStyle, this.options.followCircleStyle);
        },

        /**
         * Add control to map. Returns the container for the control.
         */
        onAdd: function (map) {
            var container = L.DomUtil.create('div',
                'leaflet-control-locate leaflet-bar leaflet-control');

            this._layer = this.options.layer || new L.LayerGroup();
            this._layer.addTo(map);
            this._event = undefined;

            this._link = L.DomUtil.create('a', 'leaflet-bar-part leaflet-bar-part-single', container);
            this._link.href = '#';
            this._link.title = this.options.strings.title;
            this._icon = L.DomUtil.create(this.options.iconElementTag, this.options.icon, this._link);

            L.DomEvent
                .on(this._link, 'click', L.DomEvent.stopPropagation)
                .on(this._link, 'click', L.DomEvent.preventDefault)
                .on(this._link, 'click', this._onClick, this)
                .on(this._link, 'dblclick', L.DomEvent.stopPropagation);

            this._resetVariables();

            this._map.on('unload', this._unload, this);

            return container;
        },

        /**
         * This method is called when the user clicks on the control.
         */
        _onClick: function() {
            this._justClicked = true;
            this._userPanned = false;

            if (this._active && !this._event) {
                // click while requesting
                this.stop();
            } else if (this._active && this._event !== undefined) {
                var behavior = this._map.getBounds().contains(this._event.latlng) ?
                    this.options.clickBehavior.inView : this.options.clickBehavior.outOfView;
                switch (behavior) {
                    case 'setView':
                        this.setView();
                        break;
                    case 'stop':
                        this.stop();
                        break;
                }
            } else {
                this.start();
            }

            this._updateContainerStyle();
        },

        /**
         * Starts the plugin:
         * - activates the engine
         * - draws the marker (if coordinates available)
         */
        start: function() {
            this._activate();

            if (this._event) {
                this._drawMarker(this._map);

                // if we already have a location but the user clicked on the control
                if (this.options.setView) {
                    this.setView();
                }
            }
            this._updateContainerStyle();
        },

        /**
         * Stops the plugin:
         * - deactivates the engine
         * - reinitializes the button
         * - removes the marker
         */
        stop: function() {
            this._deactivate();

            this._cleanClasses();
            this._resetVariables();

            this._removeMarker();
        },

        /**
         * This method launches the location engine.
         * It is called before the marker is updated,
         * event if it does not mean that the event will be ready.
         *
         * Override it if you want to add more functionalities.
         * It should set the this._active to true and do nothing if
         * this._active is true.
         */
        _activate: function() {
            if (!this._active) {
                this._map.locate(this.options.locateOptions);
                this._active = true;

                // bind event listeners
                this._map.on('locationfound', this._onLocationFound, this);
                this._map.on('locationerror', this._onLocationError, this);
                this._map.on('dragstart', this._onDrag, this);
            }
        },

        /**
         * Called to stop the location engine.
         *
         * Override it to shutdown any functionalities you added on start.
         */
        _deactivate: function() {
            this._map.stopLocate();
            this._active = false;

            // unbind event listeners
            this._map.off('locationfound', this._onLocationFound, this);
            this._map.off('locationerror', this._onLocationError, this);
            this._map.off('dragstart', this._onDrag, this);
        },

        /**
         * Zoom (unless we should keep the zoom level) and an to the current view.
         */
        setView: function() {
            if (this._isOutsideMapBounds()) {
                this.options.onLocationOutsideMapBounds(this);
            } else {
                if (this.options.keepCurrentZoomLevel) {
                    this._map.panTo([this._event.latitude, this._event.longitude]);
                } else {
                    this._map.fitBounds(this._event.bounds, {
                        padding: this.options.circlePadding,
                        maxZoom: this.options.locateOptions.maxZoom
                    });
                }
            }
            this._drawMarker();
        },

        /**
         * Draw the marker and accuracy circle on the map.
         *
         * Uses the event retrieved from onLocationFound from the map.
         */
        _drawMarker: function() {
            if (this._event.accuracy === undefined) {
                this._event.accuracy = 0;
            }

            var radius = this._event.accuracy;
            var latlng = this._event.latlng;

            // circle with the radius of the location's accuracy
            if (this.options.drawCircle) {
                var style = this._isFollowing() ? this.options.followCircleStyle : this.options.circleStyle;

                if (!this._circle) {
                    this._circle = L.circle(latlng, radius, style).addTo(this._layer);
                } else {
                    this._circle.setLatLng(latlng).setRadius(radius).setStyle(style);
                }
            }

            var distance, unit;
            if (this.options.metric) {
                distance = radius.toFixed(0);
                unit =  this.options.strings.metersUnit;
            } else {
                distance = (radius * 3.2808399).toFixed(0);
                unit = this.options.strings.feetUnit;
            }

            // small inner marker
            if (this.options.drawMarker) {
                var mStyle = this._isFollowing() ? this.options.followMarkerStyle : this.options.markerStyle;

                if (!this._marker) {
                    this._marker = new this.options.markerClass(latlng, mStyle).addTo(this._layer);
                } else {
                    this._marker.setLatLng(latlng).setStyle(mStyle);
                }
            }

            var t = this.options.strings.popup;
            if (this.options.showPopup && t && this._marker) {
                this._marker
                    .bindPopup(L.Util.template(t, {distance: distance, unit: unit}))
                    ._popup.setLatLng(latlng);
            }
        },

        /**
         * Remove the marker from map.
         */
        _removeMarker: function() {
            this._layer.clearLayers();
            this._marker = undefined;
            this._circle = undefined;
        },

        /**
         * Unload the plugin and all event listeners.
         * Kind of the opposite of onAdd.
         */
        _unload: function() {
            this.stop();
            this._map.off('unload', this._unload, this);
        },

        /**
         * Calls deactivate and dispatches an error.
         */
        _onLocationError: function(err) {
            // ignore time out error if the location is watched
            if (err.code == 3 && this.options.locateOptions.watch) {
                return;
            }

            this.stop();
            this.options.onLocationError(err, this);
        },

        /**
         * Stores the received event and updates the marker.
         */
        _onLocationFound: function(e) {
            // no need to do anything if the location has not changed
            if (this._event &&
                (this._event.latlng.lat === e.latlng.lat &&
                this._event.latlng.lng === e.latlng.lng &&
                this._event.accuracy === e.accuracy)) {
                return;
            }

            if (!this._active) {
                // we may have a stray event
                return;
            }

            this._event = e;

            this._drawMarker();
            this._updateContainerStyle();

            switch (this.options.setView) {
                case 'once':
                    if (this._justClicked) {
                        this.setView();
                    }
                    break;
                case 'untilPan':
                    if (!this._userPanned) {
                        this.setView();
                    }
                    break;
                case 'always':
                    this.setView();
                    break;
                case false:
                    // don't set the view
                    break;
            }

            this._justClicked = false;
        },

        /**
         * When the user drags. Need a separate even so we can bind and unbind even listeners.
         */
        _onDrag: function() {
            // only react to drags once we have a location
            if (this._event) {
                this._userPanned = true;
                this._updateContainerStyle();
                this._drawMarker();
            }
        },

        /**
         * Compute whether the map is following the user location with pan and zoom.
         */
        _isFollowing: function() {
            if (!this._active) {
                return false;
            }

            if (this.options.setView === 'always') {
                return true;
            } else if (this.options.setView === 'untilPan') {
                return !this._userPanned;
            }
        },

        /**
         * Check if location is in map bounds
         */
        _isOutsideMapBounds: function() {
            if (this._event === undefined) {
                return false;
            }
            return this._map.options.maxBounds &&
                !this._map.options.maxBounds.contains(this._event.latlng);
        },

        /**
         * Toggles button class between following and active.
         */
        _updateContainerStyle: function() {
            if (!this._container) {
                return;
            }

            if (this._active && !this._event) {
                // active but don't have a location yet
                this._setClasses('requesting');
            } else if (this._isFollowing()) {
                this._setClasses('following');
            } else if (this._active) {
                this._setClasses('active');
            } else {
                this._cleanClasses();
            }
        },

        /**
         * Sets the CSS classes for the state.
         */
        _setClasses: function(state) {
            if (state == 'requesting') {
                L.DomUtil.removeClasses(this._container, "active following");
                L.DomUtil.addClasses(this._container, "requesting");

                L.DomUtil.removeClasses(this._icon, this.options.icon);
                L.DomUtil.addClasses(this._icon, this.options.iconLoading);
            } else if (state == 'active') {
                L.DomUtil.removeClasses(this._container, "requesting following");
                L.DomUtil.addClasses(this._container, "active");

                L.DomUtil.removeClasses(this._icon, this.options.iconLoading);
                L.DomUtil.addClasses(this._icon, this.options.icon);
            } else if (state == 'following') {
                L.DomUtil.removeClasses(this._container, "requesting");
                L.DomUtil.addClasses(this._container, "active following");

                L.DomUtil.removeClasses(this._icon, this.options.iconLoading);
                L.DomUtil.addClasses(this._icon, this.options.icon);
            }
        },

        /**
         * Removes all classes from button.
         */
        _cleanClasses: function() {
            L.DomUtil.removeClass(this._container, "requesting");
            L.DomUtil.removeClass(this._container, "active");
            L.DomUtil.removeClass(this._container, "following");

            L.DomUtil.removeClasses(this._icon, this.options.iconLoading);
            L.DomUtil.addClasses(this._icon, this.options.icon);
        },

        /**
         * Reinitializes state variables.
         */
        _resetVariables: function() {
            // whether locate is active or not
            this._active = false;

            // true if the control was clicked for the first time
            // we need this so we can pan and zoom once we have the location
            this._justClicked = false;

            // true if the user has panned the map after clicking the control
            this._userPanned = false;
        }
    });

    L.control.locate = function (options) {
        return new L.Control.Locate(options);
    };

    (function(){
        // leaflet.js raises bug when trying to addClass / removeClass multiple classes at once
        // Let's create a wrapper on it which fixes it.
        var LDomUtilApplyClassesMethod = function(method, element, classNames) {
            classNames = classNames.split(' ');
            classNames.forEach(function(className) {
                L.DomUtil[method].call(this, element, className);
            });
        };

        L.DomUtil.addClasses = function(el, names) { LDomUtilApplyClassesMethod('addClass', el, names); };
        L.DomUtil.removeClasses = function(el, names) { LDomUtilApplyClassesMethod('removeClass', el, names); };
    })();

    return LocateControl;
}, window));
(function() {
    L.Control.NavBar = L.Control.extend({
        options: {
            position: 'topleft',
            //center:,
            //zoom :,
            //bbox:, //Alternative to center/zoom for home button, takes precedence if included
            forwardTitle: 'Vai avanti',
            backTitle: 'Via indietro',
            homeTitle: 'Vai alla estensione iniziale'
        },

        onAdd: function(map) {

            // Set options
            if (!this.options.center) {
                this.options.center = map.getCenter();
            }
            if (!this.options.zoom) {
                this.options.zoom = map.getZoom();
            }
            options = this.options;

            // Create toolbar
            var controlName = 'leaflet-control-navbar',
                container = L.DomUtil.create('div', controlName + ' leaflet-bar');

            // Add toolbar buttons
            this._homeButton = this._createButton(options.homeTitle, 'fa fa-home', container, this._goHome);
            this._fwdButton = this._createButton(options.forwardTitle, 'fa fa-caret-right', container, this._goFwd);
            this._backButton = this._createButton(options.backTitle, 'fa fa-caret-left', container, this._goBack);

            // Initialize view history and index
            this._viewHistory = [{center: this.options.center, zoom: this.options.zoom}];
            this._curIndx = 0;
            this._updateDisabled();
            map.once('moveend', function() {this._map.on('moveend', this._updateHistory, this);}, this);
            // Set intial view to home
            map.setView(options.center, options.zoom);

            return container;
        },

        onRemove: function(map) {
            map.off('moveend', this._updateHistory, this);
        },

        _goHome: function() {
            if (this.options.bbox){
                try {
                    this._map.fitBounds(this.options.bbox);
                } catch(err){
                    this._map.setView(this.options.center, this.options.zoom); //Use default if invalid bbox input.
                }
            }
            this._map.setView(this.options.center, this.options.zoom);
        },

        _goBack: function() {
            if (this._curIndx !== 0) {
                this._map.off('moveend', this._updateHistory, this);
                this._map.once('moveend', function() {this._map.on('moveend', this._updateHistory, this);}, this);
                this._curIndx--;
                this._updateDisabled();
                var view = this._viewHistory[this._curIndx];
                this._map.setView(view.center, view.zoom);
            }
        },

        _goFwd: function() {
            if (this._curIndx != this._viewHistory.length - 1) {
                this._map.off('moveend', this._updateHistory, this);
                this._map.once('moveend', function() {this._map.on('moveend', this._updateHistory, this);}, this);
                this._curIndx++;
                this._updateDisabled();
                var view = this._viewHistory[this._curIndx];
                this._map.setView(view.center, view.zoom);
            }
        },

        _createButton: function(title, className, container, fn) {
            // Modified from Leaflet zoom control

            var link = L.DomUtil.create('a', className, container);
            link.href = '#';
            link.title = title;

            L.DomEvent
                .on(link, 'mousedown dblclick', L.DomEvent.stopPropagation)
                .on(link, 'click', L.DomEvent.stop)
                .on(link, 'click', fn, this)
                .on(link, 'click', this._refocusOnMap, this);

            return link;
        },

        _updateHistory: function() {
            var newView = {center: this._map.getCenter(), zoom: this._map.getZoom()};
            var insertIndx = this._curIndx + 1;
            this._viewHistory.splice(insertIndx, this._viewHistory.length - insertIndx, newView);
            this._curIndx++;
            // Update disabled state of toolbar buttons
            this._updateDisabled();
        },

        _setFwdEnabled: function(enabled) {
            var leafletDisabled = 'leaflet-disabled';
            var fwdDisabled = 'leaflet-control-navbar-fwd-disabled';
            if (enabled === true) {
                L.DomUtil.removeClass(this._fwdButton, fwdDisabled);
                L.DomUtil.removeClass(this._fwdButton, leafletDisabled);
            }else {
                L.DomUtil.addClass(this._fwdButton, fwdDisabled);
                L.DomUtil.addClass(this._fwdButton, leafletDisabled);
            }
        },

        _setBackEnabled: function(enabled) {
            var leafletDisabled = 'leaflet-disabled';
            var backDisabled = 'leaflet-control-navbar-back-disabled';
            if (enabled === true) {
                L.DomUtil.removeClass(this._backButton, backDisabled);
                L.DomUtil.removeClass(this._backButton, leafletDisabled);
            }else {
                L.DomUtil.addClass(this._backButton, backDisabled);
                L.DomUtil.addClass(this._backButton, leafletDisabled);
            }
        },

        _updateDisabled: function() {
            if (this._curIndx == (this._viewHistory.length - 1)) {
                this._setFwdEnabled(false);
            }else {
                this._setFwdEnabled(true);
            }

            if (this._curIndx <= 0) {
                this._setBackEnabled(false);
            }else {
                this._setBackEnabled(true);
            }
        }

    });

    L.control.navbar = function(options) {
        return new L.Control.NavBar(options);
    };

})();
/**
 * Created by parodi on 08/08/2016.
 */
/*global GV:false, window:false, jQuery:false, $:false , console:false  , Marionette:false  , Backbone:false  */
GV.Models.RlLayer = Backbone.Model.extend({
/*    defaults: {
        id: 0,
        name: '',
        type: '',
        title: '',
        visible: false,
        visible: '',
        cacheMinZoomLevel: 0,
        minScale: 0,
        maxScale: 0,
        opacity: 0,
        url: '',
        legend_label: '',
    }*/
    initialize: function () {
        if (this.get('minScale') === 0) {
            this.set('minScale', 591657550);
        }
        // calcolo zIndex
        this.set('zIndex', GV.layerFactory.lastZIndex++);
        // calcolo inRange
        if (GV.app.map) {
            this.set('inRange', GV.app.map.layerInRange(this.attributes));
        } else {
            this.set('inRange', true);
        }

    }
});
/**
 * Created by parodi on 08/08/2016.
 */
/*global GV:false, window:false, jQuery:false, $:false , console:false  , Marionette:false  , Backbone:false  */
GV.Models.RlLayers = Backbone.Collection.extend({
    model: GV.Models.RlLayer
});
/**
 * Created by parodi on 08/08/2016.
 */
/*global GV:false, window:false, jQuery:false, $:false , console:false  , Marionette:false  , Backbone:false  */
GV.Models.RlMap = Backbone.Model.extend({
/*    defaults: {
        id: 0,
        name: '',
        extent: '',
        type: '',
        layers: []
    },*/

    urlRoot: '/geoservices/REST/config/map/',

    initialize: function() {
        var layers = new GV.Models.RlLayers(this.get('layers'));

        layers.models = layers.models.reverse();
        this.set('layers', layers);
        this.get('layers').on('change', this.layersChanged, this);
        this.set('type', 'map');
    },

    layersChanged: function(model) {
        // trigger new event.
        this.trigger('layer:change', model);
    },

    parse: function(response) {
        //console.log(response);
        return response.data;
    },

    toJSON: function() {
        var data = Backbone.Model.prototype.toJSON.call(this);
        if (data.layers && data.layers.toJSON) {
            data.layers = data.layers.toJSON();
        }
        return data;
    }
});
/**
 * Created by parodi on 08/08/2016.
 */
GV.Models.RlMaps = Backbone.Collection.extend({
    model: GV.Models.RlMap,
    url: '/geoservices/REST/config/map/',
    add: function(models, options) {
        "use strict";
        // carico mappe in ordine inverso
        var opts = {at: 0};
        if (options) {
            _.extend(opts,options);
        }
        Backbone.Collection.prototype.add.call(this, models, opts);
    },
    getLayerConfig: function (layerName) {
        "use strict";
        var foundLayer = null;
        _.each(this.models, function (map) {
            var layers = map.get('layers').models;
            foundLayer = _.find(layers, function (layer) {
                return layer.attributes.name === layerName;
            });
        });
        if (foundLayer) {
            return foundLayer.attributes;
        }
    },
    getAllLayersConfig: function () {
        "use strict";
        var layers = [];
        _.each(this.models, function (map) {
            _.each(map.get('layers').toJSON(), function (layer) {
                layers.push(layer);
            });
        });
        return layers;
    },
    setLayerAttribute: function (layerName, attribute, value) {
        "use strict";
        var foundLayer = null;
        _.each(this.models, function (map) {
            var layers = map.get('layers').models;
            _.each(layers, function (layer) {
                if (layer.get("name") === layerName) {
                    layer.set(attribute, value);
                }
            });
        });
    }
});

/**
 * Created by parodi on 02/08/2016.
 */
/*global GV:false, window:false, jQuery:false, $:false , console:false  , Marionette:false  , Backbone:false  , _:false , L:false  */
GV.Views.Layout = Marionette.LayoutView.extend({

    template: false,

    controls: [],

    initialize: function(options) {
        "use strict";
        this.el = options.el;

        // creo mappa leaflet/ol3
        this.addMap(options);

        // gestione eventi
        this.listenTo(GV.rlMaps, "add", this.onAddMap);
    },

    render: function (options){
        "use strict";

        var layoutConfig = options.config.application.layout;

        // aggiungo layer di base
        if (this.map && this.map.loadBaseLayers) {
            this.map.loadBaseLayers(options.config.baseLayers);
        }
        // aggiungo controlli
        if (this.map && this.map.loadControls) {
            this.map.loadControls(options);
        }

        // aggiungo toolbar
        if (layoutConfig.toolbar) {
            this.addToolbars(layoutConfig.toolbar);
        }

        // aggiungo legenda
        if (layoutConfig.legend) {
            this.addLegend(layoutConfig.legend);
        }

        return this;
    },

    addMap: function (options) {
        "use strict";

        //$(options.el).append("<div id = 'gv-map'></div>");
        //this.map = GV.map(options);

        var mapView = new GV.Views.MapView();
        $(options.el).append(mapView.el);
        mapView.render(options);
        this.map = mapView.map;

    },


    addToolbars: function (toolbar) {
        "use strict";

        _.each(toolbar, function (tb) {
            var position = tb.position || "topleft";
            _.each(tb.items, function (item) {
                var btnOptions = item.options || {};
                btnOptions.position = position;
                if (GV.Buttons[item.name]) {
                    var control = GV.Buttons[item.name](btnOptions, this.map);
                    control.name = item.name;
                    this.controls.push(control);
                    control.addTo(this.map);
                } else {
                    console.log("Bottone " + item.name + " non esistente")
                }
            }, this);
        }, this);

    },


    addLegend: function (legendConfig) {
        "use strict";

        var container = $('#gv-container');

        container.append("<div id='gv-legend-button'> </div>");
        this.addRegions({
            legendButton: '#gv-legend-button'
        });
        var legendButton = new GV.Views.LegendButton();
        this.legendButton.show(legendButton);

        container.append("<div id='gv-legend' style='display:none;'></div>");
        this.addRegions({
            legend: '#gv-legend'
        });

        var legendLayout = new GV.Views.LegendLayout();
        this.legend.show(legendLayout);

        legendLayout.title.show(new GV.Views.LegendTitle());
        legendLayout.body.show(new GV.Views.LegendBody({ collection: GV.rlMaps }));

        if (legendConfig.show) {
            $('#gv-legend').css({ display: 'block' });
            $('#gv-legend-button').css({ display: 'none' });
        }
    },

    // Funzione richiamata quando si aggiungono mappe alla collection GV.rlMaps
    onAddMap: function(data){
        "use strict";
        var layers = data.attributes.layers.toJSON();
        this.map.loadLayers(layers);
    }

});
GV.Views.LegendItem = Marionette.CompositeView.extend({
    tagName: "ul",
    className: "gv-list-group",
    getTemplate: function () {
        var tpl;
        if (this.model.get("type") === 'map') {
            if (GV.app.config.application.layout.legend.showMapInfoButton) {
                tpl = [
                    '<li class="gv-list-legend-map-item"><%= name %>',
                    '<a class="gv-legend-map-info ms ms-information" title="Scheda metadati" href="/geoservices/REST/metadata/scheda_xml/<%= id %>?style=metadati.xsl" target="_blank"></a>',
                    '</li>'
                ].join('\n');
                return _.template(tpl);
            } else {
                return _.template("<li class='gv-list-legend-map-item'><%= name %></li>");
            }
        } else {
            if (this.model.get("inRange")) {
                if (this.model.get("visible")) {
                    // layer visibili (checked)
                    tpl = [
                        '<li class="gv-list-legend-layer-item">',
                        '<div>',
                        '<img class="gv-legend-layer-icon" src="<%= legend.icon %>" width="24px" height="24px">',
                        '<span class="gv-layer-visibility-span"><input type="checkbox" class="gv-layer-visibility-cb" checked></span>',
                        '<span class="gv-layer-title-span"><%= title %></span>',
                        '</div>',
                        '</li>'
                    ].join('\n');
                    return _.template(tpl);
                } else {
                    // layer non visibili
                    tpl = [
                        '<li class="gv-list-legend-layer-item">',
                        '<img class="gv-legend-layer-icon" src="<%= legend.icon %>" width="24px" height="24px">',
                        '<span class="gv-layer-visibility-span"><input type="checkbox" class="gv-layer-visibility-cb"></span>',
                        '<span class="gv-layer-title-span"><%= title %></span>',
                        '</li>'
                    ].join('\n');
                    return _.template(tpl);
                }
            } else {
                // layer fuori range (disabled)
                tpl = [
                    '<li class="gv-list-legend-layer-disabled-item">',
                    '<img class="gv-legend-layer-icon" src="<%= legend.icon %>" width="24px" height="24px">',
                    '<span class="gv-layer-visibility-span"><input type="checkbox" class="gv-layer-visibility-cb" disabled></span>',
                    '<span class="gv-layer-title-span"><%= title %></span>',
                    '</li>'
                ].join('\n');
                return _.template(tpl);
            }
        }
    },
    initialize: function () {
        this.collection = this.model.get("layers");
        this.listenTo(this.collection, "change:inRange", this.onChangeInRangeLayer);
    },
    onChangeInRangeLayer: function (layer) {
        console.log('GV.Views.LegendItem: onChangeInRangeLayer');
        console.log(layer);
        this.render();
    },
    events: {
        'click .gv-layer-visibility-cb': 'setLayerVisibility'
        //,'click .gv-legend-map-info' : 'showMapInfo'
    },
    setLayerVisibility: function (e) {
        var layerConfig = this.model.attributes;
        if (layerConfig.type !== "map") {
            var checked = e.currentTarget.checked;
            e.stopPropagation();
            this.model.set("visible", checked);
            GV.app.map.setLayerVisible(layerConfig, checked);
        }
    }
});

GV.Views.LegendBody = Marionette.CollectionView.extend({
    tagName: "ul",
    className: "gv-list-group",
    childView: GV.Views.LegendItem
});

GV.Views.LegendTitle = Marionette.ItemView.extend({
//    template: _.template("<div><b>LEGENDA</b><button class='ms ms-plus' type='button'>+</button><button class='gv-close' type='button'>×</button></div>"),
    className: 'gv-legend-title gv-bgcolor',
    events: {
        'click .gv-close': 'hideLegend',
        'click .gv-legend-add': 'addMap'
    },
    hideLegend: function () {
        $('#gv-legend').fadeOut("slow"); //.css({display: 'none'});
        $('#gv-legend-button').css({display: 'block'});
    },
    addMap: function () {
        //TODO finestra aggiungi mappa
/*
     Finestra con tab configurabili
     * Repertorio, con funzioni di ricerca ES
     * Servizi WMS
     * File KLM/GPX
     * Canali Tematici
 */
    },
    getTemplate: function () {
        var tpl = [
            "<div>",
            "<b>LEGENDA</b>",
            "<button class='gv-close' type='button'>×</button>",
            "<button class='gv-legend-add ms ms-layers-add' title='Aggiungi Mappa' type='button'></button>",
            "</div>",
            ""
        ].join('\n');
        return _.template(tpl);
    }
});

GV.Views.LegendLayout = Marionette.LayoutView.extend({
    template: _.template("<div id='gv-legend-title'></div><div id='gv-legend-body'></div>"),
    regions: {
        title: "#gv-legend-title",
        body: "#gv-legend-body"
    }
});

GV.Views.LegendButton = Marionette.ItemView.extend({
    template: _.template("<div  class='gv-legend-button gv-bgcolor gv-legend-button ms ms-layers-o' title='Legenda'></div>"),
    events: {
        'click': 'showLegend'
    },
    showLegend: function () {
        $('#gv-legend').fadeIn("slow"); //.css({display: 'block'});
    }
});
GV.Views.MapView = Backbone.View.extend({
    id: "gv-map",
    render: function (options) {
        'use strict';

        // creazione mappa leaflet
        var mapType = options.mapType || 'leaflet';
        if (mapType === 'leaflet') {
            this.map = new GV.Map(options);
        }

        return this;
    }
});
