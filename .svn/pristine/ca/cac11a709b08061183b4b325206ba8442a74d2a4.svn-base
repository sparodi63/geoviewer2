/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */

window.matchMedia || (window.matchMedia = function() {
    "use strict";

    // For browsers that support matchMedium api such as IE 9 and webkit
    var styleMedia = (window.styleMedia || window.media);

    // For those that don't support matchMedium
    if (!styleMedia) {
        var style       = document.createElement('style'),
            script      = document.getElementsByTagName('script')[0],
            info        = null;

        style.type  = 'text/css';
        style.id    = 'matchmediajs-test';

        script.parentNode.insertBefore(style, script);

        // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
        info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;

        styleMedia = {
            matchMedium: function(media) {
                var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

                // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
                if (style.styleSheet) {
                    style.styleSheet.cssText = text;
                } else {
                    style.textContent = text;
                }

                // Test if media query is true or false
                return info.width === '1px';
            }
        };
    }

    return function(media) {
        return {
            matches: styleMedia.matchMedium(media || 'all'),
            media: media || 'all'
        };
    };
}());


var GV = GV || {};

GV.Models = {};

GV.Buttons = {};

GV.Views = {};

/**
 * Created by parodi on 02/08/2016.
 */

GV.Util = function () {
    "use strict";

    // Public API
    return {

        /**
         *  Function: getUrlParam
         *
         *  Ritorna il valore di un parametro nella queryString
         *
         *  Parameters:
         *  paramName - {String} Nome del parametro
         *
         *  Returns:
         *  {String} Valore del parametro (se non trovato ritorna 0)
         *
         */

        getUrlParam: function (paramName) {
            var results = new RegExp("[\\?&]" + paramName + "=([^&#]*)").exec(window.location.href);
            GV.Util.log("GV.Util.getUrlParam");

            return results ? decodeURIComponent(results[1]) : null;
        },

        /**
         *  Function: getUrlParam
         *
         *  Ritorna il valore di un parametro nella queryString
         *
         *  Parameters:
         *  url - {String} Stringa contenente la URL
         *  paramName - {String} Nome del parametro
         *
         *  Returns:
         *  {String} Valore del parametro (se non trovato ritorna 0)
         *
         */

        getUrlParamFromString: function (url, paramName) {
            var results = new RegExp("[\\?&]" + paramName + "=([^&#]*)").exec(url);
            if (!results) {
                return 0;
            }
            return results[1] || 0;
        },

        /**
         *  Function: log
         *
         *  Scrive un messaggio sulla console
         *
         *  Parameters:
         *  msg - {String} Messaggio da scrivere
         *
         */

        log: function (message, level) {
            var action = "log";

            if (!GV.debug) {
                return;
            }

            switch (level) {
            case 0:
                action = "warn";
                break;
            case 1:
            case 2:
                action = "error";
                break;
            default:
                action = "info";
                break;
            }

            try {
                console[action](message);
            } catch (e) {
            }
        },

        /**
         *  Function: msgBox
         *
         *  Manda un alert di avviso all'utente
         *
         *  Parameters:
         *  msg - {string} Messaggio da scrivere sull'alert
         *
         */
        msgBox: function (msg) {
            window.alert(msg);
        },


        setUnderscoreTemplate: function () {
            if (_) {
                _.templateSettings = {
                    interpolate: /\{\{(.+?)\}\}/g
                };
            }
        },

        /**
         * Function: getXML
         *
         * Funzione per caricare un oggetto xml remoto
         *
         * Ritorna un oggetto xml
         *
         */
        getXML: function (options, callback) {
            var url = options.url,
                data = options.data,
                method = options.method;

            $.ajax({
                url: url,
                dataType: (GV.Util.isBrowserIE()) ? "text" : "xml",
                data: data,
                method: method || 'GET'
            }).done(function (response) {
                try {
                    var xml = response;
                    if (GV.Util.isBrowserIE()) {    // Only for IE
                        var xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                        xmlDoc.async = "false";
                        xmlDoc.loadXML(response);
                        xml = xmlDoc;
                    }
                    callback(xml);
                } catch (exception) {
                    GV.Util.log(exception,2);
                }
            });

        },

        /**
         * Function: parseXML
         *
         * Funzione per fare il parsing di una stringa xml
         *
         * Ritorna un oggetto doc xml
         *
         * Parameters:
         * xmlString - {String} Stringa xml
         *
         * Returns:
         * {object} Oggetto xmlDoc
         *
         */
        parseXML: function (xmlString) {
            GV.Util.log("GV.Util.parseXML");
            try {
                var xmlDoc = null;
                if (window.DOMParser && window.XSLTProcessor) {
                    var parser = new DOMParser();
                    xmlDoc = parser.parseFromString(xmlString, "text/xml");
                } else {
                    xmlDoc = new ActiveXObject("Msxml2.DOMDocument.3.0");
                    xmlDoc.async = false;
                    xmlDoc.loadXML(xmlString);
                }
                return xmlDoc;
            } catch (exception) {
                GV.Util.log("GV.Util.parseXml: errore parsing xml - " + exception.message,1);
            }
        },


        /**
         *
         * Function: isPointInLig
         *
         * Controlla se un punto appartenga al BBOX del territorio ligure
         *
         * Parameters:
         * x - {number} Coordinata X
         * y - {number} Coordinata Y
         *
         * Returns:
         * {boolean} true/false
         *
         */
        isPointInLig: function (x, y) {
            GV.Util.log("GV.Util.isPointInLig");

            if (!x || !y) {
                return false;
            }

            var minX = 7.4, minY = 43.7, maxX = 10.1, maxY = 44.8;

            return (x > minX) && (x < maxX) && (y > minY) && (y < maxY);
        },

        getParamString: function (obj, existingUrl, uppercase) {
            var params = [];
            for (var i in obj) {
                params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
            }
            return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
        },

        template: function (str, data) {
            var templateRe = /\{ *([\w_\-]+) *\}/g;
            return str.replace(templateRe, function (str, key) {
                var value = data[key];

                if (value === undefined) {
                    throw new Error('No value provided for variable ' + str);

                } else if (typeof value === 'function') {
                    value = value(data);
                }
                return value;
            });
        },

        getZoomFromScaleDenom: function (scaleDenom) {
            return _.findIndex(GV.Globals.BASE_SCALES, function (scale) {
                return scaleDenom > scale;
            });
        },

        getScaleLabelsFromZoom: function (zoom) {
            return GV.Globals.BASE_SCALE_LABELS[zoom]
        },

        getScaleFromZoom: function (zoom) {
            return GV.Globals.BASE_SCALES[zoom]
        },

        endsWith: function (str, suffix) {
            return str.indexOf(suffix, str.length - suffix.length) !== -1;
        },

        isTouch: function () {
            return window.matchMedia('(pointer: coarse)').matches;
        },

        isBrowserIE: function () {
            return navigator.userAgent.indexOf("MSIE ") > 0 || navigator.userAgent.indexOf("Trident") > 0 || navigator.userAgent.indexOf("Edge") > 0;
        }
    };
}();

/**
 * Created by parodi on 02/08/2016.
 */




GV.App = Mn.Application.extend({

    region: '#gv-container',

    initialize: function (options) {
        'use strict';
        var self = this;

        // Creo variabile globale GV.app
        GV.app = this;

        GV.debug = options.debug;
        this.proxy = options.proxy || GV.Globals.DEFAULT_PROXY;

        GV.Util.log('GV.App.initialize');
        GV.Util.log(options);

        if (!options) {
            GV.debug = true;
            GV.Util.log('GV.App: Mancano opzioni di configurazione', 2);
            return;
        }

        // inizializzo collection rlMaps
        GV.rlMaps = new GV.Models.RlMaps();

        // inizializzo layerFactory
        GV.layerFactory = new GV.LayerFactory();

        //istanzio Layout Base
        this.layout = new GV.Views.Layout(options);
        this.layout.render(options);
        GV.map = this.map = this.layout.map;

        // Gestione caricamento mappe/livelli da configurazione (options.config.maps)
        if (options.config && options.config.maps && options.config.maps.length > 0) {
            _.each(options.config.maps, function (mapConfig) {
                GV.rlMaps.add(new GV.Models.RlMap(mapConfig));
            });
        }

        // Gestione caricamento mappe RL da servizio
        if (options.idMap) {
            this.addRlMap(options.idMap, options);
        } else {
            if (options && options.callback) {
                options.callback(self);
            }
        }

        // avvio automatico applicazione
        this.start(options);
    },

    addRlMap: function (idMap, options) {
        'use strict';
        var self = this;
        $.ajax({
            url: GV.Globals.RL_MAP_CONFIG_SERVICE + idMap,
            //url: '/geoservices/REST/config/map/' + idMap,
            dataType: 'jsonp'
        }).done(function (response) {
            if (!response.success) {
                GV.Util.log('Errore Caricamento Configurazione Mappa: ' + response.message, 2);
                return;
            }
            var mapConfig = response.data;
            GV.rlMaps.add(new GV.Models.RlMap(mapConfig));
            if (options && options.callback) {
                options.callback(self);
            }
            //gestione extent
            if (mapConfig.extent_3857) {
                self.map.setInitialExtent(mapConfig.extent_3857);
            }
            //gestione titolo
            if (options.setMapTitle && !GV.Globals.SMALL_SCREEN) {
                GV.app.getContainer().append("<div id='gv-title' title='" + mapConfig.name + "'>" + mapConfig.name + "</div>");
            }
            //TODO: gestione find
        }).fail(function (jqXHR, textStatus, errorThrown) {
            GV.Util.log(errorThrown,2);
        });
    },

    getContainer: function() {
        "use strict";
        return this.getRegion().$el;
    }

});

GV.AppVue = Vue.extend({
    template:
        '<div id="gv-container">' +
            '<gv-map ref="gv-map" :options="this.$options" :maps="this.maps"></gv-map>' +
            '<gv-legend ref="gv-legend" :showAddMap="showAddMap" :showInfoMap="showInfoMap" :maps="this.maps"></gv-legend>' +
        '</div>',
    data: function () {
        return GV.rlMaps;
    },
    created: function () {
        //console.log('value ' + this.models[0].id);
        this.options = this.$options;

        console.log('GV.AppVue created ');

        GV.debug = this.options.debug;
        this.proxy = this.options.proxy || GV.Globals.DEFAULT_PROXY;

        // imposto metodo per drag panelli
        this.setDrag();

        // inizializzo layerFactory
        GV.layerFactory = new GV.LayerFactory();


    },
    mounted: function() {
        console.log('GV.AppVue mounted', this.options);

        var self = this;

        this.map = this.$refs['gv-map'].map;

        // aggiungo toolbar
        this.addToolbars(this.options.config.application.layout.toolbar);

        //TODO gestione infoWms
        if (this.options.config.application.mapOptions && this.options.config.application.mapOptions.infoWms && !GV.Util.isTouch()) {
            this.infoWmsManager = new GV.InfoWmsManager();
            this.infoWmsManager.activate(this.map, this.infoWmsManager.request);
//                this.infoWmsList = new Backbone.Collection();
//                GV.app.getContainer().append("<div id='gv-info-wms' class='draggable'></div>");
//                this.addRegion('infowms', '#gv-info-wms');
        }

        // Gestione caricamento mappe/livelli da configurazione (options.config.maps)
        if (this.options.config && this.options.config.maps && this.options.config.maps.length > 0) {
            _.each(this.options.config.maps, function (mapConfig) {
                self.addMap(mapConfig);
            });
        }

        // Gestione caricamento mappe RL da servizio
        if (this.options.idMap) {
            this.addRlMap(this.options);
        } else {
            if (this.options && this.options.callback) {
                this.options.callback(this);
            }
        }
    },
    computed: {
        showAddMap: function() {
            return !this.getButtonOption("legend", "noAddMap");
        },
        showInfoMap: function() {
            return !this.getButtonOption("legend", "noInfoMap");
        }

    },
    methods: {
        getMaps: function () {
            return this.maps;
        },
        addToolbars: function () {
            if (this.options.config.application.layout.toolbar) {
                var toolbar = this.options.config.application.layout.toolbar;
                _.each(toolbar, function (tb) {
                    var position = tb.position || "topleft";
                    _.each(tb.items, function (item) {
                        item.options = item.options || {};
                        item.options.position = item.options.position || position;
                        this.addButton(item);
                    }, this);
                }, this);
            }
        },
        addButton: function (item) {
            if (GV.Buttons[item.name]) {
                var button = GV.Buttons[item.name](item.options, GV.map);
                if (button) {
                    button.name = item.name;
                    button.addTo(GV.map);
                }
            } else {
                GV.Util.log("Bottone " + item.name + " non esistente");
            }
        },
        getButtonOption: function(buttonName, optionName) {
            "use strict";
            var option = null;
            _.each(this.options.config.application.layout.toolbar, function (tb) {
                _.each(tb.items, function (item) {
                    if(item.name === buttonName) {
                        option = item.options[optionName]
                    }
                }, this);
            }, this);
            return option;
        },
        addRlMap: function (options) {
            var self = this,
                idMap = options.idMap;
            $.ajax({
                url: GV.Globals.RL_MAP_CONFIG_SERVICE + idMap,
                //url: '/geoservices/REST/config/map/' + idMap,
                dataType: 'jsonp'
            }).done(function (response) {
                if (!response.success) {
                    GV.Util.log('Errore Caricamento Configurazione Mappa: ' + response.message, 2);
                    return;
                }
                self.addMap(response.data);
                // Gestione callback
                if (options && options.callback) {
                    options.callback(self);
                }
                //TODO gestione titolo
                if (options.setMapTitle && !GV.Globals.SMALL_SCREEN) {
                    //GV.app.getContainer().append("<div id='gv-title' title='" + mapConfig.name + "'>" + mapConfig.name + "</div>");
                }
            }).fail(function (jqXHR, textStatus, errorThrown) {
                GV.Util.log(errorThrown,2);
            });
        },
        addMap: function (mapConfig) {
            // Aggiorno array delle mappe
            GV.rlMaps.addMapConfig(mapConfig);
            // Aggiungo livelli alla mappa
            this.map.loadLayers(mapConfig.layers);
            //gestione extent
            if (mapConfig.extent_3857) {
                this.map.setInitialExtent(mapConfig.extent_3857);
            }
            //TODO: gestione find

        },
        setDrag: function() {
            "use strict";
            interact('.draggable')
                .draggable({
                    // enable inertial throwing
                    inertia: true,
                    // keep the element within the area of it's parent
                    restrict: {
                        restriction: "parent",
                        endOnly: true,
                        elementRect: { top: 0, left: 0, bottom: 1, right: 1 }
                    },
                    // enable autoScroll
                    autoScroll: true,

                    // call this function on every dragmove event
                    onmove: dragMoveListener,
                    // call this function on every dragend event
                    onend: function (event) {
                        var textEl = event.target.querySelector('p');

                        textEl && (textEl.textContent = 'moved a distance of ' + (Math.sqrt(event.dx * event.dx + event.dy * event.dy)|0) + 'px');
                    }
                });

            function dragMoveListener (event) {
                var target = event.target,
                // keep the dragged position in the data-x/data-y attributes
                    x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx,
                    y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

                // translate the element
                target.style.webkitTransform = target.style.transform = 'translate(' + x + 'px, ' + y + 'px)';

                // update the posiion attributes
                target.setAttribute('data-x', x);
                target.setAttribute('data-y', y);
            }

            // this is used later in the resizing and gesture demos
            window.dragMoveListener = dragMoveListener;
        }

    }
});


var GV = GV || {};

GV.Models = {};

GV.Buttons = {};

GV.Views = {};

/**
 * Created by parodi on 02/08/2016.
 */

GV.Globals = {
    DEFAULT_PROXY: '/geoservices/proxy/proxy.jsp?url=',

    RL_MAP_CONFIG_SERVICE: 'http://geoportale.regione.liguria.it/geoservices/REST/config/map/',
    RL_CREATE_SLD_SERVICE: 'http://geoportale.regione.liguria.it/geoservices/REST/config/create_sld/',

    RL_METADATA_URL: '/geoservices/REST/metadata/scheda_xml/',

    MAX_BOUNDS: L.latLngBounds(L.latLng(43.4, 7.3), L.latLng(44.8, 10.5)),

    INFO_WMS_MAX_FEATURES: 10,

    SMALL_SCREEN: window.matchMedia("(max-width: 700px)").matches,
    //SMALL_SCREEN: false,

    BASE_SCALES: [
        591657550.500000,
        295828775.300000,
        147914387.600000,
        73957193.820000,
        36978596.910000,
        18489298.450000,
        9244649.227000,
        4622324.614000,
        2311162.307000,
        1155581.153000,
        577790.576700,
        288895.288400,
        144447.644200,
        72223.822090,
        36111.911040,
        18055.955520,
        9027.977761,
        4513.988880,
        2256.994440,
        1128.497220
    ],

    BASE_SCALE_LABELS: {
        8: '1:1.600.000',
        9: '1:800.000',
        10: '1:400.000',
        11: '1:200.000',
        12: '1:100.000',
        13: '1:50.000',
        14: '1:25.000',
        15: '1:12.500',
        16: '1:6.250',
        17: '1:3.125',
        18: '1:1.560',
        19: '1:800',
        20: '1:400'
    }


};/**
 * Created by parodi on 02/08/2016.
 */


GV.InfoWmsManager = function () {
    'use strict';
    return {
        _requestCount: 0,
        _numRequests: 0,
        _features: [],
        _numPanels: 0,

        activate: function (map, callback) {
            GV.Util.log('GV.app.infoWmsManager.activate');
            this.map = map;
            // Aggiungo layer per evidenziazione
            this.map.loadLayers([{
                name: 'InfoWmsHilite',
                type: 'JSON',
                style: {
                    "color": "#ffcc00",
                    "fillOpacity": 0,
                    "weight": 6,
                    "opacity": 0.6
                },
                pointToLayer: function (feature, latlng) {
                    return L.circleMarker(latlng, {
                        "radius": 8,
                        "color": "#ffcc00",
                        "fillColor": "#ffcc00",
                        "fill": true,
                        "fillOpacity": 0.6,
                        "weight": 6,
                        "opacity": 0.6
                    });
                },
                visible: true
            }]);
            // Attivo evento click
            map.on('click', callback);
        },

        buildWMSOptions: function (url, layers, latlng) {
            var point = GV.app.map.latLngToContainerPoint(latlng, GV.app.map.getZoom()),
                size = GV.app.map.getSize(),
                bounds = GV.app.map.getBounds(),
                sw = GV.app.map.options.crs.project(bounds.getSouthWest()),
                ne = GV.app.map.options.crs.project(bounds.getNorthEast());

            var params = {
                request: 'GetFeatureInfo',
                service: 'WMS',
                crs: 'EPSG:3857',
                styles: '',
                version: '1.1.0',
                format: 'application/json',
                bbox: sw.x + ',' + sw.y + ',' + ne.x + ',' + ne.y,
                height: size.y,
                width: size.x,
                layers: layers,
                query_layers: layers,
                FEATURE_COUNT: 100,
                buffer: 10,
                info_format: 'application/json'
            };

            _.extend(params, {});
            params[params.version === '1.3.0' ? 'i' : 'x'] = point.x;
            params[params.version === '1.3.0' ? 'j' : 'y'] = point.y;

            return GV.app.proxy + url + GV.Util.getParamString(params, url, true);
        },

        handleResponse: function (features) {
            GV.app.infoWmsManager._requestCount++;
            _.each(features, function (feature) {
                var layerName = feature.id.split('.')[0];
                feature.layerName = layerName;
                feature.layer = GV.map.getLayerByName(layerName);
                feature.label = setFeatureLabel(layerName, feature.properties);
                feature.infoOptions = feature.layer.config.infoOptions;

            });
            Array.prototype.push.apply(GV.app.infoWmsManager._features, features);
            if (GV.app.infoWmsManager._requestCount === GV.app.infoWmsManager._numRequests) {
                this.map._container.style.cursor = "default";

                //GV.app.infoWmsList.reset(GV.app.infoWmsManager._features);

                //TODO creare lista
                //GV.app.layout.getRegion('infowms').show(new GV.Views.InfoWmsListLayout());

                if (GV.app.infoWmsManager._features.length === 1) {
                    //$('#gv-info-wms').css({display: 'none'});
                    this.showFeatureInfo(GV.app.infoWmsList.models[0]);
                }


                GV.Util.log('end info request: ' + new Date());
            }

            function setFeatureLabel(layerName, attributes) {
                var infoLabelAttr,
                    infoIdAttr;
                infoLabelAttr = getField(layerName, "infoLabelAttr");
                infoIdAttr = getField(layerName, "infoIdAttr");
                if (infoLabelAttr && attributes[infoLabelAttr]) {
                    return attributes[infoLabelAttr];
                }
                if (infoIdAttr && attributes[infoIdAttr]) {
                    return attributes[infoIdAttr];
                }
                return attributes[getFirstAttribute(attributes)];
            }

            function getField(layerName, fieldName) {
                try {
                    var layerConfig = GV.map.getLayerByName(layerName).config;
                    if (layerConfig && layerConfig.infoOptions && layerConfig.infoOptions[fieldName]) {
                        return layerConfig.infoOptions[fieldName];
                    } else {
                        return null;
                    }
                } catch (exception) {
                    GV.Util.log(exception,2);
                    return null;
                }
            }

            function getFirstAttribute(attributes) {

                for (var i in attributes) {
                    if (attributes.hasOwnProperty(i) && typeof(i) !== "function") {
                        return i;
                    }
                }
                return null;
            }

        },

        showFeatureInfo: function (model) {

            var infoOptions = model.attributes.infoOptions,
                infoUrl = infoOptions.infoUrl;


            if ((infoUrl.substr(infoUrl.length - 4) === ".xsl") || (infoUrl.substr(infoUrl.length - 5) === ".xslt")) {
                // Gestione xsl
                buildAndShowHtml(infoOptions, model.attributes);
            } else {
                // Gestione html/asp
                if (!infoOptions.infoTarget || infoOptions.infoTarget === "panel") {
                    showPanel(infoUrl, null, infoOptions);
                } else {
                    openPopup(infoUrl, null, infoOptions);
                }
            }

            function buildAndShowHtml(infoOptions, data) {
                // costruisco il gml in formato getFeatureInfo Mapserver
                var xmlDoc = buildGml(data);

                var options = {
                    url: "/geoservices/REST/config/xsl_info_service?",
                    data: {
                        xslUrl: infoOptions.infoUrl,
                        ambiente: null,
                        idLayer: data.layerName.replace("L", ""),
                        featureAttributes: data.properties
                    }
                };

                GV.Util.getXML(options, function (xslDoc) {
                    // Aggiungo Nome Layer
                    var el = $(xslDoc).find('td').each(function () {
                        if (this.id === "Titolo") {
                            this.textContent = data.layer.legend.label;
                            this.text = data.layer.legend.label;
                        }
                    });
                    // applico la trasformazione xslt
                    var result = xslTransform(xmlDoc, xslDoc);
                    // levo i caratteri di encoding %0A e %09 dai link
                    result = result.replace(new RegExp('%0A', 'g'), '').replace(new RegExp('%09', 'g'), '').replace(new RegExp('%20', 'g'), '');
                    // visualizzo il risultato
                    if (!infoOptions.infoTarget || infoOptions.infoTarget === "panel") {
                        showPanel(result, null, infoOptions);
                    } else {
                        openPopup(result, null, infoOptions);
                    }
                });

                // costruisce un documento GML in formato getFeatureInfo Mapserver
                function buildGml(feature) {
                    try {
                        var baseXml = "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><msGMLOutput xmlns:gml=\"http://www.opengis.net/gml\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"></msGMLOutput>",
                            xmlDoc = GV.Util.parseXML(baseXml),
                            layerName = feature.layerName + "_layer",
                            layerNode = xmlDoc.createElement(layerName),
                            featureName = feature.layerName + "_feature",
                            featureNode = xmlDoc.createElement(featureName),
                            attributes = feature.properties;

                        for (var key in attributes) {
                            if (attributes.hasOwnProperty(key)) {
                                var text = null;
                                if (attributes[key]) {
                                    text = xmlDoc.createTextNode(attributes[key]);
                                } else {
                                    text = xmlDoc.createTextNode("");
                                }
                                var attrNode = xmlDoc.createElement(key);
                                attrNode.appendChild(text);
                                featureNode.appendChild(attrNode);
                            }
                        }
                        layerNode.appendChild(featureNode);
                        xmlDoc.documentElement.appendChild(layerNode);
                        return xmlDoc;
                    } catch (exception) {
                        GV.Util.log(exception,2);
                    }
                }

                // trasformo xml in html applicando xslt
                function xslTransform(xmlDoc, xslDoc) {
                    try {
                        if (window.XSLTProcessor) {
                            var xsltProcessor = new XSLTProcessor();
                            xsltProcessor.importStylesheet(xslDoc);
                            var transformedDoc = xsltProcessor.transformToDocument(xmlDoc);
                            return (new XMLSerializer()).serializeToString(transformedDoc);
                        } else {
                            return xmlDoc.transformNode(xslDoc);
                        }
                    } catch (exception) {
                        GV.Util.log(exception,2);
                    }
                }


                // apre una popup con un documento html

            }

            function createHtmlPanel(html, configOptions) {
                var width = configOptions.infoWidth || 400,
                    height = configOptions.infoHeight || 300;

                var ind = GV.app.infoWmsManager._numPanels++;

                //TODO creare pannello
                var regionId = 'infowms-html-' + ind;
                GV.app.getContainer().append("<div id='" + regionId + "' class='gv-info-wms-html draggable'></div>");
                GV.app.layout.addRegion(regionId, '#' + regionId).show(new GV.Views.HtmlPanelLayout({
                    regionId: regionId,
                    title: 'Risultato Info',
                    html: html,
                    width: width,
                    height: height,
                    closeAction: function() {
                        GV.app.infoWmsManager.clearHiliteLayer();
                    }
                }));
            }

            // apre una panel div con un documento html
            function showPanel(html, url, configOptions) {
                if (html) {
                    createHtmlPanel(html, configOptions)
                } else {
                    //TODO
                    // 1 - faccio request dell'html
                    // 2 - sostituisco variabile con valore - prerequisito: deve esistere un attributo con nome uguale alla variabile
                    // es: se infoUrl e' http://pippo/pluto.asp?id=${gid} deve esistere attributo "gid" in attributes della feature
                    // var infoUrl = OpenLayers.String.format(configOptions.infoUrl, data.attributes);
                    // 3 - creo il pannello html
                    //createHtmlPanel (html, configOptions)
                }
            }

            function openPopup(html, url, options) {
                var width = options.infoWidth || 400,
                    height = options.infoHeight || 500,
                    popup = window.open(url, null, "status=yes, toolbar=yes, menubar=no, width=" + width + ", height=" + height + ", resizable=yes, scrollbars=yes");

                popup.document.open();
                popup.document.write(html);
                popup.document.close();
                popup.focus();
            }

            var url = this.buildWFSUrl(model.attributes);
            $.ajax({
                url: url,
                dataType: 'json'
            }).done(function (response) {
                var layer = GV.map.getLayerByName('InfoWmsHilite');
                if (response.features && response.features[0] && response.features[0].geometry) {
                    layer.clearLayers();
                    layer.addData(response.features[0].geometry);
                    GV.map.fitBounds(layer.getBounds(), { maxZoom: 15 });
                }
            });
        },

        clearHiliteLayer: function () {
            var layer = GV.map.getLayerByName('InfoWmsHilite');
            layer.clearLayers();
        },

        buildWFSUrl: function (attr) {
            var wsName = "M" + attr.layer.config.idMap;
            var baseUrl = attr.layer.config.wfsParams.url.replace("/" + wsName, "");
            var idAttr = attr.layer.config.infoOptions.infoIdAttr;
            var url = GV.Globals.DEFAULT_PROXY;
            url += baseUrl + "service=WFS&version=2.0.0&request=GetFeature&srsName=EPSG%3A4326&outputFormat=application%2Fjson";
            url += "&typeName=" + wsName + ":" + attr.layer.config.wfsParams.typeName + "&cql_filter=" + idAttr + "=" + attr.properties[idAttr] + "";
            return url;
        },

        showWaiting: function () {
            // Hook to customize AJAX wait animation
            if (!this.map) {
                return;
            }
            this.map._container.style.cursor = "progress";
        },

        request: function (e) {
            GV.Util.log('start info request: ' + new Date());

            GV.app.infoWmsManager._requestCount = 0;
            GV.app.infoWmsManager._numRequests = 0;
            GV.app.infoWmsManager._features = [];

            // Ciclo sulle mappe caricate
            var rlMaps = GV.rlMaps.maps;
            _.each(rlMaps, function (rlMap) {
                var url = null,
                    layersArray = [];

                // Ciclo sui layer caricati sulla mappa leaflet
                _.each(rlMap.layers, function (layerConfig) {
                    if (layerConfig.idMap === rlMap.id && layerConfig.type === 'WMS' && layerConfig.queryable && layerConfig.visible && GV.app.map.layerInRange(layerConfig)) {
                        url = layerConfig.wmsParams.url;
                        layersArray.push(layerConfig.wmsParams.name);
                    }
                });

                var layers = layersArray.join(',');

                if (url && layersArray.length > 0) {
                    var wmsUrl = GV.app.infoWmsManager.buildWMSOptions(url, layers, e.latlng);
                    GV.app.infoWmsManager._numRequests++;
                    this._container.style.cursor = "progress";
                    $.ajax({
                        url: wmsUrl,
                        dataType: 'json'
                    }).done(function (response) {
                        GV.app.infoWmsManager.handleResponse(response.features);
                    });
                }
            }, this);
        }
    };

};

GV.LayerFactory = function () {
    "use strict";
    var esriLink = '<a href="http://www.esri.com/">Esri</a>';

    return {

        lastZIndex: 21,

        createPane: function (name, zIndex, map) {
            var tilePane = map.getPane('tilePane');
            var pane = map.createPane(name, tilePane);
            pane.style.zIndex = zIndex;
            return pane;
        },

        create: function (layerConfig, map) {
            if (this[layerConfig.type]) {
                var layer = this[layerConfig.type](layerConfig, map);
                layer.legend = layerConfig.legend;
                layer.config = layerConfig;
                return layer;
            } else {
                GV.Util.log('Layer di tipo ' + layerConfig.type + ' non gestito',2);
                return null;
            }

        },

        BLANK: function (layerConfig, map) {
            layerConfig.legend = {
                label: "Sfondo Bianco"
            };
            return L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{opacity: 0.0});
        },

        OSM: function (layerConfig, map) {
            layerConfig.legend = {
                label: "OpenStreetMap"
            };
            return L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Map data Â© <a href="http://openstreetmap.org">OpenStreetMap</a> contributors'
            });
        },

        STAMEN_TERRAIN: function (layerConfig, map) {
            layerConfig.legend = {
                label: "Stamen Terrain"
            };
            return L.tileLayer('http://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}.{ext}', {
                attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                subdomains: 'abcd',
                minZoom: 0,
                maxZoom: 18,
                ext: 'png'
            });
        },

        STAMEN_TONER_LIGHT: function (layerConfig, map) {
            layerConfig.legend = {
                label: "Stamen Toner Light"
            };
            return  L.tileLayer('http://stamen-tiles-{s}.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}.{ext}', {
                attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                subdomains: 'abcd',
                minZoom: 0,
                maxZoom: 20,
                ext: 'png'
            });
        },

        CARTODB_POSITRON: function (layerConfig, map) {
            layerConfig.legend = {
                label: "CartoDb Positron"
            };
            return  L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
                subdomains: 'abcd',
                maxZoom: 19
            });
        },

        CARTODB_DARKMATTER: function (layerConfig, map) {
            layerConfig.legend = {
                label: "CartoDb DarkMatter"
            };
            return  L.tileLayer('http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
                subdomains: 'abcd',
                maxZoom: 19
            });
        },

        OPENMAPSURFER_ROADS: function (layerConfig, map) {
            layerConfig.legend = {
                label: "OpenMapSurfer Roads"
            };
            return L.tileLayer('http://korona.geog.uni-heidelberg.de/tiles/roads/x={x}&y={y}&z={z}', {
                maxZoom: 20,
                attribution: 'Imagery from <a href="http://giscience.uni-hd.de/">GIScience Research Group @ University of Heidelberg</a> &mdash; Map data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            });
        },

        MAPBOX_STREETS: function (layerConfig, map) {
            layerConfig.legend = {
                label: "Mapbox Streets"
            };
            return L.tileLayer('http://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1Ijoic3RlZmFub3Bhcm9kaSIsImEiOiJjaXRma2VzeWgwMGVmMnh0bzJzMmVjcGVtIn0.2lTBdEwBI6_2QBzboizE5g', {
                attribution: 'Imagery from <a href="http://mapbox.com/about/maps/">MapBox</a> &mdash; Map data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                subdomains: 'abcd',
                id: 'mapbox.streets',
                accessToken: 'pk.eyJ1Ijoic3RlZmFub3Bhcm9kaSIsImEiOiJjaXRma2VzeWgwMGVmMnh0bzJzMmVjcGVtIn0.2lTBdEwBI6_2QBzboizE5g'
            });
        },

        MAPBOX_SATELLITE: function (layerConfig, map) {
            layerConfig.legend = {
                label: "Mapbox Satellite"
            };
            return L.tileLayer('http://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1Ijoic3RlZmFub3Bhcm9kaSIsImEiOiJjaXRma2VzeWgwMGVmMnh0bzJzMmVjcGVtIn0.2lTBdEwBI6_2QBzboizE5g', {
                attribution: 'Imagery from <a href="http://mapbox.com/about/maps/">MapBox</a> &mdash; Map data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                subdomains: 'abcd',
                id: 'mapbox.satellite',
                accessToken: 'pk.eyJ1Ijoic3RlZmFub3Bhcm9kaSIsImEiOiJjaXRma2VzeWgwMGVmMnh0bzJzMmVjcGVtIn0.2lTBdEwBI6_2QBzboizE5g'
            });
        },

        MAPBOX_OUTDOOR: function (layerConfig, map) {
            layerConfig.legend = {
                label: "Mapox Outdoor"
            };
            return L.tileLayer('http://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1Ijoic3RlZmFub3Bhcm9kaSIsImEiOiJjaXRma2VzeWgwMGVmMnh0bzJzMmVjcGVtIn0.2lTBdEwBI6_2QBzboizE5g', {
                attribution: 'Imagery from <a href="http://mapbox.com/about/maps/">MapBox</a> &mdash; Map data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                subdomains: 'abcd',
                id: 'mapbox.outdoors',
                accessToken: 'pk.eyJ1Ijoic3RlZmFub3Bhcm9kaSIsImEiOiJjaXRma2VzeWgwMGVmMnh0bzJzMmVjcGVtIn0.2lTBdEwBI6_2QBzboizE5g'
            });
        },

        MAPBOX_LIGHT: function (layerConfig, map) {
            layerConfig.legend = {
                label: "Mapox Light"
            };
            return L.tileLayer('http://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1Ijoic3RlZmFub3Bhcm9kaSIsImEiOiJjaXRma2VzeWgwMGVmMnh0bzJzMmVjcGVtIn0.2lTBdEwBI6_2QBzboizE5g', {
                attribution: 'Imagery from <a href="http://mapbox.com/about/maps/">MapBox</a> &mdash; Map data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                subdomains: 'abcd',
                id: 'mapbox.light',
                accessToken: 'pk.eyJ1Ijoic3RlZmFub3Bhcm9kaSIsImEiOiJjaXRma2VzeWgwMGVmMnh0bzJzMmVjcGVtIn0.2lTBdEwBI6_2QBzboizE5g'
            });
        },

        HYDDA: function (layerConfig, map) {
            layerConfig.legend = {
                label: "Hydda"
            };
            return L.tileLayer('http://{s}.tile.openstreetmap.se/hydda/full/{z}/{x}/{y}.png', {
                attribution: 'Tiles courtesy of <a href="http://openstreetmap.se/" target="_blank">OpenStreetMap Sweden</a> &mdash; Map data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            });
        },

        ESRI_IMAGERY: function (layerConfig, map) {
            layerConfig.legend = {label: "ESRI Imagery"};
            layerConfig.name = layerConfig.type;
            //this.createPane(layerConfig.name, 1, map);
            var attr = 'DigitalGlobe, GeoEye, i-cubed, USDA, USGS, AEX, Getmapping, Aerogrid, IGN, IGP, swisstopo, and the GIS User Community';
            return L.tileLayer(
                'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                {
                    attribution: '&copy; ' + esriLink + ', ' + attr,
                    maxZoom: 19 //,pane: layerConfig.name
                }
            );
        },

        ESRI_STREETS: function (layerConfig, map) {
            layerConfig.legend = {label: "ESRI Streets"};
            layerConfig.name = layerConfig.type;
            //this.createPane(layerConfig.name, 1, map);
            var attr = 'USGS, NOAA';
            return L.tileLayer(
                'http://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',
                {
                    attribution: '&copy; ' + esriLink + ', ' + attr,
                    maxZoom: 19 //,pane: layerConfig.name
                }
            );
        },

        ESRI_TOPOGRAPHIC: function (layerConfig, map) {
            layerConfig.legend = {label: "ESRI Topographic"};
            layerConfig.name = layerConfig.type;
            //this.createPane(layerConfig.name, 1, map);
            var attr = 'USGS, NOAA';
            return L.tileLayer(
                'http://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}',
                {
                    attribution: '&copy; ' + esriLink + ', ' + attr,
                    maxZoom: 19 //,pane: layerConfig.name
                }
            );
        },

        ESRI_GRAY: function (layerConfig, map) {
            layerConfig.legend = {label: "ESRI Gray"};
            layerConfig.name = layerConfig.type;
            //this.createPane(layerConfig.name, 1, map);
            var attr = 'HERE, DeLorme, MapmyIndia, OpenStreetMap contributors';
            return L.tileLayer(
                'http://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}',
                {
                    attribution: '&copy; ' + esriLink + ', ' + attr,
                    maxZoom: 16 //,pane: layerConfig.name
                }
            );
        },

        ESRI_DARKGRAY: function (layerConfig, map) {
            layerConfig.legend = {label: "ESRI Dark Gray"};
            layerConfig.name = layerConfig.type;
            //this.createPane(layerConfig.name, 1, map);
            var attr = 'HERE, DeLorme, MapmyIndia, OpenStreetMap contributors';
            return L.tileLayer(
                'http://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Base/MapServer/tile/{z}/{y}/{x}',
                {
                    attribution: '&copy; ' + esriLink + ', ' + attr,
                    maxZoom: 16 //,pane: layerConfig.name
                }
            );
        },

        WMS: function (layerConfig, map) {
            GV.Util.log("GV.layerFactory - Creazione Layer WMS: " + layerConfig.name);
            GV.Util.log(layerConfig);

            //this.createPane(layerConfig.name, layerConfig.zIndex, map);

            var format = (layerConfig.geomType === 'VECTOR') ? 'image/png8' : (layerConfig.cacheMinZoomLevel) ? 'image/jpeg' : 'image/png',
                minZoom = (layerConfig.minScale) ? GV.Util.getZoomFromScaleDenom(layerConfig.minScale) : 8,
                maxZoom = (layerConfig.maxScale) ? GV.Util.getZoomFromScaleDenom(layerConfig.maxScale) : 20,
                url = layerConfig.wmsParams.url,
                name = layerConfig.name,
                opacity = layerConfig.opacity || 1;

            //var tileSize = (layerConfig.cacheMinZoomLevel) ? 256 : 1024;
            if (!layerConfig.flagGeoserver) {
                layerConfig.cacheMinZoomLevel = null;
                format = (layerConfig.geomType === 'VECTOR') ? 'image/png' : 'image/jpeg';
            }

            var options = {
                'transparent': true,
                'FORMAT_OPTIONS': 'antialias:text',
                'layers': name,
                'format': format,
                'opacity': opacity,
                'minZoom': minZoom,
                'maxZoom': maxZoom,
                'bounds': GV.Globals.MAX_BOUNDS
                //,'pane': layerConfig.name
            };

            var layer;
            if (layerConfig.cacheMinZoomLevel) {
                _.extend(options, {
                    'tiled': true,
                    'TILESORIGIN': '-20037508,-20037508',
                    'tileSize': 256
                });
                layer = L.tileLayer.wms(url, options);
            } else {
                _.extend(options, {
                    'tiled': false,
                    'pane': 'tilePane'
                });
                layer = L.nonTiledLayer.wms(url, options);
            }

            layer.setZIndex(layerConfig.zIndex);
            layer.type = "WMS";
            layer.name = name;

            return layer;
        },

        JSON: function (layerConfig, map) {
            var data = layerConfig.data,
                url = layerConfig.url,
                name = layerConfig.name,
                wfsParams = layerConfig.wfsParams,
                esParams = layerConfig.esParams,
                classes = layerConfig.classes,
                style = layerConfig.style,
                pointToLayer = layerConfig.pointToLayer,
                tooltip = layerConfig.tooltip,
                popup = layerConfig.popup,
                dataType = layerConfig.dataType || 'jsonp',
                cluster = layerConfig.cluster,
                clusterLayer = null;

            var options = {};

            if (classes && classes.length > 0) {
                if (layerConfig.geomSubType === 'POINT') {
                    options.pointToLayer = function (feature, latlng) {
                        var style;
                        _.each(classes, function (cls) {
                            if (cls.filter && cls.filter.key && cls.filter.value) {
                                if (feature.properties[cls.filter.key] === cls.filter.value) {
                                    style = cls.style;
                                }
                            } else {
                                style = cls.style;
                            }
                        });
                        if (style.iconUrl) {
                            var icon;
                            switch (style.iconUrl) {
                                case 'default':
                                    icon = L.icon({
                                        iconUrl: "http://geoportale.regione.liguria.it/geoviewer2/images/legend/marker-icon.png",
                                        iconSize: [25, 41],
                                        iconAnchor: [12, 41],
                                        popupAnchor: [0, -41]
                                    });
                                    break;
                                case 'default-small':
                                    icon = L.icon({
                                        iconUrl: "http://geoportale.regione.liguria.it/geoviewer2/images/legend/marker-icon.png",
                                        iconSize: [12, 20],
                                        iconAnchor: [6, 10],
                                        popupAnchor: [0, -20]
                                    });
                                    break;
                                default:
                                    icon = L.icon({
                                        iconUrl: style.iconUrl,
                                        iconSize: style.iconSize,
                                        iconAnchor: style.iconAnchor,
                                        popupAnchor: style.popupAnchor
                                    });
                            }
                            return L.marker(latlng, {icon: icon});
                        } else {
                            return L.circleMarker(latlng, style);
                        }
                    };
                } else {
                    options.style = function (feature) {
                        var style;
                        _.each(classes, function (cls) {
                            if (cls.filter && cls.filter.key && cls.filter.value) {
                                if (feature.properties[cls.filter.key] === cls.filter.value) {
                                    style = cls.style;
                                }
                            } else {
                                style = cls.style;
                            }
                        });
                        return style;
                    };
                }
                options.filter = function(feature, layer) {
                    var visible = false;
                    _.each(classes, function (cls) {
                        if (!cls.filter) {
                            visible = true;
                        } else {
                            if (cls.filter.key && cls.filter.value) {
                                if (feature.properties[cls.filter.key] == cls.filter.value) {
                                    visible = true;
                                }
                            }
                        }
                    });
                    return visible;
                };
            }

            if (style) {
                options.style = style;
            }
            if (pointToLayer) {
                options.pointToLayer = pointToLayer;
            }

            if (tooltip || popup) {
                options.onEachFeature = function (feature, layer) {
                    if (tooltip) {
                        layer.options.title = GV.Util.template(tooltip, feature.properties);
                    }
                    if (popup) {
                        layer.bindPopup(GV.Util.template(popup, feature.properties));
                    }
                };
            }

            var layer = L.geoJson(data, options);
            layer.name = name;

            layer.setFilter = function(filters) {
                layer.filter = filters;
                if (filters) {
                    layer.eachLayer(function (marker) {
                        var opacity = 0;
                        _.each(filters, function (filter) {
                            if (marker.feature.properties[filter.key] == filter.value) {
                                opacity = layer.config.opacity || 1;
                            }
                        });
                        marker.setOpacity(opacity);
                    });
                } else {
                    layer.eachLayer(function (marker) {
                        var opacity = layer.config.opacity || 1;
                        marker.setOpacity(opacity);
                    });
                }
            };

            if (wfsParams && wfsParams.typeName && wfsParams.url) {
                var parameters = {
                    service: 'WFS',
                    version: '2.0.0',
                    request: 'GetFeature',
                    srsName: 'EPSG:4326',
                    outputFormat: 'text/javascript',
                    format_options: 'callback: getJson',
                    typeName: wfsParams.typeName
                };
                url = wfsParams.url + GV.Util.getParamString(parameters);
                dataType = 'jsonp';
            }

            // Gestione livelli puntuali su ElasticSearch
            if (esParams) {
                var parameters = {};
                if (esParams.field) {
                    parameters.q = esParams.field + ':'
                    if (esParams.query) {
                        parameters.q +=  esParams.query;
                    } else {
                        parameters.q += '*';
                    }
                } else {
                    if (esParams.query) {
                        parameters.q =  esParams.query;
                    }
                }
                parameters.pretty = 'true';
                parameters.size = 100000;
                //TODO parametro bbox. https://www.elastic.co/guide/en/elasticsearch/reference/1.4/query-dsl-geo-bounding-box-filter.html

                url = GV.app.proxy + esParams.url + GV.Util.getParamString(parameters);
                dataType = 'json';
            }

            if (url) {
                $.ajax({
                    url: url,
                    dataType: dataType,
                    jsonpCallback: 'getJson',
                    success: function (data) {
                        var geoJson = data;
                        if (esParams) {
                            var geomField = esParams.geomField || 'location';
                            var features = data.hits.hits;
                            geoJson = {
                                "type": "FeatureCollection",
                                "totalFeatures": data.hits.total,
                                "features": [],
                                "crs": {
                                    "type": "name",
                                    "properties": {
                                        "name": "urn:ogc:def:crs:EPSG::4326"
                                    }
                                }
                            };
                            _.each(features, function (feature) {
                                var coords = feature._source[geomField];
                                geoJson.features.push({
                                    "type": "Feature",
                                    "id": feature._id,
                                    "geometry": {"type": "Point", "coordinates": coords},
                                    "geometry_name": "GEOMETRY",
                                    "properties": feature._source
                                });
                            });

                        }
                        layer.addData(geoJson);
                        if (cluster) {
                            clusterLayer.addLayer(layer);
                        }
                    }
                });
            }

            if (cluster) {
                var options = {showCoverageOnHover: false};
                if (cluster.options) {
                    _.extend(options, cluster.options);
                }
                clusterLayer = L.markerClusterGroup(options);
                return clusterLayer;
            }

            return layer;

        }

    };

};
/**
 * Created by parodi on 02/08/2016.
 */
GV.Map = L.Map.extend({
    //https://github.com/mapbox/mapbox.js/blob/mb-pages/src/map.js

    // array delle mappe RL caricate
    rlMaps: [],

    layers: [],

    baseLayers: [],

    initialExtent: [],

    mapOptions: {
        zoomControl: false,
        maxBounds: GV.Globals.MAX_BOUNDS,
        maxBoundsViscosity: 1.0,
        minZoom: 7
    },

    initialize: function (options) {
        "use strict";

        this.setMapOptions(options);

        L.Map.prototype.initialize.call(this, 'gv-map', _.extend(L.Map.prototype.options, this.mapOptions));

        this.setInitialExtent();

        this.setLayersInRange();

        this.setLoading();
    },

    setMapOptions: function (options) {
        "use strict";

        if (options.config.application && options.config.application.layout && options.config.application.mapOptions) {
            _.extend(this.mapOptions, options.config.application.mapOptions);
        }
    },

    setInitialExtent: function () {
        "use strict";

        var extent = this.mapOptions.initialExtent || "830036,5402959,1123018,5597635";
        var extArray = extent.split(',');
        var swPoint = L.point(extArray[0], extArray[1]);
        var nePoint = L.point(extArray[2], extArray[3]);
        var swLatLng = L.Projection.SphericalMercator.unproject(swPoint);
        var neLatLng = L.Projection.SphericalMercator.unproject(nePoint);
        this.initialExtent = L.latLngBounds(swLatLng, neLatLng);
        this.fitBounds(this.initialExtent);
    },

    setLayersInRange: function () {
        "use strict";
        this.on('zoom', function () {
            var layers = GV.rlMaps.getAllLayersConfig();
            _.each(layers, function (layer) {
                GV.rlMaps.setLayerAttribute(layer.name, 'inRange', this.layerInRange(layer));
            }, this);
        });
    },

    setLayerVisible: function (layerConfig, visible) {
        "use strict";
        if (visible) {
            this.loadLayers([layerConfig]);
        } else {
            this.removeLayer(this.getLayerByName(layerConfig.name));
        }
    },

    layerInRange: function (layerConfig) {
        "use strict";
        if (!layerConfig.minScale && !layerConfig.minScale) {
            return true;
        }
        return (this.getScale() < layerConfig.minScale && this.getScale() > layerConfig.maxScale );
    },

    loadControls: function (options) {
        "use strict";
        if (options.config.application && options.config.application.layout && options.config.application.layout.controls) {
            var controls = options.config.application.layout.controls;
            var cntrl;
            this.controls = {};
            _.each(controls, function (control) {
                switch (control.name) {
                    case 'scaleControl':
                        cntrl = L.control.scale({imperial: false}).addTo(this);
                        this.controls[control] = cntrl;
                        break;
                }
            }, this);
        }
    },

    loadBaseLayers: function (baseLayers) {
        "use strict";
        _.each(baseLayers, function (layerConfig) {
            var layer = GV.layerFactory.create(layerConfig, this);
            this.baseLayers[layer.config.legend.label] = layer;
            if (layer && layerConfig.visible) {
                layer.on('loading', function () {
                    this.loading(true, layer);
                }, this);
                layer.on('load', function () {
                    this.loading(false, layer);
                }, this);
                layer.addTo(this);
            }
        }, this);
    },

    loadLayers: function (layers) {
        "use strict";
        _.each(layers, function (layerConfig) {
            if (!this.getLayerByName(layerConfig.name)) {
                var layer = GV.layerFactory.create(layerConfig, this);
                if (layer && layerConfig.visible) {
                    layer.on('loading', function () {
                        this.loading(true, layer);
                    }, this);
                    layer.on('load', function () {
                        this.loading(false, layer);
                    }, this);
                    layer.addTo(this);
                }
            }
        }, this);
    },

    getLayerByName: function (layerName) {
        "use strict";
        var foundLayer = null;
        this.eachLayer(function (layer) {
            if (layer.config && layer.config.name && layer.config.name === layerName) {
                foundLayer = layer;
            }
        });
        return foundLayer;
    },

    getScaleLabel: function () {
        'use strict';
        return GV.Util.getScaleLabelsFromZoom(this._zoom);
    },

    getScale: function () {
        'use strict';
        return GV.Util.getScaleFromZoom(this._zoom);
    },

    setLoading: function () {
        this._spinning = 0;
        this.on('layerremove', function (e) {
            // Clean-up
            if (e.layer.loading) {
                this.loading(false);
            }
            if (typeof e.layer.on != 'function') {
                return;
            }
            e.layer.off('load');
            e.layer.off('loading');
        }, this);
    },

    loading: function (state, layer) {
        if (!!state) {
            if (this._spinning === 0) {
                GV.Util.log('start load: ' + layer.config.name + ' - ' + new Date());
                this._container.style.cursor = "progress";
            }
            this._spinning++;
        }
        else {
            this._spinning--;
            if (this._spinning <= 0) {
                GV.Util.log('end load: ' + layer.config.name + ' - ' + new Date());
                this._container.style.cursor = "default";
            }
        }
    }



});
/*
 Leaflet.markercluster, Provides Beautiful Animated Marker Clustering functionality for Leaflet, a JS library for interactive maps.
 https://github.com/Leaflet/Leaflet.markercluster
 (c) 2012-2013, Dave Leaver, smartrak
 */
(function (window, document, undefined) {/*
 * L.MarkerClusterGroup extends L.FeatureGroup by clustering the markers contained within
 */

    L.MarkerClusterGroup = L.FeatureGroup.extend({

        options: {
            maxClusterRadius: 80, //A cluster will cover at most this many pixels from its center
            iconCreateFunction: null,

            spiderfyOnMaxZoom: true,
            showCoverageOnHover: true,
            zoomToBoundsOnClick: true,
            singleMarkerMode: false,

            disableClusteringAtZoom: null,

            // Setting this to false prevents the removal of any clusters outside of the viewpoint, which
            // is the default behaviour for performance reasons.
            removeOutsideVisibleBounds: true,

            // Set to false to disable all animations (zoom and spiderfy).
            // If false, option animateAddingMarkers below has no effect.
            // If L.DomUtil.TRANSITION is falsy, this option has no effect.
            animate: true,

            //Whether to animate adding markers after adding the MarkerClusterGroup to the map
            // If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.
            animateAddingMarkers: false,

            //Increase to increase the distance away that spiderfied markers appear from the center
            spiderfyDistanceMultiplier: 1,

            // Make it possible to specify a polyline options on a spider leg
            spiderLegPolylineOptions: {weight: 1.5, color: '#222', opacity: 0.5},

            // When bulk adding layers, adds markers in chunks. Means addLayers may not add all the layers in the call, others will be loaded during setTimeouts
            chunkedLoading: false,
            chunkInterval: 200, // process markers for a maximum of ~ n milliseconds (then trigger the chunkProgress callback)
            chunkDelay: 50, // at the end of each interval, give n milliseconds back to system/browser
            chunkProgress: null, // progress callback: function(processed, total, elapsed) (e.g. for a progress indicator)

            //Options to pass to the L.Polygon constructor
            polygonOptions: {}
        },

        initialize: function (options) {
            L.Util.setOptions(this, options);
            if (!this.options.iconCreateFunction) {
                this.options.iconCreateFunction = this._defaultIconCreateFunction;
            }

            this._featureGroup = L.featureGroup();
            this._featureGroup.addEventParent(this);

            this._nonPointGroup = L.featureGroup();
            this._nonPointGroup.addEventParent(this);

            this._inZoomAnimation = 0;
            this._needsClustering = [];
            this._needsRemoving = []; //Markers removed while we aren't on the map need to be kept track of
            //The bounds of the currently shown area (from _getExpandedVisibleBounds) Updated on zoom/move
            this._currentShownBounds = null;

            this._queue = [];

            // Hook the appropriate animation methods.
            var animate = L.DomUtil.TRANSITION && this.options.animate;
            L.extend(this, animate ? this._withAnimation : this._noAnimation);
            // Remember which MarkerCluster class to instantiate (animated or not).
            this._markerCluster = animate ? L.MarkerCluster : L.MarkerClusterNonAnimated;
        },

        addLayer: function (layer) {

            if (layer instanceof L.LayerGroup) {
                return this.addLayers([layer]);
            }

            //Don't cluster non point data
            if (!layer.getLatLng) {
                this._nonPointGroup.addLayer(layer);
                return this;
            }

            if (!this._map) {
                this._needsClustering.push(layer);
                return this;
            }

            if (this.hasLayer(layer)) {
                return this;
            }


            //If we have already clustered we'll need to add this one to a cluster

            if (this._unspiderfy) {
                this._unspiderfy();
            }

            this._addLayer(layer, this._maxZoom);

            // Refresh bounds and weighted positions.
            this._topClusterLevel._recalculateBounds();

            //Work out what is visible
            var visibleLayer = layer,
                currentZoom = this._map.getZoom();
            if (layer.__parent) {
                while (visibleLayer.__parent._zoom >= currentZoom) {
                    visibleLayer = visibleLayer.__parent;
                }
            }

            if (this._currentShownBounds.contains(visibleLayer.getLatLng())) {
                if (this.options.animateAddingMarkers) {
                    this._animationAddLayer(layer, visibleLayer);
                } else {
                    this._animationAddLayerNonAnimated(layer, visibleLayer);
                }
            }
            return this;
        },

        removeLayer: function (layer) {

            if (layer instanceof L.LayerGroup) {
                return this.removeLayers([layer]);
            }

            //Non point layers
            if (!layer.getLatLng) {
                this._nonPointGroup.removeLayer(layer);
                return this;
            }

            if (!this._map) {
                if (!this._arraySplice(this._needsClustering, layer) && this.hasLayer(layer)) {
                    this._needsRemoving.push(layer);
                }
                return this;
            }

            if (!layer.__parent) {
                return this;
            }

            if (this._unspiderfy) {
                this._unspiderfy();
                this._unspiderfyLayer(layer);
            }

            //Remove the marker from clusters
            this._removeLayer(layer, true);

            // Refresh bounds and weighted positions.
            this._topClusterLevel._recalculateBounds();

            layer.off('move', this._childMarkerMoved, this);

            if (this._featureGroup.hasLayer(layer)) {
                this._featureGroup.removeLayer(layer);
                if (layer.clusterShow) {
                    layer.clusterShow();
                }
            }

            return this;
        },

        //Takes an array of markers and adds them in bulk
        addLayers: function (layersArray) {
            if (!L.Util.isArray(layersArray)) {
                return this.addLayer(layersArray);
            }

            var fg = this._featureGroup,
                npg = this._nonPointGroup,
                chunked = this.options.chunkedLoading,
                chunkInterval = this.options.chunkInterval,
                chunkProgress = this.options.chunkProgress,
                l = layersArray.length,
                offset = 0,
                originalArray = true,
                m;

            if (this._map) {
                var started = (new Date()).getTime();
                var process = L.bind(function () {
                    var start = (new Date()).getTime();
                    for (; offset < l; offset++) {
                        if (chunked && offset % 200 === 0) {
                            // every couple hundred markers, instrument the time elapsed since processing started:
                            var elapsed = (new Date()).getTime() - start;
                            if (elapsed > chunkInterval) {
                                break; // been working too hard, time to take a break :-)
                            }
                        }

                        m = layersArray[offset];

                        // Group of layers, append children to layersArray and skip.
                        // Side effects:
                        // - Total increases, so chunkProgress ratio jumps backward.
                        // - Groups are not included in this group, only their non-group child layers (hasLayer).
                        // Changing array length while looping does not affect performance in current browsers:
                        // http://jsperf.com/for-loop-changing-length/6
                        if (m instanceof L.LayerGroup) {
                            if (originalArray) {
                                layersArray = layersArray.slice();
                                originalArray = false;
                            }
                            this._extractNonGroupLayers(m, layersArray);
                            l = layersArray.length;
                            continue;
                        }

                        //Not point data, can't be clustered
                        if (!m.getLatLng) {
                            npg.addLayer(m);
                            continue;
                        }

                        if (this.hasLayer(m)) {
                            continue;
                        }

                        this._addLayer(m, this._maxZoom);

                        //If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will
                        if (m.__parent) {
                            if (m.__parent.getChildCount() === 2) {
                                var markers = m.__parent.getAllChildMarkers(),
                                    otherMarker = markers[0] === m ? markers[1] : markers[0];
                                fg.removeLayer(otherMarker);
                            }
                        }
                    }

                    if (chunkProgress) {
                        // report progress and time elapsed:
                        chunkProgress(offset, l, (new Date()).getTime() - started);
                    }

                    // Completed processing all markers.
                    if (offset === l) {

                        // Refresh bounds and weighted positions.
                        this._topClusterLevel._recalculateBounds();

                        //Update the icons of all those visible clusters that were affected
                        this._featureGroup.eachLayer(function (c) {
                            if (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {
                                c._updateIcon();
                            }
                        });

                        this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);
                    } else {
                        setTimeout(process, this.options.chunkDelay);
                    }
                }, this);

                process();
            } else {
                var needsClustering = this._needsClustering;

                for (; offset < l; offset++) {
                    m = layersArray[offset];

                    // Group of layers, append children to layersArray and skip.
                    if (m instanceof L.LayerGroup) {
                        if (originalArray) {
                            layersArray = layersArray.slice();
                            originalArray = false;
                        }
                        this._extractNonGroupLayers(m, layersArray);
                        l = layersArray.length;
                        continue;
                    }

                    //Not point data, can't be clustered
                    if (!m.getLatLng) {
                        npg.addLayer(m);
                        continue;
                    }

                    if (this.hasLayer(m)) {
                        continue;
                    }

                    needsClustering.push(m);
                }
            }
            return this;
        },

        //Takes an array of markers and removes them in bulk
        removeLayers: function (layersArray) {
            var i, m,
                l = layersArray.length,
                fg = this._featureGroup,
                npg = this._nonPointGroup,
                originalArray = true;

            if (!this._map) {
                for (i = 0; i < l; i++) {
                    m = layersArray[i];

                    // Group of layers, append children to layersArray and skip.
                    if (m instanceof L.LayerGroup) {
                        if (originalArray) {
                            layersArray = layersArray.slice();
                            originalArray = false;
                        }
                        this._extractNonGroupLayers(m, layersArray);
                        l = layersArray.length;
                        continue;
                    }

                    this._arraySplice(this._needsClustering, m);
                    npg.removeLayer(m);
                    if (this.hasLayer(m)) {
                        this._needsRemoving.push(m);
                    }
                }
                return this;
            }

            if (this._unspiderfy) {
                this._unspiderfy();

                // Work on a copy of the array, so that next loop is not affected.
                var layersArray2 = layersArray.slice(),
                    l2 = l;
                for (i = 0; i < l2; i++) {
                    m = layersArray2[i];

                    // Group of layers, append children to layersArray and skip.
                    if (m instanceof L.LayerGroup) {
                        this._extractNonGroupLayers(m, layersArray2);
                        l2 = layersArray2.length;
                        continue;
                    }

                    this._unspiderfyLayer(m);
                }
            }

            for (i = 0; i < l; i++) {
                m = layersArray[i];

                // Group of layers, append children to layersArray and skip.
                if (m instanceof L.LayerGroup) {
                    if (originalArray) {
                        layersArray = layersArray.slice();
                        originalArray = false;
                    }
                    this._extractNonGroupLayers(m, layersArray);
                    l = layersArray.length;
                    continue;
                }

                if (!m.__parent) {
                    npg.removeLayer(m);
                    continue;
                }

                this._removeLayer(m, true, true);

                if (fg.hasLayer(m)) {
                    fg.removeLayer(m);
                    if (m.clusterShow) {
                        m.clusterShow();
                    }
                }
            }

            // Refresh bounds and weighted positions.
            this._topClusterLevel._recalculateBounds();

            //Fix up the clusters and markers on the map
            this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);

            fg.eachLayer(function (c) {
                if (c instanceof L.MarkerCluster) {
                    c._updateIcon();
                }
            });

            return this;
        },

        //Removes all layers from the MarkerClusterGroup
        clearLayers: function () {
            //Need our own special implementation as the LayerGroup one doesn't work for us

            //If we aren't on the map (yet), blow away the markers we know of
            if (!this._map) {
                this._needsClustering = [];
                delete this._gridClusters;
                delete this._gridUnclustered;
            }

            if (this._noanimationUnspiderfy) {
                this._noanimationUnspiderfy();
            }

            //Remove all the visible layers
            this._featureGroup.clearLayers();
            this._nonPointGroup.clearLayers();

            this.eachLayer(function (marker) {
                marker.off('move', this._childMarkerMoved, this);
                delete marker.__parent;
            });

            if (this._map) {
                //Reset _topClusterLevel and the DistanceGrids
                this._generateInitialClusters();
            }

            return this;
        },

        //Override FeatureGroup.getBounds as it doesn't work
        getBounds: function () {
            var bounds = new L.LatLngBounds();

            if (this._topClusterLevel) {
                bounds.extend(this._topClusterLevel._bounds);
            }

            for (var i = this._needsClustering.length - 1; i >= 0; i--) {
                bounds.extend(this._needsClustering[i].getLatLng());
            }

            bounds.extend(this._nonPointGroup.getBounds());

            return bounds;
        },

        //Overrides LayerGroup.eachLayer
        eachLayer: function (method, context) {
            var markers = this._needsClustering.slice(),
                needsRemoving = this._needsRemoving,
                i;

            if (this._topClusterLevel) {
                this._topClusterLevel.getAllChildMarkers(markers);
            }

            for (i = markers.length - 1; i >= 0; i--) {
                if (needsRemoving.indexOf(markers[i]) === -1) {
                    method.call(context, markers[i]);
                }
            }

            this._nonPointGroup.eachLayer(method, context);
        },

        //Overrides LayerGroup.getLayers
        getLayers: function () {
            var layers = [];
            this.eachLayer(function (l) {
                layers.push(l);
            });
            return layers;
        },

        //Overrides LayerGroup.getLayer, WARNING: Really bad performance
        getLayer: function (id) {
            var result = null;

            id = parseInt(id, 10);

            this.eachLayer(function (l) {
                if (L.stamp(l) === id) {
                    result = l;
                }
            });

            return result;
        },

        //Returns true if the given layer is in this MarkerClusterGroup
        hasLayer: function (layer) {
            if (!layer) {
                return false;
            }

            var i, anArray = this._needsClustering;

            for (i = anArray.length - 1; i >= 0; i--) {
                if (anArray[i] === layer) {
                    return true;
                }
            }

            anArray = this._needsRemoving;
            for (i = anArray.length - 1; i >= 0; i--) {
                if (anArray[i] === layer) {
                    return false;
                }
            }

            return !!(layer.__parent && layer.__parent._group === this) || this._nonPointGroup.hasLayer(layer);
        },

        //Zoom down to show the given layer (spiderfying if necessary) then calls the callback
        zoomToShowLayer: function (layer, callback) {

            if (typeof callback !== 'function') {
                callback = function () {
                };
            }

            var showMarker = function () {
                if ((layer._icon || layer.__parent._icon) && !this._inZoomAnimation) {
                    this._map.off('moveend', showMarker, this);
                    this.off('animationend', showMarker, this);

                    if (layer._icon) {
                        callback();
                    } else if (layer.__parent._icon) {
                        this.once('spiderfied', callback, this);
                        layer.__parent.spiderfy();
                    }
                }
            };

            if (layer._icon && this._map.getBounds().contains(layer.getLatLng())) {
                //Layer is visible ond on screen, immediate return
                callback();
            } else if (layer.__parent._zoom < this._map.getZoom()) {
                //Layer should be visible at this zoom level. It must not be on screen so just pan over to it
                this._map.on('moveend', showMarker, this);
                this._map.panTo(layer.getLatLng());
            } else {
                var moveStart = function () {
                    this._map.off('movestart', moveStart, this);
                    moveStart = null;
                };

                this._map.on('movestart', moveStart, this);
                this._map.on('moveend', showMarker, this);
                this.on('animationend', showMarker, this);
                layer.__parent.zoomToBounds();

                if (moveStart) {
                    //Never started moving, must already be there, probably need clustering however
                    showMarker.call(this);
                }
            }
        },

        //Overrides FeatureGroup.onAdd
        onAdd: function (map) {
            this._map = map;
            var i, l, layer;

            if (!isFinite(this._map.getMaxZoom())) {
                throw "Map has no maxZoom specified";
            }

            this._featureGroup.addTo(map);
            this._nonPointGroup.addTo(map);

            if (!this._gridClusters) {
                this._generateInitialClusters();
            }

            this._maxLat = map.options.crs.projection.MAX_LATITUDE;

            for (i = 0, l = this._needsRemoving.length; i < l; i++) {
                layer = this._needsRemoving[i];
                this._removeLayer(layer, true);
            }
            this._needsRemoving = [];

            //Remember the current zoom level and bounds
            this._zoom = this._map.getZoom();
            this._currentShownBounds = this._getExpandedVisibleBounds();

            this._map.on('zoomend', this._zoomEnd, this);
            this._map.on('moveend', this._moveEnd, this);

            if (this._spiderfierOnAdd) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely
                this._spiderfierOnAdd();
            }

            this._bindEvents();

            //Actually add our markers to the map:
            l = this._needsClustering;
            this._needsClustering = [];
            this.addLayers(l);
        },

        //Overrides FeatureGroup.onRemove
        onRemove: function (map) {
            map.off('zoomend', this._zoomEnd, this);
            map.off('moveend', this._moveEnd, this);

            this._unbindEvents();

            //In case we are in a cluster animation
            this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');

            if (this._spiderfierOnRemove) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely
                this._spiderfierOnRemove();
            }

            delete this._maxLat;

            //Clean up all the layers we added to the map
            this._hideCoverage();
            this._featureGroup.remove();
            this._nonPointGroup.remove();

            this._featureGroup.clearLayers();

            this._map = null;
        },

        getVisibleParent: function (marker) {
            var vMarker = marker;
            while (vMarker && !vMarker._icon) {
                vMarker = vMarker.__parent;
            }
            return vMarker || null;
        },

        //Remove the given object from the given array
        _arraySplice: function (anArray, obj) {
            for (var i = anArray.length - 1; i >= 0; i--) {
                if (anArray[i] === obj) {
                    anArray.splice(i, 1);
                    return true;
                }
            }
        },

        /**
         * Removes a marker from all _gridUnclustered zoom levels, starting at the supplied zoom.
         * @param marker to be removed from _gridUnclustered.
         * @param z integer bottom start zoom level (included)
         * @private
         */
        _removeFromGridUnclustered: function (marker, z) {
            var map = this._map,
                gridUnclustered = this._gridUnclustered;

            for (; z >= 0; z--) {
                if (!gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z))) {
                    break;
                }
            }
        },

        _childMarkerMoved: function (e) {
            if (!this._ignoreMove) {
                e.target._latlng = e.oldLatLng;
                this.removeLayer(e.target);

                e.target._latlng = e.latlng;
                this.addLayer(e.target);
            }
        },

        //Internal function for removing a marker from everything.
        //dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)
        _removeLayer: function (marker, removeFromDistanceGrid, dontUpdateMap) {
            var gridClusters = this._gridClusters,
                gridUnclustered = this._gridUnclustered,
                fg = this._featureGroup,
                map = this._map;

            //Remove the marker from distance clusters it might be in
            if (removeFromDistanceGrid) {
                this._removeFromGridUnclustered(marker, this._maxZoom);
            }

            //Work our way up the clusters removing them as we go if required
            var cluster = marker.__parent,
                markers = cluster._markers,
                otherMarker;

            //Remove the marker from the immediate parents marker list
            this._arraySplice(markers, marker);

            while (cluster) {
                cluster._childCount--;
                cluster._boundsNeedUpdate = true;

                if (cluster._zoom < 0) {
                    //Top level, do nothing
                    break;
                } else if (removeFromDistanceGrid && cluster._childCount <= 1) { //Cluster no longer required
                    //We need to push the other marker up to the parent
                    otherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0];

                    //Update distance grid
                    gridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom));
                    gridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom));

                    //Move otherMarker up to parent
                    this._arraySplice(cluster.__parent._childClusters, cluster);
                    cluster.__parent._markers.push(otherMarker);
                    otherMarker.__parent = cluster.__parent;

                    if (cluster._icon) {
                        //Cluster is currently on the map, need to put the marker on the map instead
                        fg.removeLayer(cluster);
                        if (!dontUpdateMap) {
                            fg.addLayer(otherMarker);
                        }
                    }
                } else {
                    if (!dontUpdateMap || !cluster._icon) {
                        cluster._updateIcon();
                    }
                }

                cluster = cluster.__parent;
            }

            delete marker.__parent;
        },

        _isOrIsParent: function (el, oel) {
            while (oel) {
                if (el === oel) {
                    return true;
                }
                oel = oel.parentNode;
            }
            return false;
        },

        //Override L.Evented.fire
        fire: function (type, data, propagate) {
            if (data && data.layer instanceof L.MarkerCluster) {
                //Prevent multiple clustermouseover/off events if the icon is made up of stacked divs (Doesn't work in ie <= 8, no relatedTarget)
                if (data.originalEvent && this._isOrIsParent(data.layer._icon, data.originalEvent.relatedTarget)) {
                    return;
                }
                type = 'cluster' + type;
            }

            L.FeatureGroup.prototype.fire.call(this, type, data, propagate);
        },

        //Override L.Evented.listens
        listens: function (type, propagate) {
            return L.FeatureGroup.prototype.listens.call(this, type, propagate) || L.FeatureGroup.prototype.listens.call(this, 'cluster' + type, propagate);
        },

        //Default functionality
        _defaultIconCreateFunction: function (cluster) {
            var childCount = cluster.getChildCount();

            var c = ' marker-cluster-';
            if (childCount < 10) {
                c += 'small';
            } else if (childCount < 100) {
                c += 'medium';
            } else {
                c += 'large';
            }

            return new L.DivIcon({
                html: '<div><span>' + childCount + '</span></div>',
                className: 'marker-cluster' + c,
                iconSize: new L.Point(40, 40)
            });
        },

        _bindEvents: function () {
            var map = this._map,
                spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
                showCoverageOnHover = this.options.showCoverageOnHover,
                zoomToBoundsOnClick = this.options.zoomToBoundsOnClick;

            //Zoom on cluster click or spiderfy if we are at the lowest level
            if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
                this.on('clusterclick', this._zoomOrSpiderfy, this);
            }

            //Show convex hull (boundary) polygon on mouse over
            if (showCoverageOnHover) {
                this.on('clustermouseover', this._showCoverage, this);
                this.on('clustermouseout', this._hideCoverage, this);
                map.on('zoomend', this._hideCoverage, this);
            }
        },

        _zoomOrSpiderfy: function (e) {
            var cluster = e.layer,
                bottomCluster = cluster;

            while (bottomCluster._childClusters.length === 1) {
                bottomCluster = bottomCluster._childClusters[0];
            }

            if (bottomCluster._zoom === this._maxZoom &&
                bottomCluster._childCount === cluster._childCount &&
                this.options.spiderfyOnMaxZoom) {

                // All child markers are contained in a single cluster from this._maxZoom to this cluster.
                cluster.spiderfy();
            } else if (this.options.zoomToBoundsOnClick) {
                cluster.zoomToBounds();
            }

            // Focus the map again for keyboard users.
            if (e.originalEvent && e.originalEvent.keyCode === 13) {
                this._map._container.focus();
            }
        },

        _showCoverage: function (e) {
            var map = this._map;
            if (this._inZoomAnimation) {
                return;
            }
            if (this._shownPolygon) {
                map.removeLayer(this._shownPolygon);
            }
            if (e.layer.getChildCount() > 2 && e.layer !== this._spiderfied) {
                this._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions);
                map.addLayer(this._shownPolygon);
            }
        },

        _hideCoverage: function () {
            if (this._shownPolygon) {
                this._map.removeLayer(this._shownPolygon);
                this._shownPolygon = null;
            }
        },

        _unbindEvents: function () {
            var spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
                showCoverageOnHover = this.options.showCoverageOnHover,
                zoomToBoundsOnClick = this.options.zoomToBoundsOnClick,
                map = this._map;

            if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
                this.off('clusterclick', this._zoomOrSpiderfy, this);
            }
            if (showCoverageOnHover) {
                this.off('clustermouseover', this._showCoverage, this);
                this.off('clustermouseout', this._hideCoverage, this);
                map.off('zoomend', this._hideCoverage, this);
            }
        },

        _zoomEnd: function () {
            if (!this._map) { //May have been removed from the map by a zoomEnd handler
                return;
            }
            this._mergeSplitClusters();

            this._zoom = Math.round(this._map._zoom);
            this._currentShownBounds = this._getExpandedVisibleBounds();
        },

        _moveEnd: function () {
            if (this._inZoomAnimation) {
                return;
            }

            var newBounds = this._getExpandedVisibleBounds();

            this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, newBounds);
            this._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), newBounds);

            this._currentShownBounds = newBounds;
            return;
        },

        _generateInitialClusters: function () {
            var maxZoom = this._map.getMaxZoom(),
                radius = this.options.maxClusterRadius,
                radiusFn = radius;

            //If we just set maxClusterRadius to a single number, we need to create
            //a simple function to return that number. Otherwise, we just have to
            //use the function we've passed in.
            if (typeof radius !== "function") {
                radiusFn = function () {
                    return radius;
                };
            }

            if (this.options.disableClusteringAtZoom) {
                maxZoom = this.options.disableClusteringAtZoom - 1;
            }
            this._maxZoom = maxZoom;
            this._gridClusters = {};
            this._gridUnclustered = {};

            //Set up DistanceGrids for each zoom
            for (var zoom = maxZoom; zoom >= 0; zoom--) {
                this._gridClusters[zoom] = new L.DistanceGrid(radiusFn(zoom));
                this._gridUnclustered[zoom] = new L.DistanceGrid(radiusFn(zoom));
            }

            // Instantiate the appropriate L.MarkerCluster class (animated or not).
            this._topClusterLevel = new this._markerCluster(this, -1);
        },

        //Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)
        _addLayer: function (layer, zoom) {
            var gridClusters = this._gridClusters,
                gridUnclustered = this._gridUnclustered,
                markerPoint, z;

            if (this.options.singleMarkerMode) {
                this._overrideMarkerIcon(layer);
            }

            layer.on('move', this._childMarkerMoved, this);

            //Find the lowest zoom level to slot this one in
            for (; zoom >= 0; zoom--) {
                markerPoint = this._map.project(layer.getLatLng(), zoom); // calculate pixel position

                //Try find a cluster close by
                var closest = gridClusters[zoom].getNearObject(markerPoint);
                if (closest) {
                    closest._addChild(layer);
                    layer.__parent = closest;
                    return;
                }

                //Try find a marker close by to form a new cluster with
                closest = gridUnclustered[zoom].getNearObject(markerPoint);
                if (closest) {
                    var parent = closest.__parent;
                    if (parent) {
                        this._removeLayer(closest, false);
                    }

                    //Create new cluster with these 2 in it

                    var newCluster = new this._markerCluster(this, zoom, closest, layer);
                    gridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom));
                    closest.__parent = newCluster;
                    layer.__parent = newCluster;

                    //First create any new intermediate parent clusters that don't exist
                    var lastParent = newCluster;
                    for (z = zoom - 1; z > parent._zoom; z--) {
                        lastParent = new this._markerCluster(this, z, lastParent);
                        gridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));
                    }
                    parent._addChild(lastParent);

                    //Remove closest from this zoom level and any above that it is in, replace with newCluster
                    this._removeFromGridUnclustered(closest, zoom);

                    return;
                }

                //Didn't manage to cluster in at this zoom, record us as a marker here and continue upwards
                gridUnclustered[zoom].addObject(layer, markerPoint);
            }

            //Didn't get in anything, add us to the top
            this._topClusterLevel._addChild(layer);
            layer.__parent = this._topClusterLevel;
            return;
        },

        //Enqueue code to fire after the marker expand/contract has happened
        _enqueue: function (fn) {
            this._queue.push(fn);
            if (!this._queueTimeout) {
                this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300);
            }
        },
        _processQueue: function () {
            for (var i = 0; i < this._queue.length; i++) {
                this._queue[i].call(this);
            }
            this._queue.length = 0;
            clearTimeout(this._queueTimeout);
            this._queueTimeout = null;
        },

        //Merge and split any existing clusters that are too big or small
        _mergeSplitClusters: function () {
            var mapZoom = Math.round(this._map._zoom);

            //In case we are starting to split before the animation finished
            this._processQueue();

            if (this._zoom < mapZoom && this._currentShownBounds.intersects(this._getExpandedVisibleBounds())) { //Zoom in, split
                this._animationStart();
                //Remove clusters now off screen
                this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, this._getExpandedVisibleBounds());

                this._animationZoomIn(this._zoom, mapZoom);

            } else if (this._zoom > mapZoom) { //Zoom out, merge
                this._animationStart();

                this._animationZoomOut(this._zoom, mapZoom);
            } else {
                this._moveEnd();
            }
        },

        //Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)
        _getExpandedVisibleBounds: function () {
            if (!this.options.removeOutsideVisibleBounds) {
                return this._mapBoundsInfinite;
            } else if (L.Browser.mobile) {
                return this._checkBoundsMaxLat(this._map.getBounds());
            }

            return this._checkBoundsMaxLat(this._map.getBounds().pad(1)); // Padding expands the bounds by its own dimensions but scaled with the given factor.
        },

        /**
         * Expands the latitude to Infinity (or -Infinity) if the input bounds reach the map projection maximum defined latitude
         * (in the case of Web/Spherical Mercator, it is 85.0511287798 / see https://en.wikipedia.org/wiki/Web_Mercator#Formulas).
         * Otherwise, the removeOutsideVisibleBounds option will remove markers beyond that limit, whereas the same markers without
         * this option (or outside MCG) will have their position floored (ceiled) by the projection and rendered at that limit,
         * making the user think that MCG "eats" them and never displays them again.
         * @param bounds L.LatLngBounds
         * @returns {L.LatLngBounds}
         * @private
         */
        _checkBoundsMaxLat: function (bounds) {
            var maxLat = this._maxLat;

            if (maxLat !== undefined) {
                if (bounds.getNorth() >= maxLat) {
                    bounds._northEast.lat = Infinity;
                }
                if (bounds.getSouth() <= -maxLat) {
                    bounds._southWest.lat = -Infinity;
                }
            }

            return bounds;
        },

        //Shared animation code
        _animationAddLayerNonAnimated: function (layer, newCluster) {
            if (newCluster === layer) {
                this._featureGroup.addLayer(layer);
            } else if (newCluster._childCount === 2) {
                newCluster._addToMap();

                var markers = newCluster.getAllChildMarkers();
                this._featureGroup.removeLayer(markers[0]);
                this._featureGroup.removeLayer(markers[1]);
            } else {
                newCluster._updateIcon();
            }
        },

        /**
         * Extracts individual (i.e. non-group) layers from a Layer Group.
         * @param group to extract layers from.
         * @param output {Array} in which to store the extracted layers.
         * @returns {*|Array}
         * @private
         */
        _extractNonGroupLayers: function (group, output) {
            var layers = group.getLayers(),
                i = 0,
                layer;

            output = output || [];

            for (; i < layers.length; i++) {
                layer = layers[i];

                if (layer instanceof L.LayerGroup) {
                    this._extractNonGroupLayers(layer, output);
                    continue;
                }

                output.push(layer);
            }

            return output;
        },

        /**
         * Implements the singleMarkerMode option.
         * @param layer Marker to re-style using the Clusters iconCreateFunction.
         * @returns {L.Icon} The newly created icon.
         * @private
         */
        _overrideMarkerIcon: function (layer) {
            var icon = layer.options.icon = this.options.iconCreateFunction({
                getChildCount: function () {
                    return 1;
                },
                getAllChildMarkers: function () {
                    return [layer];
                }
            });

            return icon;
        }
    });

// Constant bounds used in case option "removeOutsideVisibleBounds" is set to false.
    L.MarkerClusterGroup.include({
        _mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-Infinity, -Infinity), new L.LatLng(Infinity, Infinity))
    });

    L.MarkerClusterGroup.include({
        _noAnimation: {
            //Non Animated versions of everything
            _animationStart: function () {
                //Do nothing...
            },
            _animationZoomIn: function (previousZoomLevel, newZoomLevel) {
                this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel);
                this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());

                //We didn't actually animate, but we use this event to mean "clustering animations have finished"
                this.fire('animationend');
            },
            _animationZoomOut: function (previousZoomLevel, newZoomLevel) {
                this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel);
                this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());

                //We didn't actually animate, but we use this event to mean "clustering animations have finished"
                this.fire('animationend');
            },
            _animationAddLayer: function (layer, newCluster) {
                this._animationAddLayerNonAnimated(layer, newCluster);
            }
        },

        _withAnimation: {
            //Animated versions here
            _animationStart: function () {
                this._map._mapPane.className += ' leaflet-cluster-anim';
                this._inZoomAnimation++;
            },

            _animationZoomIn: function (previousZoomLevel, newZoomLevel) {
                var bounds = this._getExpandedVisibleBounds(),
                    fg = this._featureGroup,
                    i;

                this._ignoreMove = true;

                //Add all children of current clusters to map and remove those clusters from map
                this._topClusterLevel._recursively(bounds, previousZoomLevel, 0, function (c) {
                    var startPos = c._latlng,
                        markers = c._markers,
                        m;

                    if (!bounds.contains(startPos)) {
                        startPos = null;
                    }

                    if (c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel) { //Immediately add the new child and remove us
                        fg.removeLayer(c);
                        c._recursivelyAddChildrenToMap(null, newZoomLevel, bounds);
                    } else {
                        //Fade out old cluster
                        c.clusterHide();
                        c._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds);
                    }

                    //Remove all markers that aren't visible any more
                    //TODO: Do we actually need to do this on the higher levels too?
                    for (i = markers.length - 1; i >= 0; i--) {
                        m = markers[i];
                        if (!bounds.contains(m._latlng)) {
                            fg.removeLayer(m);
                        }
                    }

                });

                this._forceLayout();

                //Update opacities
                this._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);
                //TODO Maybe? Update markers in _recursivelyBecomeVisible
                fg.eachLayer(function (n) {
                    if (!(n instanceof L.MarkerCluster) && n._icon) {
                        n.clusterShow();
                    }
                });

                //update the positions of the just added clusters/markers
                this._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function (c) {
                    c._recursivelyRestoreChildPositions(newZoomLevel);
                });

                this._ignoreMove = false;

                //Remove the old clusters and close the zoom animation
                this._enqueue(function () {
                    //update the positions of the just added clusters/markers
                    this._topClusterLevel._recursively(bounds, previousZoomLevel, 0, function (c) {
                        fg.removeLayer(c);
                        c.clusterShow();
                    });

                    this._animationEnd();
                });
            },

            _animationZoomOut: function (previousZoomLevel, newZoomLevel) {
                this._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);

                //Need to add markers for those that weren't on the map before but are now
                this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());
                //Remove markers that were on the map before but won't be now
                this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel, this._getExpandedVisibleBounds());
            },

            _animationAddLayer: function (layer, newCluster) {
                var me = this,
                    fg = this._featureGroup;

                fg.addLayer(layer);
                if (newCluster !== layer) {
                    if (newCluster._childCount > 2) { //Was already a cluster

                        newCluster._updateIcon();
                        this._forceLayout();
                        this._animationStart();

                        layer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));
                        layer.clusterHide();

                        this._enqueue(function () {
                            fg.removeLayer(layer);
                            layer.clusterShow();

                            me._animationEnd();
                        });

                    } else { //Just became a cluster
                        this._forceLayout();

                        me._animationStart();
                        me._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._map.getZoom());
                    }
                }
            }
        },

        // Private methods for animated versions.
        _animationZoomOutSingle: function (cluster, previousZoomLevel, newZoomLevel) {
            var bounds = this._getExpandedVisibleBounds();

            //Animate all of the markers in the clusters to move to their cluster center point
            cluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, previousZoomLevel + 1, newZoomLevel);

            var me = this;

            //Update the opacity (If we immediately set it they won't animate)
            this._forceLayout();
            cluster._recursivelyBecomeVisible(bounds, newZoomLevel);

            //TODO: Maybe use the transition timing stuff to make this more reliable
            //When the animations are done, tidy up
            this._enqueue(function () {

                //This cluster stopped being a cluster before the timeout fired
                if (cluster._childCount === 1) {
                    var m = cluster._markers[0];
                    //If we were in a cluster animation at the time then the opacity and position of our child could be wrong now, so fix it
                    this._ignoreMove = true;
                    m.setLatLng(m.getLatLng());
                    this._ignoreMove = false;
                    if (m.clusterShow) {
                        m.clusterShow();
                    }
                } else {
                    cluster._recursively(bounds, newZoomLevel, 0, function (c) {
                        c._recursivelyRemoveChildrenFromMap(bounds, previousZoomLevel + 1);
                    });
                }
                me._animationEnd();
            });
        },

        _animationEnd: function () {
            if (this._map) {
                this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');
            }
            this._inZoomAnimation--;
            this.fire('animationend');
        },

        //Force a browser layout of stuff in the map
        // Should apply the current opacity and location to all elements so we can update them again for an animation
        _forceLayout: function () {
            //In my testing this works, infact offsetWidth of any element seems to work.
            //Could loop all this._layers and do this for each _icon if it stops working

            L.Util.falseFn(document.body.offsetWidth);
        }
    });

    L.markerClusterGroup = function (options) {
        return new L.MarkerClusterGroup(options);
    };


    L.MarkerCluster = L.Marker.extend({
        initialize: function (group, zoom, a, b) {

            L.Marker.prototype.initialize.call(this, a ? (a._cLatLng || a.getLatLng()) : new L.LatLng(0, 0), {icon: this});


            this._group = group;
            this._zoom = zoom;

            this._markers = [];
            this._childClusters = [];
            this._childCount = 0;
            this._iconNeedsUpdate = true;
            this._boundsNeedUpdate = true;

            this._bounds = new L.LatLngBounds();

            if (a) {
                this._addChild(a);
            }
            if (b) {
                this._addChild(b);
            }
        },

        //Recursively retrieve all child markers of this cluster
        getAllChildMarkers: function (storageArray) {
            storageArray = storageArray || [];

            for (var i = this._childClusters.length - 1; i >= 0; i--) {
                this._childClusters[i].getAllChildMarkers(storageArray);
            }

            for (var j = this._markers.length - 1; j >= 0; j--) {
                storageArray.push(this._markers[j]);
            }

            return storageArray;
        },

        //Returns the count of how many child markers we have
        getChildCount: function () {
            return this._childCount;
        },

        //Zoom to the minimum of showing all of the child markers, or the extents of this cluster
        zoomToBounds: function () {
            var childClusters = this._childClusters.slice(),
                map = this._group._map,
                boundsZoom = map.getBoundsZoom(this._bounds),
                zoom = this._zoom + 1,
                mapZoom = map.getZoom(),
                i;

            //calculate how far we need to zoom down to see all of the markers
            while (childClusters.length > 0 && boundsZoom > zoom) {
                zoom++;
                var newClusters = [];
                for (i = 0; i < childClusters.length; i++) {
                    newClusters = newClusters.concat(childClusters[i]._childClusters);
                }
                childClusters = newClusters;
            }

            if (boundsZoom > zoom) {
                this._group._map.setView(this._latlng, zoom);
            } else if (boundsZoom <= mapZoom) { //If fitBounds wouldn't zoom us down, zoom us down instead
                this._group._map.setView(this._latlng, mapZoom + 1);
            } else {
                this._group._map.fitBounds(this._bounds);
            }
        },

        getBounds: function () {
            var bounds = new L.LatLngBounds();
            bounds.extend(this._bounds);
            return bounds;
        },

        _updateIcon: function () {
            this._iconNeedsUpdate = true;
            if (this._icon) {
                this.setIcon(this);
            }
        },

        //Cludge for Icon, we pretend to be an icon for performance
        createIcon: function () {
            if (this._iconNeedsUpdate) {
                this._iconObj = this._group.options.iconCreateFunction(this);
                this._iconNeedsUpdate = false;
            }
            return this._iconObj.createIcon();
        },
        createShadow: function () {
            return this._iconObj.createShadow();
        },


        _addChild: function (new1, isNotificationFromChild) {

            this._iconNeedsUpdate = true;

            this._boundsNeedUpdate = true;
            this._setClusterCenter(new1);

            if (new1 instanceof L.MarkerCluster) {
                if (!isNotificationFromChild) {
                    this._childClusters.push(new1);
                    new1.__parent = this;
                }
                this._childCount += new1._childCount;
            } else {
                if (!isNotificationFromChild) {
                    this._markers.push(new1);
                }
                this._childCount++;
            }

            if (this.__parent) {
                this.__parent._addChild(new1, true);
            }
        },

        /**
         * Makes sure the cluster center is set. If not, uses the child center if it is a cluster, or the marker position.
         * @param child L.MarkerCluster|L.Marker that will be used as cluster center if not defined yet.
         * @private
         */
        _setClusterCenter: function (child) {
            if (!this._cLatLng) {
                // when clustering, take position of the first point as the cluster center
                this._cLatLng = child._cLatLng || child._latlng;
            }
        },

        /**
         * Assigns impossible bounding values so that the next extend entirely determines the new bounds.
         * This method avoids having to trash the previous L.LatLngBounds object and to create a new one, which is much slower for this class.
         * As long as the bounds are not extended, most other methods would probably fail, as they would with bounds initialized but not extended.
         * @private
         */
        _resetBounds: function () {
            var bounds = this._bounds;

            if (bounds._southWest) {
                bounds._southWest.lat = Infinity;
                bounds._southWest.lng = Infinity;
            }
            if (bounds._northEast) {
                bounds._northEast.lat = -Infinity;
                bounds._northEast.lng = -Infinity;
            }
        },

        _recalculateBounds: function () {
            var markers = this._markers,
                childClusters = this._childClusters,
                latSum = 0,
                lngSum = 0,
                totalCount = this._childCount,
                i, child, childLatLng, childCount;

            // Case where all markers are removed from the map and we are left with just an empty _topClusterLevel.
            if (totalCount === 0) {
                return;
            }

            // Reset rather than creating a new object, for performance.
            this._resetBounds();

            // Child markers.
            for (i = 0; i < markers.length; i++) {
                childLatLng = markers[i]._latlng;

                this._bounds.extend(childLatLng);

                latSum += childLatLng.lat;
                lngSum += childLatLng.lng;
            }

            // Child clusters.
            for (i = 0; i < childClusters.length; i++) {
                child = childClusters[i];

                // Re-compute child bounds and weighted position first if necessary.
                if (child._boundsNeedUpdate) {
                    child._recalculateBounds();
                }

                this._bounds.extend(child._bounds);

                childLatLng = child._wLatLng;
                childCount = child._childCount;

                latSum += childLatLng.lat * childCount;
                lngSum += childLatLng.lng * childCount;
            }

            this._latlng = this._wLatLng = new L.LatLng(latSum / totalCount, lngSum / totalCount);

            // Reset dirty flag.
            this._boundsNeedUpdate = false;
        },

        //Set our markers position as given and add it to the map
        _addToMap: function (startPos) {
            if (startPos) {
                this._backupLatlng = this._latlng;
                this.setLatLng(startPos);
            }
            this._group._featureGroup.addLayer(this);
        },

        _recursivelyAnimateChildrenIn: function (bounds, center, maxZoom) {
            this._recursively(bounds, 0, maxZoom - 1,
                function (c) {
                    var markers = c._markers,
                        i, m;
                    for (i = markers.length - 1; i >= 0; i--) {
                        m = markers[i];

                        //Only do it if the icon is still on the map
                        if (m._icon) {
                            m._setPos(center);
                            m.clusterHide();
                        }
                    }
                },
                function (c) {
                    var childClusters = c._childClusters,
                        j, cm;
                    for (j = childClusters.length - 1; j >= 0; j--) {
                        cm = childClusters[j];
                        if (cm._icon) {
                            cm._setPos(center);
                            cm.clusterHide();
                        }
                    }
                }
            );
        },

        _recursivelyAnimateChildrenInAndAddSelfToMap: function (bounds, previousZoomLevel, newZoomLevel) {
            this._recursively(bounds, newZoomLevel, 0,
                function (c) {
                    c._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);

                    //TODO: depthToAnimateIn affects _isSingleParent, if there is a multizoom we may/may not be.
                    //As a hack we only do a animation free zoom on a single level zoom, if someone does multiple levels then we always animate
                    if (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {
                        c.clusterShow();
                        c._recursivelyRemoveChildrenFromMap(bounds, previousZoomLevel); //Immediately remove our children as we are replacing them. TODO previousBounds not bounds
                    } else {
                        c.clusterHide();
                    }

                    c._addToMap();
                }
            );
        },

        _recursivelyBecomeVisible: function (bounds, zoomLevel) {
            this._recursively(bounds, 0, zoomLevel, null, function (c) {
                c.clusterShow();
            });
        },

        _recursivelyAddChildrenToMap: function (startPos, zoomLevel, bounds) {
            this._recursively(bounds, -1, zoomLevel,
                function (c) {
                    if (zoomLevel === c._zoom) {
                        return;
                    }

                    //Add our child markers at startPos (so they can be animated out)
                    for (var i = c._markers.length - 1; i >= 0; i--) {
                        var nm = c._markers[i];

                        if (!bounds.contains(nm._latlng)) {
                            continue;
                        }

                        if (startPos) {
                            nm._backupLatlng = nm.getLatLng();

                            nm.setLatLng(startPos);
                            if (nm.clusterHide) {
                                nm.clusterHide();
                            }
                        }

                        c._group._featureGroup.addLayer(nm);
                    }
                },
                function (c) {
                    c._addToMap(startPos);
                }
            );
        },

        _recursivelyRestoreChildPositions: function (zoomLevel) {
            //Fix positions of child markers
            for (var i = this._markers.length - 1; i >= 0; i--) {
                var nm = this._markers[i];
                if (nm._backupLatlng) {
                    nm.setLatLng(nm._backupLatlng);
                    delete nm._backupLatlng;
                }
            }

            if (zoomLevel - 1 === this._zoom) {
                //Reposition child clusters
                for (var j = this._childClusters.length - 1; j >= 0; j--) {
                    this._childClusters[j]._restorePosition();
                }
            } else {
                for (var k = this._childClusters.length - 1; k >= 0; k--) {
                    this._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);
                }
            }
        },

        _restorePosition: function () {
            if (this._backupLatlng) {
                this.setLatLng(this._backupLatlng);
                delete this._backupLatlng;
            }
        },

        //exceptBounds: If set, don't remove any markers/clusters in it
        _recursivelyRemoveChildrenFromMap: function (previousBounds, zoomLevel, exceptBounds) {
            var m, i;
            this._recursively(previousBounds, -1, zoomLevel - 1,
                function (c) {
                    //Remove markers at every level
                    for (i = c._markers.length - 1; i >= 0; i--) {
                        m = c._markers[i];
                        if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
                            c._group._featureGroup.removeLayer(m);
                            if (m.clusterShow) {
                                m.clusterShow();
                            }
                        }
                    }
                },
                function (c) {
                    //Remove child clusters at just the bottom level
                    for (i = c._childClusters.length - 1; i >= 0; i--) {
                        m = c._childClusters[i];
                        if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
                            c._group._featureGroup.removeLayer(m);
                            if (m.clusterShow) {
                                m.clusterShow();
                            }
                        }
                    }
                }
            );
        },

        //Run the given functions recursively to this and child clusters
        // boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to
        // zoomLevelToStart: zoom level to start running functions (inclusive)
        // zoomLevelToStop: zoom level to stop running functions (inclusive)
        // runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level
        // runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level
        _recursively: function (boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {
            var childClusters = this._childClusters,
                zoom = this._zoom,
                i, c;

            if (zoomLevelToStart > zoom) { //Still going down to required depth, just recurse to child clusters
                for (i = childClusters.length - 1; i >= 0; i--) {
                    c = childClusters[i];
                    if (boundsToApplyTo.intersects(c._bounds)) {
                        c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
                    }
                }
            } else { //In required depth

                if (runAtEveryLevel) {
                    runAtEveryLevel(this);
                }
                if (runAtBottomLevel && this._zoom === zoomLevelToStop) {
                    runAtBottomLevel(this);
                }

                //TODO: This loop is almost the same as above
                if (zoomLevelToStop > zoom) {
                    for (i = childClusters.length - 1; i >= 0; i--) {
                        c = childClusters[i];
                        if (boundsToApplyTo.intersects(c._bounds)) {
                            c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
                        }
                    }
                }
            }
        },

        //Returns true if we are the parent of only one cluster and that cluster is the same as us
        _isSingleParent: function () {
            //Don't need to check this._markers as the rest won't work if there are any
            return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;
        }
    });


    /*
     * Extends L.Marker to include two extra methods: clusterHide and clusterShow.
     *
     * They work as setOpacity(0) and setOpacity(1) respectively, but
     * they will remember the marker's opacity when hiding and showing it again.
     *
     */


    L.Marker.include({

        clusterHide: function () {
            this.options.opacityWhenUnclustered = this.options.opacity || 1;
            return this.setOpacity(0);
        },

        clusterShow: function () {
            var ret = this.setOpacity(this.options.opacity || this.options.opacityWhenUnclustered);
            delete this.options.opacityWhenUnclustered;
            return ret;
        }

    });


    L.DistanceGrid = function (cellSize) {
        this._cellSize = cellSize;
        this._sqCellSize = cellSize * cellSize;
        this._grid = {};
        this._objectPoint = {};
    };

    L.DistanceGrid.prototype = {

        addObject: function (obj, point) {
            var x = this._getCoord(point.x),
                y = this._getCoord(point.y),
                grid = this._grid,
                row = grid[y] = grid[y] || {},
                cell = row[x] = row[x] || [],
                stamp = L.Util.stamp(obj);

            this._objectPoint[stamp] = point;

            cell.push(obj);
        },

        updateObject: function (obj, point) {
            this.removeObject(obj);
            this.addObject(obj, point);
        },

        //Returns true if the object was found
        removeObject: function (obj, point) {
            var x = this._getCoord(point.x),
                y = this._getCoord(point.y),
                grid = this._grid,
                row = grid[y] = grid[y] || {},
                cell = row[x] = row[x] || [],
                i, len;

            delete this._objectPoint[L.Util.stamp(obj)];

            for (i = 0, len = cell.length; i < len; i++) {
                if (cell[i] === obj) {

                    cell.splice(i, 1);

                    if (len === 1) {
                        delete row[x];
                    }

                    return true;
                }
            }

        },

        eachObject: function (fn, context) {
            var i, j, k, len, row, cell, removed,
                grid = this._grid;

            for (i in grid) {
                row = grid[i];

                for (j in row) {
                    cell = row[j];

                    for (k = 0, len = cell.length; k < len; k++) {
                        removed = fn.call(context, cell[k]);
                        if (removed) {
                            k--;
                            len--;
                        }
                    }
                }
            }
        },

        getNearObject: function (point) {
            var x = this._getCoord(point.x),
                y = this._getCoord(point.y),
                i, j, k, row, cell, len, obj, dist,
                objectPoint = this._objectPoint,
                closestDistSq = this._sqCellSize,
                closest = null;

            for (i = y - 1; i <= y + 1; i++) {
                row = this._grid[i];
                if (row) {

                    for (j = x - 1; j <= x + 1; j++) {
                        cell = row[j];
                        if (cell) {

                            for (k = 0, len = cell.length; k < len; k++) {
                                obj = cell[k];
                                dist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);
                                if (dist < closestDistSq) {
                                    closestDistSq = dist;
                                    closest = obj;
                                }
                            }
                        }
                    }
                }
            }
            return closest;
        },

        _getCoord: function (x) {
            return Math.floor(x / this._cellSize);
        },

        _sqDist: function (p, p2) {
            var dx = p2.x - p.x,
                dy = p2.y - p.y;
            return dx * dx + dy * dy;
        }
    };


    /* Copyright (c) 2012 the authors listed at the following URL, and/or
     the authors of referenced articles or incorporated external code:
     http://en.literateprograms.org/Quickhull_(Javascript)?action=history&offset=20120410175256

     Permission is hereby granted, free of charge, to any person obtaining
     a copy of this software and associated documentation files (the
     "Software"), to deal in the Software without restriction, including
     without limitation the rights to use, copy, modify, merge, publish,
     distribute, sublicense, and/or sell copies of the Software, and to
     permit persons to whom the Software is furnished to do so, subject to
     the following conditions:

     The above copyright notice and this permission notice shall be
     included in all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

     Retrieved from: http://en.literateprograms.org/Quickhull_(Javascript)?oldid=18434
     */

    (function () {
        L.QuickHull = {

            /*
             * @param {Object} cpt a point to be measured from the baseline
             * @param {Array} bl the baseline, as represented by a two-element
             *   array of latlng objects.
             * @returns {Number} an approximate distance measure
             */
            getDistant: function (cpt, bl) {
                var vY = bl[1].lat - bl[0].lat,
                    vX = bl[0].lng - bl[1].lng;
                return (vX * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng));
            },

            /*
             * @param {Array} baseLine a two-element array of latlng objects
             *   representing the baseline to project from
             * @param {Array} latLngs an array of latlng objects
             * @returns {Object} the maximum point and all new points to stay
             *   in consideration for the hull.
             */
            findMostDistantPointFromBaseLine: function (baseLine, latLngs) {
                var maxD = 0,
                    maxPt = null,
                    newPoints = [],
                    i, pt, d;

                for (i = latLngs.length - 1; i >= 0; i--) {
                    pt = latLngs[i];
                    d = this.getDistant(pt, baseLine);

                    if (d > 0) {
                        newPoints.push(pt);
                    } else {
                        continue;
                    }

                    if (d > maxD) {
                        maxD = d;
                        maxPt = pt;
                    }
                }

                return {maxPoint: maxPt, newPoints: newPoints};
            },


            /*
             * Given a baseline, compute the convex hull of latLngs as an array
             * of latLngs.
             *
             * @param {Array} latLngs
             * @returns {Array}
             */
            buildConvexHull: function (baseLine, latLngs) {
                var convexHullBaseLines = [],
                    t = this.findMostDistantPointFromBaseLine(baseLine, latLngs);

                if (t.maxPoint) { // if there is still a point "outside" the base line
                    convexHullBaseLines =
                        convexHullBaseLines.concat(
                            this.buildConvexHull([baseLine[0], t.maxPoint], t.newPoints)
                        );
                    convexHullBaseLines =
                        convexHullBaseLines.concat(
                            this.buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints)
                        );
                    return convexHullBaseLines;
                } else {  // if there is no more point "outside" the base line, the current base line is part of the convex hull
                    return [baseLine[0]];
                }
            },

            /*
             * Given an array of latlngs, compute a convex hull as an array
             * of latlngs
             *
             * @param {Array} latLngs
             * @returns {Array}
             */
            getConvexHull: function (latLngs) {
                // find first baseline
                var maxLat = false, minLat = false,
                    maxLng = false, minLng = false,
                    maxLatPt = null, minLatPt = null,
                    maxLngPt = null, minLngPt = null,
                    maxPt = null, minPt = null,
                    i;

                for (i = latLngs.length - 1; i >= 0; i--) {
                    var pt = latLngs[i];
                    if (maxLat === false || pt.lat > maxLat) {
                        maxLatPt = pt;
                        maxLat = pt.lat;
                    }
                    if (minLat === false || pt.lat < minLat) {
                        minLatPt = pt;
                        minLat = pt.lat;
                    }
                    if (maxLng === false || pt.lng > maxLng) {
                        maxLngPt = pt;
                        maxLng = pt.lng;
                    }
                    if (minLng === false || pt.lng < minLng) {
                        minLngPt = pt;
                        minLng = pt.lng;
                    }
                }

                if (minLat !== maxLat) {
                    minPt = minLatPt;
                    maxPt = maxLatPt;
                } else {
                    minPt = minLngPt;
                    maxPt = maxLngPt;
                }

                var ch = [].concat(this.buildConvexHull([minPt, maxPt], latLngs),
                    this.buildConvexHull([maxPt, minPt], latLngs));
                return ch;
            }
        };
    }());

    L.MarkerCluster.include({
        getConvexHull: function () {
            var childMarkers = this.getAllChildMarkers(),
                points = [],
                p, i;

            for (i = childMarkers.length - 1; i >= 0; i--) {
                p = childMarkers[i].getLatLng();
                points.push(p);
            }

            return L.QuickHull.getConvexHull(points);
        }
    });


//This code is 100% based on https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet
//Huge thanks to jawj for implementing it first to make my job easy :-)

    L.MarkerCluster.include({

        _2PI: Math.PI * 2,
        _circleFootSeparation: 25, //related to circumference of circle
        _circleStartAngle: Math.PI / 6,

        _spiralFootSeparation: 28, //related to size of spiral (experiment!)
        _spiralLengthStart: 11,
        _spiralLengthFactor: 5,

        _circleSpiralSwitchover: 9, //show spiral instead of circle from this marker count upwards.
                                    // 0 -> always spiral; Infinity -> always circle

        spiderfy: function () {
            if (this._group._spiderfied === this || this._group._inZoomAnimation) {
                return;
            }

            var childMarkers = this.getAllChildMarkers(),
                group = this._group,
                map = group._map,
                center = map.latLngToLayerPoint(this._latlng),
                positions;

            this._group._unspiderfy();
            this._group._spiderfied = this;

            //TODO Maybe: childMarkers order by distance to center

            if (childMarkers.length >= this._circleSpiralSwitchover) {
                positions = this._generatePointsSpiral(childMarkers.length, center);
            } else {
                center.y += 10; // Otherwise circles look wrong => hack for standard blue icon, renders differently for other icons.
                positions = this._generatePointsCircle(childMarkers.length, center);
            }

            this._animationSpiderfy(childMarkers, positions);
        },

        unspiderfy: function (zoomDetails) {
            /// <param Name="zoomDetails">Argument from zoomanim if being called in a zoom animation or null otherwise</param>
            if (this._group._inZoomAnimation) {
                return;
            }
            this._animationUnspiderfy(zoomDetails);

            this._group._spiderfied = null;
        },

        _generatePointsCircle: function (count, centerPt) {
            var circumference = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count),
                legLength = circumference / this._2PI,  //radius from circumference
                angleStep = this._2PI / count,
                res = [],
                i, angle;

            res.length = count;

            for (i = count - 1; i >= 0; i--) {
                angle = this._circleStartAngle + i * angleStep;
                res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
            }

            return res;
        },

        _generatePointsSpiral: function (count, centerPt) {
            var spiderfyDistanceMultiplier = this._group.options.spiderfyDistanceMultiplier,
                legLength = spiderfyDistanceMultiplier * this._spiralLengthStart,
                separation = spiderfyDistanceMultiplier * this._spiralFootSeparation,
                lengthFactor = spiderfyDistanceMultiplier * this._spiralLengthFactor * this._2PI,
                angle = 0,
                res = [],
                i;

            res.length = count;

            // Higher index, closer position to cluster center.
            for (i = count - 1; i >= 0; i--) {
                angle += separation / legLength + i * 0.0005;
                res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
                legLength += lengthFactor / angle;
            }
            return res;
        },

        _noanimationUnspiderfy: function () {
            var group = this._group,
                map = group._map,
                fg = group._featureGroup,
                childMarkers = this.getAllChildMarkers(),
                m, i;

            group._ignoreMove = true;

            this.setOpacity(1);
            for (i = childMarkers.length - 1; i >= 0; i--) {
                m = childMarkers[i];

                fg.removeLayer(m);

                if (m._preSpiderfyLatlng) {
                    m.setLatLng(m._preSpiderfyLatlng);
                    delete m._preSpiderfyLatlng;
                }
                if (m.setZIndexOffset) {
                    m.setZIndexOffset(0);
                }

                if (m._spiderLeg) {
                    map.removeLayer(m._spiderLeg);
                    delete m._spiderLeg;
                }
            }

            group.fire('unspiderfied', {
                cluster: this,
                markers: childMarkers
            });
            group._ignoreMove = false;
            group._spiderfied = null;
        }
    });

//Non Animated versions of everything
    L.MarkerClusterNonAnimated = L.MarkerCluster.extend({
        _animationSpiderfy: function (childMarkers, positions) {
            var group = this._group,
                map = group._map,
                fg = group._featureGroup,
                legOptions = this._group.options.spiderLegPolylineOptions,
                i, m, leg, newPos;

            group._ignoreMove = true;

            // Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.
            // The reverse order trick no longer improves performance on modern browsers.
            for (i = 0; i < childMarkers.length; i++) {
                newPos = map.layerPointToLatLng(positions[i]);
                m = childMarkers[i];

                // Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.
                leg = new L.Polyline([this._latlng, newPos], legOptions);
                map.addLayer(leg);
                m._spiderLeg = leg;

                // Now add the marker.
                m._preSpiderfyLatlng = m._latlng;
                m.setLatLng(newPos);
                if (m.setZIndexOffset) {
                    m.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING
                }

                fg.addLayer(m);
            }
            this.setOpacity(0.3);

            group._ignoreMove = false;
            group.fire('spiderfied', {
                cluster: this,
                markers: childMarkers
            });
        },

        _animationUnspiderfy: function () {
            this._noanimationUnspiderfy();
        }
    });

//Animated versions here
    L.MarkerCluster.include({

        _animationSpiderfy: function (childMarkers, positions) {
            var me = this,
                group = this._group,
                map = group._map,
                fg = group._featureGroup,
                thisLayerLatLng = this._latlng,
                thisLayerPos = map.latLngToLayerPoint(thisLayerLatLng),
                svg = L.Path.SVG,
                legOptions = L.extend({}, this._group.options.spiderLegPolylineOptions), // Copy the options so that we can modify them for animation.
                finalLegOpacity = legOptions.opacity,
                i, m, leg, legPath, legLength, newPos;

            if (finalLegOpacity === undefined) {
                finalLegOpacity = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity;
            }

            if (svg) {
                // If the initial opacity of the spider leg is not 0 then it appears before the animation starts.
                legOptions.opacity = 0;

                // Add the class for CSS transitions.
                legOptions.className = (legOptions.className || '') + ' leaflet-cluster-spider-leg';
            } else {
                // Make sure we have a defined opacity.
                legOptions.opacity = finalLegOpacity;
            }

            group._ignoreMove = true;

            // Add markers and spider legs to map, hidden at our center point.
            // Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.
            // The reverse order trick no longer improves performance on modern browsers.
            for (i = 0; i < childMarkers.length; i++) {
                m = childMarkers[i];

                newPos = map.layerPointToLatLng(positions[i]);

                // Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.
                leg = new L.Polyline([thisLayerLatLng, newPos], legOptions);
                map.addLayer(leg);
                m._spiderLeg = leg;

                // Explanations: https://jakearchibald.com/2013/animated-line-drawing-svg/
                // In our case the transition property is declared in the CSS file.
                if (svg) {
                    legPath = leg._path;
                    legLength = legPath.getTotalLength() + 0.1; // Need a small extra length to avoid remaining dot in Firefox.
                    legPath.style.strokeDasharray = legLength; // Just 1 length is enough, it will be duplicated.
                    legPath.style.strokeDashoffset = legLength;
                }

                // If it is a marker, add it now and we'll animate it out
                if (m.setZIndexOffset) {
                    m.setZIndexOffset(1000000); // Make normal markers appear on top of EVERYTHING
                }
                if (m.clusterHide) {
                    m.clusterHide();
                }

                // Vectors just get immediately added
                fg.addLayer(m);

                if (m._setPos) {
                    m._setPos(thisLayerPos);
                }
            }

            group._forceLayout();
            group._animationStart();

            // Reveal markers and spider legs.
            for (i = childMarkers.length - 1; i >= 0; i--) {
                newPos = map.layerPointToLatLng(positions[i]);
                m = childMarkers[i];

                //Move marker to new position
                m._preSpiderfyLatlng = m._latlng;
                m.setLatLng(newPos);

                if (m.clusterShow) {
                    m.clusterShow();
                }

                // Animate leg (animation is actually delegated to CSS transition).
                if (svg) {
                    leg = m._spiderLeg;
                    legPath = leg._path;
                    legPath.style.strokeDashoffset = 0;
                    //legPath.style.strokeOpacity = finalLegOpacity;
                    leg.setStyle({opacity: finalLegOpacity});
                }
            }
            this.setOpacity(0.3);

            group._ignoreMove = false;

            setTimeout(function () {
                group._animationEnd();
                group.fire('spiderfied', {
                    cluster: me,
                    markers: childMarkers
                });
            }, 200);
        },

        _animationUnspiderfy: function (zoomDetails) {
            var me = this,
                group = this._group,
                map = group._map,
                fg = group._featureGroup,
                thisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng),
                childMarkers = this.getAllChildMarkers(),
                svg = L.Path.SVG,
                m, i, leg, legPath, legLength, nonAnimatable;

            group._ignoreMove = true;
            group._animationStart();

            //Make us visible and bring the child markers back in
            this.setOpacity(1);
            for (i = childMarkers.length - 1; i >= 0; i--) {
                m = childMarkers[i];

                //Marker was added to us after we were spiderfied
                if (!m._preSpiderfyLatlng) {
                    continue;
                }

                //Fix up the location to the real one
                m.setLatLng(m._preSpiderfyLatlng);
                delete m._preSpiderfyLatlng;

                //Hack override the location to be our center
                nonAnimatable = true;
                if (m._setPos) {
                    m._setPos(thisLayerPos);
                    nonAnimatable = false;
                }
                if (m.clusterHide) {
                    m.clusterHide();
                    nonAnimatable = false;
                }
                if (nonAnimatable) {
                    fg.removeLayer(m);
                }

                // Animate the spider leg back in (animation is actually delegated to CSS transition).
                if (svg) {
                    leg = m._spiderLeg;
                    legPath = leg._path;
                    legLength = legPath.getTotalLength() + 0.1;
                    legPath.style.strokeDashoffset = legLength;
                    leg.setStyle({opacity: 0});
                }
            }

            group._ignoreMove = false;

            setTimeout(function () {
                //If we have only <= one child left then that marker will be shown on the map so don't remove it!
                var stillThereChildCount = 0;
                for (i = childMarkers.length - 1; i >= 0; i--) {
                    m = childMarkers[i];
                    if (m._spiderLeg) {
                        stillThereChildCount++;
                    }
                }


                for (i = childMarkers.length - 1; i >= 0; i--) {
                    m = childMarkers[i];

                    if (!m._spiderLeg) { //Has already been unspiderfied
                        continue;
                    }

                    if (m.clusterShow) {
                        m.clusterShow();
                    }
                    if (m.setZIndexOffset) {
                        m.setZIndexOffset(0);
                    }

                    if (stillThereChildCount > 1) {
                        fg.removeLayer(m);
                    }

                    map.removeLayer(m._spiderLeg);
                    delete m._spiderLeg;
                }
                group._animationEnd();
                group.fire('unspiderfied', {
                    cluster: me,
                    markers: childMarkers
                });
            }, 200);
        }
    });


    L.MarkerClusterGroup.include({
        //The MarkerCluster currently spiderfied (if any)
        _spiderfied: null,

        unspiderfy: function () {
            this._unspiderfy.apply(this, arguments);
        },

        _spiderfierOnAdd: function () {
            this._map.on('click', this._unspiderfyWrapper, this);

            if (this._map.options.zoomAnimation) {
                this._map.on('zoomstart', this._unspiderfyZoomStart, this);
            }
            //Browsers without zoomAnimation or a big zoom don't fire zoomstart
            this._map.on('zoomend', this._noanimationUnspiderfy, this);

            if (!L.Browser.touch) {
                this._map.getRenderer(this);
                //Needs to happen in the pageload, not after, or animations don't work in webkit
                //  http://stackoverflow.com/questions/8455200/svg-animate-with-dynamically-added-elements
                //Disable on touch browsers as the animation messes up on a touch zoom and isn't very noticable
            }
        },

        _spiderfierOnRemove: function () {
            this._map.off('click', this._unspiderfyWrapper, this);
            this._map.off('zoomstart', this._unspiderfyZoomStart, this);
            this._map.off('zoomanim', this._unspiderfyZoomAnim, this);
            this._map.off('zoomend', this._noanimationUnspiderfy, this);

            //Ensure that markers are back where they should be
            // Use no animation to avoid a sticky leaflet-cluster-anim class on mapPane
            this._noanimationUnspiderfy();
        },

        //On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)
        //This means we can define the animation they do rather than Markers doing an animation to their actual location
        _unspiderfyZoomStart: function () {
            if (!this._map) { //May have been removed from the map by a zoomEnd handler
                return;
            }

            this._map.on('zoomanim', this._unspiderfyZoomAnim, this);
        },

        _unspiderfyZoomAnim: function (zoomDetails) {
            //Wait until the first zoomanim after the user has finished touch-zooming before running the animation
            if (L.DomUtil.hasClass(this._map._mapPane, 'leaflet-touching')) {
                return;
            }

            this._map.off('zoomanim', this._unspiderfyZoomAnim, this);
            this._unspiderfy(zoomDetails);
        },

        _unspiderfyWrapper: function () {
            /// <summary>_unspiderfy but passes no arguments</summary>
            this._unspiderfy();
        },

        _unspiderfy: function (zoomDetails) {
            if (this._spiderfied) {
                this._spiderfied.unspiderfy(zoomDetails);
            }
        },

        _noanimationUnspiderfy: function () {
            if (this._spiderfied) {
                this._spiderfied._noanimationUnspiderfy();
            }
        },

        //If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc
        _unspiderfyLayer: function (layer) {
            if (layer._spiderLeg) {
                this._featureGroup.removeLayer(layer);

                if (layer.clusterShow) {
                    layer.clusterShow();
                }
                //Position will be fixed up immediately in _animationUnspiderfy
                if (layer.setZIndexOffset) {
                    layer.setZIndexOffset(0);
                }

                this._map.removeLayer(layer._spiderLeg);
                delete layer._spiderLeg;
            }
        }
    });


    /**
     * Adds 1 public method to MCG and 1 to L.Marker to facilitate changing
     * markers' icon options and refreshing their icon and their parent clusters
     * accordingly (case where their iconCreateFunction uses data of childMarkers
     * to make up the cluster icon).
     */


    L.MarkerClusterGroup.include({
        /**
         * Updates the icon of all clusters which are parents of the given marker(s).
         * In singleMarkerMode, also updates the given marker(s) icon.
         * @param layers L.MarkerClusterGroup|L.LayerGroup|Array(L.Marker)|Map(L.Marker)|
         * L.MarkerCluster|L.Marker (optional) list of markers (or single marker) whose parent
         * clusters need to be updated. If not provided, retrieves all child markers of this.
         * @returns {L.MarkerClusterGroup}
         */
        refreshClusters: function (layers) {
            if (!layers) {
                layers = this._topClusterLevel.getAllChildMarkers();
            } else if (layers instanceof L.MarkerClusterGroup) {
                layers = layers._topClusterLevel.getAllChildMarkers();
            } else if (layers instanceof L.LayerGroup) {
                layers = layers._layers;
            } else if (layers instanceof L.MarkerCluster) {
                layers = layers.getAllChildMarkers();
            } else if (layers instanceof L.Marker) {
                layers = [layers];
            } // else: must be an Array(L.Marker)|Map(L.Marker)
            this._flagParentsIconsNeedUpdate(layers);
            this._refreshClustersIcons();

            // In case of singleMarkerMode, also re-draw the markers.
            if (this.options.singleMarkerMode) {
                this._refreshSingleMarkerModeMarkers(layers);
            }

            return this;
        },

        /**
         * Simply flags all parent clusters of the given markers as having a "dirty" icon.
         * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
         * @private
         */
        _flagParentsIconsNeedUpdate: function (layers) {
            var id, parent;

            // Assumes layers is an Array or an Object whose prototype is non-enumerable.
            for (id in layers) {
                // Flag parent clusters' icon as "dirty", all the way up.
                // Dumb process that flags multiple times upper parents, but still
                // much more efficient than trying to be smart and make short lists,
                // at least in the case of a hierarchy following a power law:
                // http://jsperf.com/flag-nodes-in-power-hierarchy/2
                parent = layers[id].__parent;
                while (parent) {
                    parent._iconNeedsUpdate = true;
                    parent = parent.__parent;
                }
            }
        },

        /**
         * Refreshes the icon of all "dirty" visible clusters.
         * Non-visible "dirty" clusters will be updated when they are added to the map.
         * @private
         */
        _refreshClustersIcons: function () {
            this._featureGroup.eachLayer(function (c) {
                if (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {
                    c._updateIcon();
                }
            });
        },

        /**
         * Re-draws the icon of the supplied markers.
         * To be used in singleMarkerMode only.
         * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
         * @private
         */
        _refreshSingleMarkerModeMarkers: function (layers) {
            var id, layer;

            for (id in layers) {
                layer = layers[id];

                // Make sure we do not override markers that do not belong to THIS group.
                if (this.hasLayer(layer)) {
                    // Need to re-create the icon first, then re-draw the marker.
                    layer.setIcon(this._overrideMarkerIcon(layer));
                }
            }
        }
    });

    L.Marker.include({
        /**
         * Updates the given options in the marker's icon and refreshes the marker.
         * @param options map object of icon options.
         * @param directlyRefreshClusters boolean (optional) true to trigger
         * MCG.refreshClustersOf() right away with this single marker.
         * @returns {L.Marker}
         */
        refreshIconOptions: function (options, directlyRefreshClusters) {
            var icon = this.options.icon;

            L.setOptions(icon, options);

            this.setIcon(icon);

            // Shortcut to refresh the associated MCG clusters right away.
            // To be used when refreshing a single marker.
            // Otherwise, better use MCG.refreshClusters() once at the end with
            // the list of modified markers.
            if (directlyRefreshClusters && this.__parent) {
                this.__parent._group.refreshClusters(this);
            }

            return this;
        }
    });


}(window, document));
/*
 * L.NonTiledLayer is an addon for leaflet which renders dynamic image overlays
 */
L.NonTiledLayer = L.Layer.extend({
    includes: L.Mixin.Events,
    options: {
        attribution: '',
        opacity: 1.0,
        zIndex: undefined,
        minZoom: 0,
        maxZoom: 18,
        pointerEvents: null,
        errorImageUrl: 'data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==', //1px transparent GIF
        bounds: L.latLngBounds([-85.05, -180], [85.05, 180])
    },
    url: '',

    // override this method in the inherited class
    //getImageUrl: function (world1, world2, width, height) {},
    //getImageUrlAsync: function (world1, world2, width, height, f) {},

    initialize: function (options) {
        L.setOptions(this, options);
    },

    onAdd: function (map) {
        this._map = map;

        if (!this._div) {
            this._div = L.DomUtil.create('div', 'leaflet-image-layer');
            if (this.options.pointerEvents) {
                this._div.style['pointer-events'] = this.options.pointerEvents;
            }
            if (this.options.zIndex !== undefined) {
                this._div.style.zIndex = this.options.zIndex;
            }
            if (this.options.opacity !== undefined){
                this._div.style.opacity = this.options.opacity;
            }
        }

        this.getPane().appendChild(this._div);

        this._bufferImage = this._initImage();
        this._currentImage = this._initImage();

        this._update();
    },

    onRemove: function (map) {
        this.getPane().removeChild(this._div);

        this._div.removeChild(this._bufferImage);
        this._div.removeChild(this._currentImage);
    },

    addTo: function (map) {
        map.addLayer(this);
        return this;
    },

    getEvents: function () {
        var events = {
            moveend: this._update,
            zoom: this._viewreset
        };

        if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
        }

        return events;
    },

    getElement: function () {
        return this._div;
    },

    setOpacity: function (opacity) {
        this.options.opacity = opacity;
        if (this._div) {
            L.DomUtil.setOpacity(this._div, this.options.opacity);
        }
        return this;
    },

    setZIndex: function (zIndex) {
        if(zIndex){
            this.options.zIndex = zIndex;
            if (this._div) {
                this._div.style.zIndex = zIndex;
            }
        }
        return this;
    },

    // TODO remove bringToFront/bringToBack duplication from TileLayer/Path
    bringToFront: function () {
        if (this._div) {
            this._pane.appendChild(this._div);
        }
        return this;
    },

    bringToBack: function () {
        if (this._div) {
            this._pane.insertBefore(this._div, this._pane.firstChild);
        }
        return this;
    },

    getAttribution: function () {
        return this.options.attribution;
    },

    _initImage: function (_image) {
        var _image = L.DomUtil.create('img', 'leaflet-image-layer');


        this._div.appendChild(_image);

        if (this._map.options.zoomAnimation && L.Browser.any3d) {
            L.DomUtil.addClass(_image, 'leaflet-zoom-animated');
        } else {
            L.DomUtil.addClass(_image, 'leaflet-zoom-hide');
        }



        //TODO createImage util method to remove duplication
        L.extend(_image, {
            galleryimg: 'no',
            onselectstart: L.Util.falseFn,
            onmousemove: L.Util.falseFn,
            onload: L.bind(this._onImageLoad, this),
            onerror: L.bind(this._onImageError, this)
        });

        return _image;
    },

    redraw: function () {
        if (this._map) {
            this._update();
        }
        return this;
    },

    _animateZoom: function (e) {
        if (this._currentImage._bounds)
            this._animateImage(this._currentImage, e);
        if (this._bufferImage._bounds)
            this._animateImage(this._bufferImage, e);
    },

    _animateImage: function (image, e) {
        var scale = this._map.getZoomScale(e.zoom),
            offset = this._map._latLngToNewLayerPoint(image._bounds.getNorthWest(), e.zoom, e.center);

        L.DomUtil.setTransform(image, offset, scale);
    },

    _resetImage: function (image) {
        var bounds = new L.Bounds(
                this._map.latLngToLayerPoint(image._bounds.getNorthWest()),
                this._map.latLngToLayerPoint(image._bounds.getSouthEast())),
            size = bounds.getSize();

        L.DomUtil.setPosition(image, bounds.min);

        image.style.width = size.x + 'px';
        image.style.height = size.y + 'px';
    },

    _getClippedBounds: function () {
        var wgsBounds = this._map.getBounds();

        // truncate bounds to valid wgs bounds
        var mSouth = wgsBounds.getSouth();
        var mNorth = wgsBounds.getNorth();
        var mWest = wgsBounds.getWest();
        var mEast = wgsBounds.getEast();

        var lSouth = this.options.bounds.getSouth();
        var lNorth = this.options.bounds.getNorth();
        var lWest = this.options.bounds.getWest();
        var lEast = this.options.bounds.getEast();

        //mWest = (mWest + 180) % 360 - 180;
        if (mSouth < lSouth) mSouth = lSouth;
        if (mNorth > lNorth) mNorth = lNorth;
        if (mWest < lWest) mWest = lWest;
        if (mEast > lEast) mEast = lEast;

        var world1 = new L.LatLng(mNorth, mWest);
        var world2 = new L.LatLng(mSouth, mEast);

        return new L.LatLngBounds(world1, world2);
    },

    _viewreset: function () {
        if (this._bufferImage._bounds)
            this._resetImage(this._bufferImage);
        if (this._currentImage._bounds)
            this._resetImage(this._currentImage);
    },

    _update: function () {
        if (this._map.getZoom() < this.options.minZoom ||
            this._map.getZoom() > this.options.maxZoom) {
            this._div.style.visibility = 'hidden';
            return;
        }
        else {
            this._div.style.visibility = 'visible';
        }

        if (this._bufferImage._bounds)
            this._resetImage(this._bufferImage);

        var bounds = this._getClippedBounds();

        // re-project to corresponding pixel bounds
        var pix1 = this._map.latLngToContainerPoint(bounds.getNorthWest());
        var pix2 = this._map.latLngToContainerPoint(bounds.getSouthEast());

        // get pixel size
        var width = pix2.x - pix1.x;
        var height = pix2.y - pix1.y;

        // resulting image is too small
        if (width < 32 || height < 32)
            return;

        this._currentImage._bounds = bounds;

        this._resetImage(this._currentImage);

        var i = this._currentImage;
        if (this.getImageUrl)
            i.src = this.getImageUrl(bounds.getNorthWest(), bounds.getSouthEast(), width, height);
        else
            this.getImageUrlAsync(bounds.getNorthWest(), bounds.getSouthEast(), width, height, function (url, tag) {
                i.src = url;
                i.tag = tag;
            });

        this.url = i.src;

        L.DomUtil.setOpacity(this._currentImage, 0);
    },
    _onImageError:function(e){
        this.fire('error', e);
        L.DomUtil.addClass(e.target, 'invalid');
        if(e.target.src !== this.options.errorImageUrl){ // prevent error loop if error image is not valid
            e.target.src = this.options.errorImageUrl;
            this._onImageDone(false, e);
        }
    },
    _onImageLoad:function(e){
        if(e.target.src !== this.options.errorImageUrl){
            L.DomUtil.removeClass(e.target, 'invalid');
            if (e.target.src !== this.url) { // obsolete image
                return;
            }
            this._onImageDone(true, e);
        }
    },
    _onImageDone: function (success, e) {
        L.DomUtil.setOpacity(this._currentImage, 1);
        L.DomUtil.setOpacity(this._bufferImage, 0);

        if (this._addInteraction)
            this._addInteraction(this._currentImage.tag);

        var tmp = this._bufferImage;
        this._bufferImage = this._currentImage;
        this._currentImage = tmp;
        this.fire('load', e);
    }
});

L.nonTiledLayer = function () {
    return new L.NonTiledLayer();
};

/*
 * L.NonTiledLayer.WMS is used for putting WMS non tiled layers on the map.
 */
L.NonTiledLayer.WMS = L.NonTiledLayer.extend({

    defaultWmsParams: {
        service: 'WMS',
        request: 'GetMap',
        version: '1.1.1',
        layers: '',
        styles: '',
        format: 'image/jpeg',
        transparent: false
    },

    options: {
        crs: null,
        uppercase: false
    },

    initialize: function (url, options) { // (String, Object)
        this._wmsUrl = url;

        var wmsParams = L.extend({}, this.defaultWmsParams);

        // all keys that are not NonTiledLayer options go to WMS params
        for (var i in options) {
            if (!L.NonTiledLayer.prototype.options.hasOwnProperty(i) &&
                !L.Layer.prototype.options.hasOwnProperty(i)) {
                wmsParams[i] = options[i];
            }
        }

        this.wmsParams = wmsParams;

        L.setOptions(this, options);
    },

    onAdd: function (map) {

        this._crs = this.options.crs || map.options.crs;
        this._wmsVersion = parseFloat(this.wmsParams.version);

        var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
        this.wmsParams[projectionKey] = this._crs.code;

        L.NonTiledLayer.prototype.onAdd.call(this, map);
    },

    getImageUrl: function (world1, world2, width, height) {
        var wmsParams = this.wmsParams;
        wmsParams.width = width;
        wmsParams.height = height;

        var nw = this._crs.project(world1);
        var se = this._crs.project(world2);

        var url = this._wmsUrl;

        var bbox = bbox = (this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?
            [se.y, nw.x, nw.y, se.x] :
            [nw.x, se.y, se.x, nw.y]).join(',');

        return url +
            L.Util.getParamString(this.wmsParams, url, this.options.uppercase) +
            (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
    },

    setParams: function (params, noRedraw) {

        L.extend(this.wmsParams, params);

        if (!noRedraw) {
            this.redraw();
        }

        return this;
    }
});

L.nonTiledLayer.wms = function (url, options) {
    return new L.NonTiledLayer.WMS(url, options);
};
/**
 * Created by parodi on 02/08/2016.
 */

GV.Util = function () {
    "use strict";

    // Public API
    return {

        /**
         *  Function: getUrlParam
         *
         *  Ritorna il valore di un parametro nella queryString
         *
         *  Parameters:
         *  paramName - {String} Nome del parametro
         *
         *  Returns:
         *  {String} Valore del parametro (se non trovato ritorna 0)
         *
         */

        getUrlParam: function (paramName) {
            var results = new RegExp("[\\?&]" + paramName + "=([^&#]*)").exec(window.location.href);
            GV.Util.log("GV.Util.getUrlParam");

            return results ? decodeURIComponent(results[1]) : null;
        },

        /**
         *  Function: getUrlParam
         *
         *  Ritorna il valore di un parametro nella queryString
         *
         *  Parameters:
         *  url - {String} Stringa contenente la URL
         *  paramName - {String} Nome del parametro
         *
         *  Returns:
         *  {String} Valore del parametro (se non trovato ritorna 0)
         *
         */

        getUrlParamFromString: function (url, paramName) {
            var results = new RegExp("[\\?&]" + paramName + "=([^&#]*)").exec(url);
            if (!results) {
                return 0;
            }
            return results[1] || 0;
        },

        /**
         *  Function: log
         *
         *  Scrive un messaggio sulla console
         *
         *  Parameters:
         *  msg - {String} Messaggio da scrivere
         *
         */

        log: function (message, level) {
            var action = "log";

            if (!GV.debug) {
                return;
            }

            switch (level) {
            case 0:
                action = "warn";
                break;
            case 1:
            case 2:
                action = "error";
                break;
            default:
                action = "info";
                break;
            }

            try {
                console[action](message);
            } catch (e) {
            }
        },

        /**
         *  Function: msgBox
         *
         *  Manda un alert di avviso all'utente
         *
         *  Parameters:
         *  msg - {string} Messaggio da scrivere sull'alert
         *
         */
        msgBox: function (msg) {
            window.alert(msg);
        },


        setUnderscoreTemplate: function () {
            if (_) {
                _.templateSettings = {
                    interpolate: /\{\{(.+?)\}\}/g
                };
            }
        },

        /**
         * Function: getXML
         *
         * Funzione per caricare un oggetto xml remoto
         *
         * Ritorna un oggetto xml
         *
         */
        getXML: function (options, callback) {
            var url = options.url,
                data = options.data,
                method = options.method;

            $.ajax({
                url: url,
                dataType: (GV.Util.isBrowserIE()) ? "text" : "xml",
                data: data,
                method: method || 'GET'
            }).done(function (response) {
                try {
                    var xml = response;
                    if (GV.Util.isBrowserIE()) {    // Only for IE
                        var xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                        xmlDoc.async = "false";
                        xmlDoc.loadXML(response);
                        xml = xmlDoc;
                    }
                    callback(xml);
                } catch (exception) {
                    GV.Util.log(exception,2);
                }
            });

        },

        /**
         * Function: parseXML
         *
         * Funzione per fare il parsing di una stringa xml
         *
         * Ritorna un oggetto doc xml
         *
         * Parameters:
         * xmlString - {String} Stringa xml
         *
         * Returns:
         * {object} Oggetto xmlDoc
         *
         */
        parseXML: function (xmlString) {
            GV.Util.log("GV.Util.parseXML");
            try {
                var xmlDoc = null;
                if (window.DOMParser && window.XSLTProcessor) {
                    var parser = new DOMParser();
                    xmlDoc = parser.parseFromString(xmlString, "text/xml");
                } else {
                    xmlDoc = new ActiveXObject("Msxml2.DOMDocument.3.0");
                    xmlDoc.async = false;
                    xmlDoc.loadXML(xmlString);
                }
                return xmlDoc;
            } catch (exception) {
                GV.Util.log("GV.Util.parseXml: errore parsing xml - " + exception.message,1);
            }
        },


        /**
         *
         * Function: isPointInLig
         *
         * Controlla se un punto appartenga al BBOX del territorio ligure
         *
         * Parameters:
         * x - {number} Coordinata X
         * y - {number} Coordinata Y
         *
         * Returns:
         * {boolean} true/false
         *
         */
        isPointInLig: function (x, y) {
            GV.Util.log("GV.Util.isPointInLig");

            if (!x || !y) {
                return false;
            }

            var minX = 7.4, minY = 43.7, maxX = 10.1, maxY = 44.8;

            return (x > minX) && (x < maxX) && (y > minY) && (y < maxY);
        },

        getParamString: function (obj, existingUrl, uppercase) {
            var params = [];
            for (var i in obj) {
                params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
            }
            return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
        },

        template: function (str, data) {
            var templateRe = /\{ *([\w_\-]+) *\}/g;
            return str.replace(templateRe, function (str, key) {
                var value = data[key];

                if (value === undefined) {
                    throw new Error('No value provided for variable ' + str);

                } else if (typeof value === 'function') {
                    value = value(data);
                }
                return value;
            });
        },

        getZoomFromScaleDenom: function (scaleDenom) {
            return _.findIndex(GV.Globals.BASE_SCALES, function (scale) {
                return scaleDenom > scale;
            });
        },

        getScaleLabelsFromZoom: function (zoom) {
            return GV.Globals.BASE_SCALE_LABELS[zoom]
        },

        getScaleFromZoom: function (zoom) {
            return GV.Globals.BASE_SCALES[zoom]
        },

        endsWith: function (str, suffix) {
            return str.indexOf(suffix, str.length - suffix.length) !== -1;
        },

        isTouch: function () {
            return window.matchMedia('(pointer: coarse)').matches;
        },

        isBrowserIE: function () {
            return navigator.userAgent.indexOf("MSIE ") > 0 || navigator.userAgent.indexOf("Trident") > 0 || navigator.userAgent.indexOf("Edge") > 0;
        }
    };
}();

/**
 * Created by parodi on 19/09/2016.
 */
GV.Buttons.baselayers = function(btnOptions, map) {
    "use strict";

    if (GV.Globals.SMALL_SCREEN) {
        return null;
    }
    return L.control.baseLayersSwitcher(map.baseLayers, [], { position: btnOptions.position}).addTo(map);
};
/**
 * Created by parodi on 19/09/2016.
 */
GV.Buttons.fullscreen = function(btnOptions, map) {
    "use strict";

    return L.control.fullscreen(btnOptions);
};/**
 * Created by parodi on 19/09/2016.
 */
GV.Buttons.geocoder = function(btnOptions, map) {
    "use strict";

    return new L.Control.Geocoder(btnOptions);
};/**
 * Created by parodi on 19/09/2016.
 */
GV.Buttons.legend = function(btnOptions, map) {
    "use strict";

    // costruisco pannello legenda (se passato nelle options del bottone altrimenti costruisco pannello default
    if (btnOptions.buildLegendPanel) {
        btnOptions.buildLegendPanel(btnOptions);
    } else {
        buildLegendPanel(btnOptions);
    }

    var options = _.extend(btnOptions, {
        leafletClasses: true,
        states: [{
            stateName: 'print',
            onClick: function (button, map){
//                $('#gv-legend').fadeIn("slow");
                $('#gv-legend').css({ display: 'block' });
            },
            title: 'Legenda',
            icon: 'ms ms-layers'
        }]
    });

    return L.easyButton(options);

    function buildLegendPanel(btnOptions) {
        // costruisco pannello
        if (btnOptions.type === 'vue') {
        } else {
            GV.app.getContainer().append("<div id='gv-legend' style='display:none;'></div>");
            GV.app.layout.addRegion('legend', '#gv-legend');
            GV.app.layout.getRegion('legend').show(new GV.Views.LegendLayout(btnOptions));
            // nel caso rendo visibile
        }
        if (btnOptions.show && !GV.Globals.SMALL_SCREEN && !GV.Util.isTouch()) {
            $('#gv-legend').css({ display: 'block' });
        }
    }
};/**
 * Created by parodi on 19/09/2016.
 */
GV.Buttons.locate = function(btnOptions, map) {
    "use strict";

    return new L.Control.Locate(btnOptions);
};/**
 * Created by parodi on 19/09/2016.
 */
GV.Buttons.navbar = function(btnOptions, map) {
    "use strict";

    if (GV.Util.isTouch()) {
        return null;
    }
    return L.control.navbar(btnOptions);
};/**
 * Created by parodi on 19/09/2016.
 */
GV.Buttons.print = function(btnOptions, map) {
    "use strict";
    if (GV.Globals.SMALL_SCREEN) {
        return null;
    }

    var options = _.extend(btnOptions, {
        leafletClasses: true,
        states: [{
            stateName: 'print',
            onClick: function (button, map){
                console.log('print');
            },
            title: 'Stampa',
            icon: 'fa-print'
        }]
    });

    return L.easyButton(options);
};/**
 * Created by parodi on 19/09/2016.
 */
GV.Buttons.search = function(btnOptions, map) {
    "use strict";

    var layers = [];
    _.each(btnOptions.layers, function (layerName) {
        layers.push(map.getLayerByName(layerName));
    });
    btnOptions.layer = L.layerGroup(layers);

    return new L.Control.Search(btnOptions);
};/**
 * Created by parodi on 19/09/2016.
 */
GV.Buttons.zoom = function(btnOptions, map) {
    "use strict";
    if (GV.Util.isTouch()) {
        return null;
    }

    return L.control.zoom(btnOptions);
};
Vue.component('gv-iframe-panel', {
    template:
        '<div v-show="visible" :class="cls">' +
            '<div class="gv-panel-title gv-bgcolor">{{title}}<button class="gv-close" type="button" @click="closePanel">Ã</button></div>' +
            '<div><div class="gv-html-panel-body"><iframe id="iframe" :src="src" :height="height" :width="width" style="border: none;" ></iframe></div></div>' +
        '</div>',
    props: ['html', 'src', 'visible', 'cls', 'title', 'width', 'height'],
    methods: {
        closePanel: function() {
            //this.visible = false;
            this.$el.parentNode.removeChild(this.$el);
        }
    },
    mounted: function () {
        if (this.html) {
            this.$el.querySelector('#iframe').contentDocument.body.innerHTML = this.html;
        }
    }
});

Vue.component('gv-legend-layer', {
    template:
    '<li :class="getClass">' +
    '<img class="gv-legend-layer-icon" :src="iconUrl" width="24px" height="24px" @click="showLegendPanel">' +
    '<span class="gv-layer-visibility-span"><input type="checkbox" class="gv-layer-visibility-cb" v-model="layer.visible" @click="setLayerVisible"></span>' +
    '<span class="gv-layer-title-span">{{layer.title}}</span>' +
    '</li>',
    props: ['layer'],
    computed: {
        iconUrl: function() {
            return this.layer.legend.icon;
        },
        getClass: function() {
            return (this.layer.inRange) ? "gv-list-legend-layer-item" : "gv-list-legend-layer-disabled-item";
        }
    },
    methods: {
        setLayerVisible: function(event) {
            this.layer.visible = event.srcElement.checked;
            GV.map.setLayerVisible(this.layer,event.srcElement.checked);
        },
        showLegendPanel: function(event) {
            console.log('showLegendPanel');
            var layerConfig = this.layer;
            //if (layerConfig.inRange && (layerConfig.multiClasse || layerConfig.legend.popUpFlag)) {
            if ((layerConfig.multiClasse || layerConfig.legend.popUpFlag)) {
                var url = null, html = null, width, height;
                if (layerConfig.legend.popUpUrl && layerConfig.legend.popUpFlag) {
                    // se impostato attributo legendPopupUrl apro una finestra con il documento
                    url = layerConfig.legend.popUpUrl;
                    width = (GV.Util.SMALL_SCREEN) ? 400 : 600;
                    height = (GV.Util.SMALL_SCREEN) ? 400 : 600;
                } else if (layerConfig.multiClasse) {
                    // se livello multiclasse apro una finestra con la legenda dei livelli multiclasse
                    if (layerConfig.flagGeoserver) {
                        url = layerConfig.wmsParams.url + "LAYER=" + layerConfig.name + "&REQUEST=GetLegendGraphic&VERSION=1.0.0&FORMAT=image/png&WIDTH=20&HEIGHT=20&";
                        width = 400;
                        height = 350;
                    } else {
                        var classes = layerConfig.classes;
                        html = '<table width=100% border=0>';
                        _.each(classes, function (cls) {
                            html += '<tr>';
                            html += '<td width=30><img src="' + cls.legendIcon + '"></td>';
                            html += '<td >' + cls.legendLabel + '</td>';
                            html += '</tr>';
                        });
                        html += '</table>';
                    }
                }


                var vm = new Vue({
                    template:
                        '<gv-iframe-panel visible="true" :src="src" :html="html" :height="height" :width="width" :cls="cls" :title="title"></gv-iframe-panel-body>' ,
                    data: {
                        title: 'LEGENDA - ' + layerConfig.legend.label,
                        src: url,
                        html: html,
                        width: width,
                        height: height,
                        cls: "draggable gv-legend-multi"
                    },
                    created: function() {
                        $("#gv-container").append("<div id='gv-legend-multi'></div>");
                    }
                });
                vm.$mount("#gv-legend-multi");

/*
                new GV.IFramePanel({
                    el: '#gv-legend-multi',
                    data: {
                        title: 'LEGENDA - ' + layerConfig.legend.label,
                        src: url,
                        html: html,
                        width: width,
                        height: height,
                        cls: "draggable",
                        visible: true
                    }
                });
*/

            }
        }
    }
});


Vue.component('gv-legend-map', {
    template:
    '<ul class="gv-list-group">' +
        '<li class="gv-list-legend-map-item">{{map.name}}' +
            '<a v-show="showInfoMap" class="gv-legend-map-info ms ms-information" title="Scheda metadati" href="" target="_blank"></a>' +
        '</li>' +
        '<ul class="gv-list-group">' +
            '<gv-legend-layer v-for="layer in map.layers" :layer="layer" ></gv-legend-layer>' +
        '</ul>' +
    '</ul>',
    props: ['showInfoMap', 'map']
});


Vue.component('gv-legend', {
    template:
        '<div id="gv-legend">' +
            '<div id="gv-legend-title">' +
                '<div class="gv-panel-title gv-bgcolor">' +
                '<b>LEGENDA</b>' +
                    '<button class="gv-close" type="button" @click="hideLegend">Ã</button>' +
                    '<button v-show="showAddMap" class="gv-legend-add ms ms-layers-add" title="Aggiungi Mappa" type="button"></button>' +
                '</div>' +
            '</div>' +
            '<div id="gv-legend-body">' +
                '<gv-legend-map v-for="map in maps" :map="map" :showInfoMap="showInfoMap" ></gv-legend-map>' +
            '</div>' +
        '</div>',
    props: ['showAddMap', 'showInfoMap', 'maps'],
    methods: {
        hideLegend: function(event) {
            $('#gv-legend').css({display: 'none'});
            $('#gv-legend-button').css({display: 'block'});
        }
    }
});
Vue.component('gv-map', {
    template: '<div id= "gv-map"></div>',
    props: ['options', 'maps'],
    mounted: function() {
        console.log('gv-map mounted', this.options);
        this.map = new GV.Map(this.options);
        GV.map = this.map;
        if (this.map && this.map.loadBaseLayers) {
            this.map.loadBaseLayers(this.options.config.baseLayers);
        }
        // aggiungo controlli
        if (this.map && this.map.loadControls) {
            this.map.loadControls(this.options);
        }
    },
    created: function () {
        console.log('gv-map created ');
    },
    beforeUpdate: function() {
        console.log('gv-map update ', this.maps);
    },
    methods: {
    }
});

L.Control.BaseLayersSwitcher = L.Control.extend({
    // @section
    // @aka Control.Layers options
    options: {
        // @option collapsed: Boolean = true
        // If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
        collapsed: true,
        position: 'topright',

        // @option autoZIndex: Boolean = true
        // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
        autoZIndex: true,

        // @option hideSingleBase: Boolean = false
        // If `true`, the base layers in the control will be hidden when there is only one.
        hideSingleBase: false
    },

    initialize: function (baseLayers, overlays, options) {
        L.setOptions(this, options);

        this._layers = [];
        this._lastZIndex = 0;
        this._handlingClick = false;

        for (var i in baseLayers) {
            this._addLayer(baseLayers[i], i);
        }

        for (i in overlays) {
            this._addLayer(overlays[i], i, true);
        }
    },

    onAdd: function (map) {
        this._initLayout();
        this._update();

        this._map = map;
        map.on('zoomend', this._checkDisabledLayers, this);

        return this._container;
    },

    onRemove: function () {
        this._map.off('zoomend', this._checkDisabledLayers, this);

        for (var i = 0; i < this._layers.length; i++) {
            this._layers[i].layer.off('add remove', this._onLayerChange, this);
        }
    },

    // @method addBaseLayer(layer: Layer, name: String): this
    // Adds a base layer (radio button entry) with the given name to the control.
    addBaseLayer: function (layer, name) {
        this._addLayer(layer, name);
        return (this._map) ? this._update() : this;
    },

    // @method addOverlay(layer: Layer, name: String): this
    // Adds an overlay (checkbox entry) with the given name to the control.
    addOverlay: function (layer, name) {
        this._addLayer(layer, name, true);
        return (this._map) ? this._update() : this;
    },

    // @method removeLayer(layer: Layer): this
    // Remove the given layer from the control.
    removeLayer: function (layer) {
        layer.off('add remove', this._onLayerChange, this);

        var obj = this._getLayer(L.stamp(layer));
        if (obj) {
            this._layers.splice(this._layers.indexOf(obj), 1);
        }
        return (this._map) ? this._update() : this;
    },

    // @method expand(): this
    // Expand the control container if collapsed.
    expand: function () {
        L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
        this._form.style.height = null;
        var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
        if (acceptableHeight < this._form.clientHeight) {
            L.DomUtil.addClass(this._form, 'leaflet-control-layers-scrollbar');
            this._form.style.height = acceptableHeight + 'px';
        } else {
            L.DomUtil.removeClass(this._form, 'leaflet-control-layers-scrollbar');
        }
        this._checkDisabledLayers();
        return this;
    },

    // @method collapse(): this
    // Collapse the control container if expanded.
    collapse: function () {
        L.DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');
        return this;
    },

    _initLayout: function () {
        //ms ms-globe
        var className = 'leaflet-control-layers',
            container = this._container = L.DomUtil.create('div', className);

        // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
        container.setAttribute('aria-haspopup', true);

        L.DomEvent.disableClickPropagation(container);
        if (!L.Browser.touch) {
            L.DomEvent.disableScrollPropagation(container);
        }

        var form = this._form = L.DomUtil.create('form', className + '-list');

        if (this.options.collapsed) {
            if (!L.Browser.android) {
                L.DomEvent.on(container, {
                    mouseenter: this.expand,
                    mouseleave: this.collapse
                }, this);
            }

            var link = this._layersLink = L.DomUtil.create('a', 'ms ms-globe ' + className + '-toggle', container);
            link.href = '#';
            link.title = 'Layers';

            if (L.Browser.touch) {
                L.DomEvent
                    .on(link, 'click', L.DomEvent.stop)
                    .on(link, 'click', this.expand, this);
            } else {
                L.DomEvent.on(link, 'focus', this.expand, this);
            }

            // work around for Firefox Android issue https://github.com/Leaflet/Leaflet/issues/2033
            L.DomEvent.on(form, 'click', function () {
                setTimeout(L.bind(this._onInputClick, this), 0);
            }, this);

            this._map.on('click', this.collapse, this);
            // TODO keyboard accessibility
        } else {
            this.expand();
        }

        this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
        this._separator = L.DomUtil.create('div', className + '-separator', form);
        this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

        container.appendChild(form);
    },

    _getLayer: function (id) {
        for (var i = 0; i < this._layers.length; i++) {

            if (this._layers[i] && L.stamp(this._layers[i].layer) === id) {
                return this._layers[i];
            }
        }
    },

    _addLayer: function (layer, name, overlay) {
        layer.on('add remove', this._onLayerChange, this);

        this._layers.push({
            layer: layer,
            name: name,
            overlay: overlay
        });

        if (this.options.autoZIndex && layer.setZIndex) {
            this._lastZIndex++;
            layer.setZIndex(this._lastZIndex);
        }
    },

    _update: function () {
        if (!this._container) { return this; }

        L.DomUtil.empty(this._baseLayersList);
        L.DomUtil.empty(this._overlaysList);

        var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

        for (i = 0; i < this._layers.length; i++) {
            obj = this._layers[i];
            this._addItem(obj);
            overlaysPresent = overlaysPresent || obj.overlay;
            baseLayersPresent = baseLayersPresent || !obj.overlay;
            baseLayersCount += !obj.overlay ? 1 : 0;
        }

        // Hide base layers section if there's only one layer.
        if (this.options.hideSingleBase) {
            baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
            this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
        }

        this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

        return this;
    },

    _onLayerChange: function (e) {
        if (!this._handlingClick) {
            this._update();
        }

        var obj = this._getLayer(L.stamp(e.target));

        // @namespace Map
        // @section Layer events
        // @event baselayerchange: LayersControlEvent
        // Fired when the base layer is changed through the [layer control](#control-layers).
        // @event overlayadd: LayersControlEvent
        // Fired when an overlay is selected through the [layer control](#control-layers).
        // @event overlayremove: LayersControlEvent
        // Fired when an overlay is deselected through the [layer control](#control-layers).
        // @namespace Control.Layers
        var type = obj.overlay ?
            (e.type === 'add' ? 'overlayadd' : 'overlayremove') :
            (e.type === 'add' ? 'baselayerchange' : null);

        if (type) {
            this._map.fire(type, obj);
        }
    },

    // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
    _createRadioElement: function (name, checked) {

        var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
            name + '"' + (checked ? ' checked="checked"' : '') + '/>';

        var radioFragment = document.createElement('div');
        radioFragment.innerHTML = radioHtml;

        return radioFragment.firstChild;
    },

    _addItem: function (obj) {
        var label = document.createElement('label'),
            checked = this._map.hasLayer(obj.layer),
            input;

        if (obj.overlay) {
            input = document.createElement('input');
            input.type = 'checkbox';
            input.className = 'leaflet-control-layers-selector';
            input.defaultChecked = checked;
        } else {
            input = this._createRadioElement('leaflet-base-layers', checked);
        }

        input.layerId = L.stamp(obj.layer);

        L.DomEvent.on(input, 'click', this._onInputClick, this);

        var name = document.createElement('span');
        name.innerHTML = '&nbsp;&nbsp' + obj.name;

        // Helps from preventing layer control flicker when checkboxes are disabled
        // https://github.com/Leaflet/Leaflet/issues/2771
        var holder = document.createElement('div');

        label.appendChild(holder);
        holder.appendChild(input);
        holder.appendChild(name);

        var container = obj.overlay ? this._overlaysList : this._baseLayersList;
        container.appendChild(label);

        this._checkDisabledLayers();
        return label;
    },

    _onInputClick: function () {
        var inputs = this._form.getElementsByTagName('input'),
            input, layer, hasLayer;
        var addedLayers = [],
            removedLayers = [];

        this._handlingClick = true;

        for (var i = inputs.length - 1; i >= 0; i--) {
            input = inputs[i];
            layer = this._getLayer(input.layerId).layer;
            hasLayer = this._map.hasLayer(layer);

            if (input.checked && !hasLayer) {
                addedLayers.push(layer);

            } else if (!input.checked && hasLayer) {
                removedLayers.push(layer);
            }
        }

        // Bugfix issue 2318: Should remove all old layers before readding new ones
        for (i = 0; i < removedLayers.length; i++) {
            this._map.removeLayer(removedLayers[i]);
        }
        for (i = 0; i < addedLayers.length; i++) {
            this._map.addLayer(addedLayers[i]);
        }

        this._handlingClick = false;

        this._refocusOnMap();
    },

    _checkDisabledLayers: function () {
        var inputs = this._form.getElementsByTagName('input'),
            input,
            layer,
            zoom = this._map.getZoom();

        for (var i = inputs.length - 1; i >= 0; i--) {
            input = inputs[i];
            layer = this._getLayer(input.layerId).layer;
            input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
            (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

        }
    },

    _expand: function () {
        // Backward compatibility, remove me in 1.1.
        return this.expand();
    },

    _collapse: function () {
        // Backward compatibility, remove me in 1.1.
        return this.collapse();
    }

});


// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
// Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
L.control.baseLayersSwitcher = function (baseLayers, overlays, options) {
    return new L.Control.BaseLayersSwitcher(baseLayers, overlays, options);
};

(function(){

// This is for grouping buttons into a bar
// takes an array of `L.easyButton`s and
// then the usual `.addTo(map)`
    L.Control.EasyBar = L.Control.extend({

        options: {
            position:       'topleft',  // part of leaflet's defaults
            id:             null,       // an id to tag the Bar with
            leafletClasses: true        // use leaflet classes?
        },


        initialize: function(buttons, options){

            if(options){
                L.Util.setOptions( this, options );
            }

            this._buildContainer();
            this._buttons = [];

            for(var i = 0; i < buttons.length; i++){
                buttons[i]._bar = this;
                buttons[i]._container = buttons[i].button;
                this._buttons.push(buttons[i]);
                this.container.appendChild(buttons[i].button);
            }

        },


        _buildContainer: function(){
            this._container = this.container = L.DomUtil.create('div', '');
            this.options.leafletClasses && L.DomUtil.addClass(this.container, 'leaflet-bar easy-button-container leaflet-control');
            this.options.id && (this.container.id = this.options.id);
        },


        enable: function(){
            L.DomUtil.addClass(this.container, 'enabled');
            L.DomUtil.removeClass(this.container, 'disabled');
            this.container.setAttribute('aria-hidden', 'false');
            return this;
        },


        disable: function(){
            L.DomUtil.addClass(this.container, 'disabled');
            L.DomUtil.removeClass(this.container, 'enabled');
            this.container.setAttribute('aria-hidden', 'true');
            return this;
        },


        onAdd: function () {
            return this.container;
        },

        addTo: function (map) {
            this._map = map;

            for(var i = 0; i < this._buttons.length; i++){
                this._buttons[i]._map = map;
            }

            var container = this._container = this.onAdd(map),
                pos = this.getPosition(),
                corner = map._controlCorners[pos];

            L.DomUtil.addClass(container, 'leaflet-control');

            if (pos.indexOf('bottom') !== -1) {
                corner.insertBefore(container, corner.firstChild);
            } else {
                corner.appendChild(container);
            }

            return this;
        }

    });

    L.easyBar = function(){
        var args = [L.Control.EasyBar];
        for(var i = 0; i < arguments.length; i++){
            args.push( arguments[i] );
        }
        return new (Function.prototype.bind.apply(L.Control.EasyBar, args));
    };

// L.EasyButton is the actual buttons
// can be called without being grouped into a bar
    L.Control.EasyButton = L.Control.extend({

        options: {
            position:  'topleft',       // part of leaflet's defaults

            id:        null,            // an id to tag the button with

            type:      'replace',       // [(replace|animate)]
                                        // replace swaps out elements
                                        // animate changes classes with all elements inserted

            states:    [],              // state names look like this
                                        // {
                                        //   stateName: 'untracked',
                                        //   onClick: function(){ handle_nav_manually(); };
                                        //   title: 'click to make inactive',
                                        //   icon: 'fa-circle',    // wrapped with <a>
                                        // }

            leafletClasses:   true,     // use leaflet styles for the button
            tagName:          'button'
        },



        initialize: function(icon, onClick, title, id){

            // clear the states manually
            this.options.states = [];

            // add id to options
            if(id != null){
                this.options.id = id;
            }

            // storage between state functions
            this.storage = {};

            // is the last item an object?
            if( typeof arguments[arguments.length-1] === 'object' ){

                // if so, it should be the options
                L.Util.setOptions( this, arguments[arguments.length-1] );
            }

            // if there aren't any states in options
            // use the early params
            if( this.options.states.length === 0 &&
                typeof icon  === 'string' &&
                typeof onClick === 'function'){

                // turn the options object into a state
                this.options.states.push({
                    icon: icon,
                    onClick: onClick,
                    title: typeof title === 'string' ? title : ''
                });
            }

            // curate and move user's states into
            // the _states for internal use
            this._states = [];

            for(var i = 0; i < this.options.states.length; i++){
                this._states.push( new State(this.options.states[i], this) );
            }

            this._buildButton();

            this._activateState(this._states[0]);

        },

        _buildButton: function(){

            this.button = L.DomUtil.create(this.options.tagName, '');

            // the next three if statements should be collapsed into the options
            // when it's time for breaking changes.
            if (this.tagName === 'button') {
                this.button.type = 'button';
            }

            if (this.options.id ){
                this.button.id = this.options.id;
            }

            if (this.options.leafletClasses){
                L.DomUtil.addClass(this.button, 'leaflet-bar-part leaflet-interactive easy-button gv-bgcolor');
            }

            // don't let double clicks and mousedown get to the map
            L.DomEvent.addListener(this.button, 'dblclick', L.DomEvent.stop);
            L.DomEvent.addListener(this.button, 'mousedown', L.DomEvent.stop);

            // take care of normal clicks
            L.DomEvent.addListener(this.button,'click', function(e){
                L.DomEvent.stop(e);
                this._currentState.onClick(this, this._map ? this._map : null );
                this._map.getContainer().focus();
            }, this);

            // prep the contents of the control
            if(this.options.type == 'replace'){
                this.button.appendChild(this._currentState.icon);
            } else {
                for(var i=0;i<this._states.length;i++){
                    this.button.appendChild(this._states[i].icon);
                }
            }
        },


        _currentState: {
            // placeholder content
            stateName: 'unnamed',
            icon: (function(){ return document.createElement('span'); })()
        },



        _states: null, // populated on init



        state: function(newState){

            // activate by name
            if(typeof newState == 'string'){

                this._activateStateNamed(newState);

                // activate by index
            } else if (typeof newState == 'number'){

                this._activateState(this._states[newState]);
            }

            return this;
        },


        _activateStateNamed: function(stateName){
            for(var i = 0; i < this._states.length; i++){
                if( this._states[i].stateName == stateName ){
                    this._activateState( this._states[i] );
                }
            }
        },

        _activateState: function(newState){

            if( newState === this._currentState ){

                // don't touch the dom if it'll just be the same after
                return;

            } else {

                // swap out elements... if you're into that kind of thing
                if( this.options.type == 'replace' ){
                    this.button.appendChild(newState.icon);
                    this.button.removeChild(this._currentState.icon);
                }

                if( newState.title ){
                    this.button.title = newState.title;
                } else {
                    this.button.removeAttribute('title');
                }

                // update classes for animations
                for(var i=0;i<this._states.length;i++){
                    L.DomUtil.removeClass(this._states[i].icon, this._currentState.stateName + '-active');
                    L.DomUtil.addClass(this._states[i].icon, newState.stateName + '-active');
                }

                // update classes for animations
                L.DomUtil.removeClass(this.button, this._currentState.stateName + '-active');
                L.DomUtil.addClass(this.button, newState.stateName + '-active');

                // update the record
                this._currentState = newState;

            }
        },



        enable: function(){
            L.DomUtil.addClass(this.button, 'enabled');
            L.DomUtil.removeClass(this.button, 'disabled');
            this.button.setAttribute('aria-hidden', 'false');
            return this;
        },



        disable: function(){
            L.DomUtil.addClass(this.button, 'disabled');
            L.DomUtil.removeClass(this.button, 'enabled');
            this.button.setAttribute('aria-hidden', 'true');
            return this;
        },


        removeFrom: function (map) {

            this._container.parentNode.removeChild(this._container);
            this._map = null;

            return this;
        },

        onAdd: function(){
            var containerObj = L.easyBar([this], {
                position: this.options.position,
                leafletClasses: this.options.leafletClasses
            });
            this._container = containerObj.container;
            return this._container;
        }


    });

    L.easyButton = function(/* args will pass automatically */){
        var args = Array.prototype.concat.apply([L.Control.EasyButton],arguments);
        return new (Function.prototype.bind.apply(L.Control.EasyButton, args));
    };

    /*************************
     *
     * util functions
     *
     *************************/

// constructor for states so only curated
// states end up getting called
    function State(template, easyButton){

        this.title = template.title;
        this.stateName = template.stateName ? template.stateName : 'unnamed-state';

        // build the wrapper
        this.icon = L.DomUtil.create('span', '');

        L.DomUtil.addClass(this.icon, 'button-state state-' + this.stateName.replace(/(^\s*|\s*$)/g,''));
        this.icon.innerHTML = buildIcon(template.icon);
        this.onClick = L.Util.bind(template.onClick?template.onClick:function(){}, easyButton);
    }

    function buildIcon(ambiguousIconString) {

        var tmpIcon;

        // does this look like html? (i.e. not a class)
        if( ambiguousIconString.match(/[&;=<>"']/) ){

            // if so, the user should have put in html
            // so move forward as such
            tmpIcon = ambiguousIconString;

            // then it wasn't html, so
            // it's a class list, figure out what kind
        } else {
            ambiguousIconString = ambiguousIconString.replace(/(^\s*|\s*$)/g,'');
            tmpIcon = L.DomUtil.create('span', '');

            if( ambiguousIconString.indexOf('fa-') === 0 ){
                L.DomUtil.addClass(tmpIcon, 'fa '  + ambiguousIconString)
            } else if ( ambiguousIconString.indexOf('glyphicon-') === 0 ) {
                L.DomUtil.addClass(tmpIcon, 'glyphicon ' + ambiguousIconString)
            } else {
                L.DomUtil.addClass(tmpIcon, /*rollwithit*/ ambiguousIconString)
            }

            // make this a string so that it's easy to set innerHTML below
            tmpIcon = tmpIcon.outerHTML;
        }

        return tmpIcon;
    }

})();L.Control.Fullscreen = L.Control.extend({
    options: {
        position: 'topleft',
        title: {
            'false': 'Schermo intero',
            'true': 'Esci da Schermo intero'
        }
    },

    onAdd: function (map) {
        var container = L.DomUtil.create('div', 'leaflet-control-fullscreen leaflet-bar leaflet-control');

        this.link = L.DomUtil.create('a', 'ms ms-max-extent', container);
        this.link.href = '#';

        this._map = map;
        this._map.on('fullscreenchange', this._toggleTitle, this);
        this._toggleTitle();

        L.DomEvent.on(this.link, 'click', this._click, this);

        return container;
    },

    _click: function (e) {
        L.DomEvent.stopPropagation(e);
        L.DomEvent.preventDefault(e);
        this._map.toggleFullscreen(this.options);
    },

    _toggleTitle: function() {
        this.link.title = this.options.title[this._map.isFullscreen()];
    }
});

L.Map.include({
    isFullscreen: function () {
        return this._isFullscreen || false;
    },

    toggleFullscreen: function (options) {
        var container = this.getContainer();
        if (this.isFullscreen()) {
            if (options && options.pseudoFullscreen) {
                this._disablePseudoFullscreen(container);
            } else if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.webkitCancelFullScreen) {
                document.webkitCancelFullScreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            } else {
                this._disablePseudoFullscreen(container);
            }
        } else {
            if (options && options.pseudoFullscreen) {
                this._enablePseudoFullscreen(container);
            } else if (container.requestFullscreen) {
                container.requestFullscreen();
            } else if (container.mozRequestFullScreen) {
                container.mozRequestFullScreen();
            } else if (container.webkitRequestFullscreen) {
                container.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            } else if (container.msRequestFullscreen) {
                container.msRequestFullscreen();
            } else {
                this._enablePseudoFullscreen(container);
            }
        }

    },

    _enablePseudoFullscreen: function (container) {
        L.DomUtil.addClass(container, 'leaflet-pseudo-fullscreen');
        this._setFullscreen(true);
        this.invalidateSize();
        this.fire('fullscreenchange');
    },

    _disablePseudoFullscreen: function (container) {
        L.DomUtil.removeClass(container, 'leaflet-pseudo-fullscreen');
        this._setFullscreen(false);
        this.invalidateSize();
        this.fire('fullscreenchange');
    },

    _setFullscreen: function(fullscreen) {
        this._isFullscreen = fullscreen;
        var container = this.getContainer();
        if (fullscreen) {
            L.DomUtil.addClass(container, 'leaflet-fullscreen-on');
        } else {
            L.DomUtil.removeClass(container, 'leaflet-fullscreen-on');
        }
    },

    _onFullscreenChange: function (e) {
        var fullscreenElement =
            document.fullscreenElement ||
            document.mozFullScreenElement ||
            document.webkitFullscreenElement ||
            document.msFullscreenElement;

        if (fullscreenElement === this.getContainer() && !this._isFullscreen) {
            this._setFullscreen(true);
            this.fire('fullscreenchange');
        } else if (fullscreenElement !== this.getContainer() && this._isFullscreen) {
            this._setFullscreen(false);
            this.fire('fullscreenchange');
        }
    }
});

L.Map.mergeOptions({
    fullscreenControl: false
});

L.Map.addInitHook(function () {
    if (this.options.fullscreenControl) {
        this.fullscreenControl = new L.Control.Fullscreen(this.options.fullscreenControl);
        this.addControl(this.fullscreenControl);
    }

    var fullscreenchange;

    if ('onfullscreenchange' in document) {
        fullscreenchange = 'fullscreenchange';
    } else if ('onmozfullscreenchange' in document) {
        fullscreenchange = 'mozfullscreenchange';
    } else if ('onwebkitfullscreenchange' in document) {
        fullscreenchange = 'webkitfullscreenchange';
    } else if ('onmsfullscreenchange' in document) {
        fullscreenchange = 'MSFullscreenChange';
    }

    if (fullscreenchange) {
        var onFullscreenChange = L.bind(this._onFullscreenChange, this);

        this.whenReady(function () {
            L.DomEvent.on(document, fullscreenchange, onFullscreenChange);
        });

        this.on('unload', function () {
            L.DomEvent.off(document, fullscreenchange, onFullscreenChange);
        });
    }
});

L.control.fullscreen = function (options) {
    return new L.Control.Fullscreen(options);
};
(function () {
    'use strict';
    L.Control.Geocoder = L.Control.extend({
        options: {
            showResultIcons: false,
            collapsed: true,
            expand: 'click',
            position: 'topright',
            placeholder: 'Ricerca Indirizzo...',
            errorMessage: 'Non trovato.'
        },

        _callbackId: 0,

        initialize: function (options) {
            L.Util.setOptions(this, options);
            if (!this.options.geocoder) {
                this.options.geocoder = new L.Control.Geocoder.Nominatim();
            }
        },

        onAdd: function (map) {
            var className = 'leaflet-control-geocoder',
                container = L.DomUtil.create('div', className + ' leaflet-bar'),
                icon = L.DomUtil.create('a', 'ms ms-zoom', container),
                form = this._form = L.DomUtil.create('form', className + '-form', container),
                input;

            icon.innerHTML = '';
            icon.href = 'javascript:void(0);';
            this._map = map;
            this._container = container;
            input = this._input = L.DomUtil.create('input');
            input.type = 'text';
            input.placeholder = this.options.placeholder;

            L.DomEvent.addListener(input, 'keydown', this._keydown, this);
            //L.DomEvent.addListener(input, 'onpaste', this._clearResults, this);
            //L.DomEvent.addListener(input, 'oninput', this._clearResults, this);

            this._errorElement = document.createElement('div');
            this._errorElement.className = className + '-form-no-error';
            this._errorElement.innerHTML = this.options.errorMessage;

            this._alts = L.DomUtil.create('ul', className + '-alternatives leaflet-control-geocoder-alternatives-minimized');

            form.appendChild(input);
            this._container.appendChild(this._errorElement);
            container.appendChild(this._alts);

            L.DomEvent.addListener(form, 'submit', this._geocode, this);

            if (this.options.collapsed) {
                if (this.options.expand === 'click') {
                    L.DomEvent.addListener(icon, 'click', function(e) {
                        // TODO: touch
                        if (e.button === 0 && e.detail !== 2) {
                            this._toggle();
                        }
                    }, this);
                } else {
                    L.DomEvent.addListener(icon, 'mouseover', this._expand, this);
                    L.DomEvent.addListener(icon, 'mouseout', this._collapse, this);
                    this._map.on('movestart', this._collapse, this);
                }
            } else {
                L.DomEvent.addListener(icon, 'click', function(e) {
                    this._geocode(e);
                }, this);
                this._expand();
            }

            L.DomEvent.disableClickPropagation(container);

            return container;
        },

        _geocodeResult: function (results) {
            L.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-throbber');
            if (results.length === 1) {
                this._geocodeResultSelected(results[0]);
            } else if (results.length > 0) {
                this._alts.innerHTML = '';
                this._results = results;
                L.DomUtil.removeClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');
                for (var i = 0; i < results.length; i++) {
                    this._alts.appendChild(this._createAlt(results[i], i));
                }
            } else {
                L.DomUtil.addClass(this._errorElement, 'leaflet-control-geocoder-error');
            }
        },

        markGeocode: function(result) {
            this._map.fitBounds(result.bbox);
            this._map.setZoom(16);

            if (this._geocodeMarker) {
                this._map.removeLayer(this._geocodeMarker);
            }

            this._geocodeMarker = new L.Marker(result.center)
                .bindPopup(result.html || result.name)
                .addTo(this._map)
                .openPopup();

            return this;
        },

        _geocode: function(event) {
            L.DomEvent.preventDefault(event);

            L.DomUtil.addClass(this._container, 'leaflet-control-geocoder-throbber');
            this._clearResults();
            this.options.geocoder.geocode(this._input.value, this._geocodeResult, this);

            return false;
        },

        _geocodeResultSelected: function(result) {
            if (this.options.collapsed) {
                this._collapse();
            } else {
                this._clearResults();
            }
            this.markGeocode(result);
        },

        _toggle: function() {
            if (this._container.className.indexOf('leaflet-control-geocoder-expanded') >= 0) {
                this._collapse();
            } else {
                this._expand();
            }
        },

        _expand: function () {
            L.DomUtil.addClass(this._container, 'leaflet-control-geocoder-expanded');
            this._input.select();
        },

        _collapse: function () {
            this._container.className = this._container.className.replace(' leaflet-control-geocoder-expanded', '');
            L.DomUtil.addClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');
            L.DomUtil.removeClass(this._errorElement, 'leaflet-control-geocoder-error');
        },

        _clearResults: function () {
            L.DomUtil.addClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');
            this._selection = null;
            L.DomUtil.removeClass(this._errorElement, 'leaflet-control-geocoder-error');
        },

        _createAlt: function(result, index) {
            var li = L.DomUtil.create('li', ''),
                a = L.DomUtil.create('a', '', li),
                icon = this.options.showResultIcons && result.icon ? L.DomUtil.create('img', '', a) : null,
                text = result.html ? undefined : document.createTextNode(result.name),
                clickHandler = function clickHandler(e) {
                    L.DomEvent.preventDefault(e);
                    this._geocodeResultSelected(result);
                };

            if (icon) {
                icon.src = result.icon;
            }

            li.setAttribute('data-result-index', index);

            if (result.html) {
                a.innerHTML = result.html;
            } else {
                a.appendChild(text);
            }

            L.DomEvent.addListener(li, 'click', clickHandler, this);

            return li;
        },

        _keydown: function(e) {
            var _this = this,
                select = function select(dir) {
                    if (_this._selection) {
                        L.DomUtil.removeClass(_this._selection, 'leaflet-control-geocoder-selected');
                        _this._selection = _this._selection[dir > 0 ? 'nextSibling' : 'previousSibling'];
                    }
                    if (!_this._selection) {
                        _this._selection = _this._alts[dir > 0 ? 'firstChild' : 'lastChild'];
                    }

                    if (_this._selection) {
                        L.DomUtil.addClass(_this._selection, 'leaflet-control-geocoder-selected');
                    }
                };

            switch (e.keyCode) {
                // Escape
                case 27:
                    if (this.options.collapsed) {
                        this._collapse();
                    }
                    break;
                // Up
                case 38:
                    select(-1);
                    L.DomEvent.preventDefault(e);
                    break;
                // Up
                case 40:
                    select(1);
                    L.DomEvent.preventDefault(e);
                    break;
                // Enter
                case 13:
                    if (this._selection) {
                        var index = parseInt(this._selection.getAttribute('data-result-index'), 10);
                        this._geocodeResultSelected(this._results[index]);
                        this._clearResults();
                        L.DomEvent.preventDefault(e);
                    }
            }
            return true;
        }
    });

    L.Control.geocoder = function(options) {
        return new L.Control.Geocoder(options);
    };

    L.Control.Geocoder.callbackId = 0;

    L.Control.Geocoder.jsonp = function(url, params, callback, context, jsonpParam) {
        var callbackId = '_l_geocoder_' + (L.Control.Geocoder.callbackId++);
        params[jsonpParam || 'callback'] = callbackId;
        window[callbackId] = L.Util.bind(callback, context);
        var script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = url + L.Util.getParamString(params);
        script.id = callbackId;
        document.getElementsByTagName('head')[0].appendChild(script);
    };

    L.Control.Geocoder.getJSON = function(url, params, callback) {
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = function () {
            if (xmlHttp.readyState != 4){
                return;
            }
            if (xmlHttp.status != 200 && xmlHttp.status != 304){
                callback('');
                return;
            }
            callback(JSON.parse(xmlHttp.response));
        };
        xmlHttp.open( "GET", url + L.Util.getParamString(params), true);
        xmlHttp.setRequestHeader("Accept", "application/json");
        xmlHttp.send(null);
    };

    L.Control.Geocoder.template = function (str, data, htmlEscape) {
        return str.replace(/\{ *([\w_]+) *\}/g, function (str, key) {
            var value = data[key];
            if (value === undefined) {
                value = '';
            } else if (typeof value === 'function') {
                value = value(data);
            }
            return L.Control.Geocoder.htmlEscape(value);
        });
    };

    // Adapted from handlebars.js
    // https://github.com/wycats/handlebars.js/
    L.Control.Geocoder.htmlEscape = (function() {
        var badChars = /[&<>"'`]/g;
        var possible = /[&<>"'`]/;
        var escape = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            '\'': '&#x27;',
            '`': '&#x60;'
        };

        function escapeChar(chr) {
            return escape[chr];
        }

        return function(string) {
            if (string == null) {
                return '';
            } else if (!string) {
                return string + '';
            }

            // Force a string conversion as this will be done by the append regardless and
            // the regex test will do this transparently behind the scenes, causing issues if
            // an object's to string has escaped characters in it.
            string = '' + string;

            if (!possible.test(string)) {
                return string;
            }
            return string.replace(badChars, escapeChar);
        };
    })();

    L.Control.Geocoder.Nominatim = L.Class.extend({
        options: {
            serviceUrl: '//nominatim.openstreetmap.org/',
            geocodingQueryParams: {
                countrycodes:'it',
                viewbox: '7.49958,44.791951,10.06312,43.730645',
                bounded: 1
            },
            reverseQueryParams: {},
            htmlTemplate: function(r) {


                var display = r.display_name.replace('Genoa,','').replace('Italia','').replace('Liguria,','');
                return L.Control.Geocoder.template(display.split(',').join('<br/>'),  r.address, true);

                //return L.Control.Geocoder.template(parts.join('<br/>'), a, true);

            }
        },

        initialize: function(options) {
            L.Util.setOptions(this, options);
        },

        geocode: function(query, cb, context) {
            L.Control.Geocoder.jsonp(this.options.serviceUrl + 'search/', L.extend({
                    q: query + ' Liguria',
                    limit: 10,
                    format: 'json',
                    addressdetails: 1
                }, this.options.geocodingQueryParams),
                function(data) {
                    var results = [];
                    for (var i = data.length - 1; i >= 0; i--) {
                        var bbox = data[i].boundingbox;
                        for (var j = 0; j < 4; j++) bbox[j] = parseFloat(bbox[j]);
                        results[i] = {
                            icon: data[i].icon,
                            name: data[i].display_name,
                            html: this.options.htmlTemplate ?
                                this.options.htmlTemplate(data[i])
                                : undefined,
                            bbox: L.latLngBounds([bbox[0], bbox[2]], [bbox[1], bbox[3]]),
                            center: L.latLng(data[i].lat, data[i].lon),
                            properties: data[i]
                        };
                    }
                    cb.call(context, results);
                }, this, 'json_callback');
        },

        reverse: function(location, scale, cb, context) {
            L.Control.Geocoder.jsonp(this.options.serviceUrl + 'reverse/', L.extend({
                lat: location.lat,
                lon: location.lng,
                zoom: Math.round(Math.log(scale / 256) / Math.log(2)),
                addressdetails: 1,
                format: 'json'
            }, this.options.reverseQueryParams), function(data) {
                var result = [],
                    loc;

                if (data && data.lat && data.lon) {
                    loc = L.latLng(data.lat, data.lon);
                    result.push({
                        name: data.display_name,
                        html: this.options.htmlTemplate ?
                            this.options.htmlTemplate(data)
                            : undefined,
                        center: loc,
                        bounds: L.latLngBounds(loc, loc),
                        properties: data
                    });
                }

                cb.call(context, result);
            }, this, 'json_callback');
        }
    });

    L.Control.Geocoder.Google = L.Class.extend({
        options: {
            service_url: 'https://maps.googleapis.com/maps/api/geocode/json'
        },

        initialize: function(key) {
            this._key = key;
        },

        geocode: function(query, cb, context) {
            var params = {
                address: query
            };
            if(this._key && this._key.length)
            {
                params['key'] = this._key
            }

            L.Control.Geocoder.getJSON(this.options.service_url, params, function(data) {
                var results = [],
                    loc,
                    latLng,
                    latLngBounds;
                if (data.results && data.results.length) {
                    for (var i = 0; i <= data.results.length - 1; i++) {
                        loc = data.results[i];
                        latLng = L.latLng(loc.geometry.location);
                        latLngBounds = L.latLngBounds(L.latLng(loc.geometry.viewport.northeast), L.latLng(loc.geometry.viewport.southwest));
                        results[i] = {
                            name: loc.formatted_address,
                            bbox: latLngBounds,
                            center: latLng
                        };
                    }
                }

                cb.call(context, results);
            });
        },

        reverse: function(location, scale, cb, context) {
            var params = {
                latlng: encodeURIComponent(location.lat) + ',' + encodeURIComponent(location.lng)
            };
            if(this._key && this._key.length)
            {
                params['key'] = this._key
            }
            L.Control.Geocoder.getJSON(this.options.service_url, params, function(data) {
                var results = [],
                    loc,
                    latLng,
                    latLngBounds;
                if (data.results && data.results.length) {
                    for (var i = 0; i <= data.results.length - 1; i++) {
                        loc = data.results[i];
                        latLng = L.latLng(loc.geometry.location);
                        latLngBounds = L.latLngBounds(L.latLng(loc.geometry.viewport.northeast), L.latLng(loc.geometry.viewport.southwest));
                        results[i] = {
                            name: loc.formatted_address,
                            bbox: latLngBounds,
                            center: latLng
                        };
                    }
                }

                cb.call(context, results);
            });
        }
    });

    return L.Control.Geocoder;
})();

/*!
 Copyright (c) 2016 Dominik Moritz

 This file is part of the leaflet locate control. It is licensed under the MIT license.
 You can find the project at: https://github.com/domoritz/leaflet-locatecontrol
 */
(function (factory, window) {
    // see https://github.com/Leaflet/Leaflet/blob/master/PLUGIN-GUIDE.md#module-loaders
    // for details on how to structure a leaflet plugin.

    // define an AMD module that relies on 'leaflet'
    if (typeof define === 'function' && define.amd) {
        define(['leaflet'], factory);

        // define a Common JS module that relies on 'leaflet'
    } else if (typeof exports === 'object') {
        if (typeof window !== 'undefined' && window.L) {
            module.exports = factory(L);
        } else {
            module.exports = factory(require('leaflet'));
        }
    }

    // attach your plugin to the global 'L' variable
    if(typeof window !== 'undefined' && window.L){
        window.L.Control.Locate = factory(L);
    }
} (function (L) {
    var LocateControl = L.Control.extend({
        options: {
            /** Position of the control */
            position: 'topleft',
            /** The layer that the user's location should be drawn on. By default creates a new layer. */
            layer: undefined,
            /**
             * Automatically sets the map view (zoom and pan) to the user's location as it updates.
             * While the map is following the user's location, the control is in the `following` state,
             * which changes the style of the control and the circle marker.
             *
             * Possible values:
             *  - false: never updates the map view when location changes.
             *  - 'once': set the view when the location is first determined
             *  - 'always': always updates the map view when location changes.
             *              The map view follows the users location.
             *  - 'untilPan': (default) like 'always', except stops updating the
             *                view if the user has manually panned the map.
             *                The map view follows the users location until she pans.
             */
            setView: 'untilPan',
            /** Keep the current map zoom level when setting the view and only pan. */
            keepCurrentZoomLevel: false,
            /**
             * The user location can be inside and outside the current view when the user clicks on the
             * control that is already active. Both cases can be configures separately.
             * Possible values are:
             *  - 'setView': zoom and pan to the current location
             *  - 'stop': stop locating and remove the location marker
             */
            clickBehavior: {
                /** What should happen if the user clicks on the control while the location is within the current view. */
                inView: 'stop',
                /** What should happen if the user clicks on the control while the location is outside the current view. */
                outOfView: 'setView',
            },
            /** If set, a circle that shows the location accuracy is drawn. */
            drawCircle: true,
            /** If set, the marker at the users' location is drawn. */
            drawMarker: true,
            /** The class to be used to create the marker. For example L.CircleMarker or L.Marker */
            markerClass: L.CircleMarker,
            /** Accuracy circle style properties. */
            circleStyle: {
                color: '#136AEC',
                fillColor: '#136AEC',
                fillOpacity: 0.15,
                weight: 2,
                opacity: 0.5
            },
            /** Inner marker style properties. */
            markerStyle: {
                color: '#136AEC',
                fillColor: '#2A93EE',
                fillOpacity: 0.7,
                weight: 2,
                opacity: 0.9,
                radius: 5
            },
            /**
             * Changes to accuracy circle and inner marker while following.
             * It is only necessary to provide the properties that should change.
             */
            followCircleStyle: {},
            followMarkerStyle: {
                // color: '#FFA500',
                // fillColor: '#FFB000'
            },
            /** The CSS class for the icon. For example fa-location-arrow or fa-map-marker */
            icon: 'fa fa-map-marker',
            iconLoading: 'fa fa-spinner fa-spin',
            /** The element to be created for icons. For example span or i */
            iconElementTag: 'span',
            /** Padding around the accuracy circle. */
            circlePadding: [0, 0],
            /** Use metric units. */
            metric: true,
            /** This event is called in case of any location error that is not a time out error. */
            onLocationError: function(err, control) {
                alert(err.message);
            },
            /**
             * This even is called when the user's location is outside the bounds set on the map.
             * The event is called repeatedly when the location changes.
             */
            onLocationOutsideMapBounds: function(control) {
                control.stop();
                alert(control.options.strings.outsideMapBoundsMsg);
            },
            /** Display a pop-up when the user click on the inner marker. */
            showPopup: true,
            strings: {
                title: "Show me where I am",
                metersUnit: "meters",
                feetUnit: "feet",
                popup: "You are within {distance} {unit} from this point",
                outsideMapBoundsMsg: "You seem located outside the boundaries of the map"
            },
            /** The default options passed to leaflets locate method. */
            locateOptions: {
                maxZoom: Infinity,
                watch: true,  // if you overwrite this, visualization cannot be updated
                setView: false // have to set this to false because we have to
                               // do setView manually
            }
        },

        initialize: function (options) {
            // set default options if nothing is set (merge one step deep)
            for (var i in options) {
                if (typeof this.options[i] === 'object') {
                    L.extend(this.options[i], options[i]);
                } else {
                    this.options[i] = options[i];
                }
            }

            // extend the follow marker style and circle from the normal style
            this.options.followMarkerStyle = L.extend({}, this.options.markerStyle, this.options.followMarkerStyle);
            this.options.followCircleStyle = L.extend({}, this.options.circleStyle, this.options.followCircleStyle);
        },

        /**
         * Add control to map. Returns the container for the control.
         */
        onAdd: function (map) {
            var container = L.DomUtil.create('div',
                'leaflet-control-locate leaflet-bar leaflet-control');

            this._layer = this.options.layer || new L.LayerGroup();
            this._layer.addTo(map);
            this._event = undefined;

            this._link = L.DomUtil.create('a', 'leaflet-bar-part leaflet-bar-part-single', container);
            this._link.href = '#';
            this._link.title = this.options.strings.title;
            this._icon = L.DomUtil.create(this.options.iconElementTag, this.options.icon, this._link);

            L.DomEvent
                .on(this._link, 'click', L.DomEvent.stopPropagation)
                .on(this._link, 'click', L.DomEvent.preventDefault)
                .on(this._link, 'click', this._onClick, this)
                .on(this._link, 'dblclick', L.DomEvent.stopPropagation);

            this._resetVariables();

            this._map.on('unload', this._unload, this);

            return container;
        },

        /**
         * This method is called when the user clicks on the control.
         */
        _onClick: function() {
            this._justClicked = true;
            this._userPanned = false;

            if (this._active && !this._event) {
                // click while requesting
                this.stop();
            } else if (this._active && this._event !== undefined) {
                var behavior = this._map.getBounds().contains(this._event.latlng) ?
                    this.options.clickBehavior.inView : this.options.clickBehavior.outOfView;
                switch (behavior) {
                    case 'setView':
                        this.setView();
                        break;
                    case 'stop':
                        this.stop();
                        break;
                }
            } else {
                this.start();
            }

            this._updateContainerStyle();
        },

        /**
         * Starts the plugin:
         * - activates the engine
         * - draws the marker (if coordinates available)
         */
        start: function() {
            this._activate();

            if (this._event) {
                this._drawMarker(this._map);

                // if we already have a location but the user clicked on the control
                if (this.options.setView) {
                    this.setView();
                }
            }
            this._updateContainerStyle();
        },

        /**
         * Stops the plugin:
         * - deactivates the engine
         * - reinitializes the button
         * - removes the marker
         */
        stop: function() {
            this._deactivate();

            this._cleanClasses();
            this._resetVariables();

            this._removeMarker();
        },

        /**
         * This method launches the location engine.
         * It is called before the marker is updated,
         * event if it does not mean that the event will be ready.
         *
         * Override it if you want to add more functionalities.
         * It should set the this._active to true and do nothing if
         * this._active is true.
         */
        _activate: function() {
            if (!this._active) {
                this._map.locate(this.options.locateOptions);
                this._active = true;

                // bind event listeners
                this._map.on('locationfound', this._onLocationFound, this);
                this._map.on('locationerror', this._onLocationError, this);
                this._map.on('dragstart', this._onDrag, this);
            }
        },

        /**
         * Called to stop the location engine.
         *
         * Override it to shutdown any functionalities you added on start.
         */
        _deactivate: function() {
            this._map.stopLocate();
            this._active = false;

            // unbind event listeners
            this._map.off('locationfound', this._onLocationFound, this);
            this._map.off('locationerror', this._onLocationError, this);
            this._map.off('dragstart', this._onDrag, this);
        },

        /**
         * Zoom (unless we should keep the zoom level) and an to the current view.
         */
        setView: function() {
            if (this._isOutsideMapBounds()) {
                this.options.onLocationOutsideMapBounds(this);
            } else {
                if (this.options.keepCurrentZoomLevel) {
                    this._map.panTo([this._event.latitude, this._event.longitude]);
                } else {
                    this._map.fitBounds(this._event.bounds, {
                        padding: this.options.circlePadding,
                        maxZoom: this.options.locateOptions.maxZoom
                    });
                }
            }
            this._drawMarker();
        },

        /**
         * Draw the marker and accuracy circle on the map.
         *
         * Uses the event retrieved from onLocationFound from the map.
         */
        _drawMarker: function() {
            if (this._event.accuracy === undefined) {
                this._event.accuracy = 0;
            }

            var radius = this._event.accuracy;
            var latlng = this._event.latlng;

            // circle with the radius of the location's accuracy
            if (this.options.drawCircle) {
                var style = this._isFollowing() ? this.options.followCircleStyle : this.options.circleStyle;

                if (!this._circle) {
                    this._circle = L.circle(latlng, radius, style).addTo(this._layer);
                } else {
                    this._circle.setLatLng(latlng).setRadius(radius).setStyle(style);
                }
            }

            var distance, unit;
            if (this.options.metric) {
                distance = radius.toFixed(0);
                unit =  this.options.strings.metersUnit;
            } else {
                distance = (radius * 3.2808399).toFixed(0);
                unit = this.options.strings.feetUnit;
            }

            // small inner marker
            if (this.options.drawMarker) {
                var mStyle = this._isFollowing() ? this.options.followMarkerStyle : this.options.markerStyle;

                if (!this._marker) {
                    this._marker = new this.options.markerClass(latlng, mStyle).addTo(this._layer);
                } else {
                    this._marker.setLatLng(latlng).setStyle(mStyle);
                }
            }

            var t = this.options.strings.popup;
            if (this.options.showPopup && t && this._marker) {
                this._marker
                    .bindPopup(L.Util.template(t, {distance: distance, unit: unit}))
                    ._popup.setLatLng(latlng);
            }
        },

        /**
         * Remove the marker from map.
         */
        _removeMarker: function() {
            this._layer.clearLayers();
            this._marker = undefined;
            this._circle = undefined;
        },

        /**
         * Unload the plugin and all event listeners.
         * Kind of the opposite of onAdd.
         */
        _unload: function() {
            this.stop();
            this._map.off('unload', this._unload, this);
        },

        /**
         * Calls deactivate and dispatches an error.
         */
        _onLocationError: function(err) {
            // ignore time out error if the location is watched
            if (err.code == 3 && this.options.locateOptions.watch) {
                return;
            }

            this.stop();
            this.options.onLocationError(err, this);
        },

        /**
         * Stores the received event and updates the marker.
         */
        _onLocationFound: function(e) {
            // no need to do anything if the location has not changed
            if (this._event &&
                (this._event.latlng.lat === e.latlng.lat &&
                this._event.latlng.lng === e.latlng.lng &&
                this._event.accuracy === e.accuracy)) {
                return;
            }

            if (!this._active) {
                // we may have a stray event
                return;
            }

            this._event = e;

            this._drawMarker();
            this._updateContainerStyle();

            switch (this.options.setView) {
                case 'once':
                    if (this._justClicked) {
                        this.setView();
                    }
                    break;
                case 'untilPan':
                    if (!this._userPanned) {
                        this.setView();
                    }
                    break;
                case 'always':
                    this.setView();
                    break;
                case false:
                    // don't set the view
                    break;
            }

            this._justClicked = false;
        },

        /**
         * When the user drags. Need a separate even so we can bind and unbind even listeners.
         */
        _onDrag: function() {
            // only react to drags once we have a location
            if (this._event) {
                this._userPanned = true;
                this._updateContainerStyle();
                this._drawMarker();
            }
        },

        /**
         * Compute whether the map is following the user location with pan and zoom.
         */
        _isFollowing: function() {
            if (!this._active) {
                return false;
            }

            if (this.options.setView === 'always') {
                return true;
            } else if (this.options.setView === 'untilPan') {
                return !this._userPanned;
            }
        },

        /**
         * Check if location is in map bounds
         */
        _isOutsideMapBounds: function() {
            if (this._event === undefined) {
                return false;
            }
            return this._map.options.maxBounds &&
                !this._map.options.maxBounds.contains(this._event.latlng);
        },

        /**
         * Toggles button class between following and active.
         */
        _updateContainerStyle: function() {
            if (!this._container) {
                return;
            }

            if (this._active && !this._event) {
                // active but don't have a location yet
                this._setClasses('requesting');
            } else if (this._isFollowing()) {
                this._setClasses('following');
            } else if (this._active) {
                this._setClasses('active');
            } else {
                this._cleanClasses();
            }
        },

        /**
         * Sets the CSS classes for the state.
         */
        _setClasses: function(state) {
            if (state == 'requesting') {
                L.DomUtil.removeClasses(this._container, "active following");
                L.DomUtil.addClasses(this._container, "requesting");

                L.DomUtil.removeClasses(this._icon, this.options.icon);
                L.DomUtil.addClasses(this._icon, this.options.iconLoading);
            } else if (state == 'active') {
                L.DomUtil.removeClasses(this._container, "requesting following");
                L.DomUtil.addClasses(this._container, "active");

                L.DomUtil.removeClasses(this._icon, this.options.iconLoading);
                L.DomUtil.addClasses(this._icon, this.options.icon);
            } else if (state == 'following') {
                L.DomUtil.removeClasses(this._container, "requesting");
                L.DomUtil.addClasses(this._container, "active following");

                L.DomUtil.removeClasses(this._icon, this.options.iconLoading);
                L.DomUtil.addClasses(this._icon, this.options.icon);
            }
        },

        /**
         * Removes all classes from button.
         */
        _cleanClasses: function() {
            L.DomUtil.removeClass(this._container, "requesting");
            L.DomUtil.removeClass(this._container, "active");
            L.DomUtil.removeClass(this._container, "following");

            L.DomUtil.removeClasses(this._icon, this.options.iconLoading);
            L.DomUtil.addClasses(this._icon, this.options.icon);
        },

        /**
         * Reinitializes state variables.
         */
        _resetVariables: function() {
            // whether locate is active or not
            this._active = false;

            // true if the control was clicked for the first time
            // we need this so we can pan and zoom once we have the location
            this._justClicked = false;

            // true if the user has panned the map after clicking the control
            this._userPanned = false;
        }
    });

    L.control.locate = function (options) {
        return new L.Control.Locate(options);
    };

    (function(){
        // leaflet.js raises bug when trying to addClass / removeClass multiple classes at once
        // Let's create a wrapper on it which fixes it.
        var LDomUtilApplyClassesMethod = function(method, element, classNames) {
            classNames = classNames.split(' ');
            classNames.forEach(function(className) {
                L.DomUtil[method].call(this, element, className);
            });
        };

        L.DomUtil.addClasses = function(el, names) { LDomUtilApplyClassesMethod('addClass', el, names); };
        L.DomUtil.removeClasses = function(el, names) { LDomUtilApplyClassesMethod('removeClass', el, names); };
    })();

    return LocateControl;
}, window));
(function() {
    L.Control.NavBar = L.Control.extend({
        options: {
            position: 'topleft',
            //center:,
            //zoom :,
            //bbox:, //Alternative to center/zoom for home button, takes precedence if included
            forwardTitle: 'Vai avanti',
            backTitle: 'Via indietro',
            homeTitle: 'Vai alla estensione iniziale'
        },

        onAdd: function(map) {

            // Set options
            if (!this.options.center) {
                this.options.center = map.getCenter();
            }
            if (!this.options.zoom) {
                this.options.zoom = map.getZoom();
            }
            options = this.options;

            // Create toolbar
            var controlName = 'leaflet-control-navbar',
                container = L.DomUtil.create('div', controlName + ' leaflet-bar');

            // Add toolbar buttons
            this._homeButton = this._createButton(options.homeTitle, 'fa fa-home', container, this._goHome);
            this._fwdButton = this._createButton(options.forwardTitle, 'fa fa-caret-right', container, this._goFwd);
            this._backButton = this._createButton(options.backTitle, 'fa fa-caret-left', container, this._goBack);

            // Initialize view history and index
            this._viewHistory = [{center: this.options.center, zoom: this.options.zoom}];
            this._curIndx = 0;
            this._updateDisabled();
            map.once('moveend', function() {this._map.on('moveend', this._updateHistory, this);}, this);
            // Set intial view to home
            map.setView(options.center, options.zoom);

            return container;
        },

        onRemove: function(map) {
            map.off('moveend', this._updateHistory, this);
        },

        _goHome: function() {
            if (this.options.bbox){
                try {
                    this._map.fitBounds(this.options.bbox);
                } catch(err){
                    this._map.setView(this.options.center, this.options.zoom); //Use default if invalid bbox input.
                }
            }
            this._map.setView(this.options.center, this.options.zoom);
        },

        _goBack: function() {
            if (this._curIndx !== 0) {
                this._map.off('moveend', this._updateHistory, this);
                this._map.once('moveend', function() {this._map.on('moveend', this._updateHistory, this);}, this);
                this._curIndx--;
                this._updateDisabled();
                var view = this._viewHistory[this._curIndx];
                this._map.setView(view.center, view.zoom);
            }
        },

        _goFwd: function() {
            if (this._curIndx != this._viewHistory.length - 1) {
                this._map.off('moveend', this._updateHistory, this);
                this._map.once('moveend', function() {this._map.on('moveend', this._updateHistory, this);}, this);
                this._curIndx++;
                this._updateDisabled();
                var view = this._viewHistory[this._curIndx];
                this._map.setView(view.center, view.zoom);
            }
        },

        _createButton: function(title, className, container, fn) {
            // Modified from Leaflet zoom control

            var link = L.DomUtil.create('a', className, container);
            link.href = '#';
            link.title = title;

            L.DomEvent
                .on(link, 'mousedown dblclick', L.DomEvent.stopPropagation)
                .on(link, 'click', L.DomEvent.stop)
                .on(link, 'click', fn, this)
                .on(link, 'click', this._refocusOnMap, this);

            return link;
        },

        _updateHistory: function() {
            var newView = {center: this._map.getCenter(), zoom: this._map.getZoom()};
            var insertIndx = this._curIndx + 1;
            this._viewHistory.splice(insertIndx, this._viewHistory.length - insertIndx, newView);
            this._curIndx++;
            // Update disabled state of toolbar buttons
            this._updateDisabled();
        },

        _setFwdEnabled: function(enabled) {
            var leafletDisabled = 'leaflet-disabled';
            var fwdDisabled = 'leaflet-control-navbar-fwd-disabled';
            if (enabled === true) {
                L.DomUtil.removeClass(this._fwdButton, fwdDisabled);
                L.DomUtil.removeClass(this._fwdButton, leafletDisabled);
            }else {
                L.DomUtil.addClass(this._fwdButton, fwdDisabled);
                L.DomUtil.addClass(this._fwdButton, leafletDisabled);
            }
        },

        _setBackEnabled: function(enabled) {
            var leafletDisabled = 'leaflet-disabled';
            var backDisabled = 'leaflet-control-navbar-back-disabled';
            if (enabled === true) {
                L.DomUtil.removeClass(this._backButton, backDisabled);
                L.DomUtil.removeClass(this._backButton, leafletDisabled);
            }else {
                L.DomUtil.addClass(this._backButton, backDisabled);
                L.DomUtil.addClass(this._backButton, leafletDisabled);
            }
        },

        _updateDisabled: function() {
            if (this._curIndx == (this._viewHistory.length - 1)) {
                this._setFwdEnabled(false);
            }else {
                this._setFwdEnabled(true);
            }

            if (this._curIndx <= 0) {
                this._setBackEnabled(false);
            }else {
                this._setBackEnabled(true);
            }
        }

    });

    L.control.navbar = function(options) {
        return new L.Control.NavBar(options);
    };

})();
(function (factory) {
    if(typeof define === 'function' && define.amd) {
        //AMD
        define(['leaflet'], factory);
    } else if(typeof module !== 'undefined') {
        // Node/CommonJS
        module.exports = factory(require('leaflet'));
    } else {
        // Browser globals
        if(typeof window.L === 'undefined')
            throw 'Leaflet must be loaded first';
        factory(window.L);
    }
})(function (L) {

    function _getPath(obj, prop) {
        var parts = prop.split('.'),
            last = parts.pop(),
            len = parts.length,
            cur = parts[0],
            i = 1;

        if(len > 0)
            while((obj = obj[cur]) && i < len)
                cur = parts[i++];

        if(obj)
            return obj[last];
    }

    function _isObject(obj) {
        return Object.prototype.toString.call(obj) === "[object Object]";
    }


    L.Control.Search = L.Control.extend({
        includes: L.Mixin.Events,
        //
        //	Name					Data passed			   Description
        //
        //Managed Events:
        //	search:locationfound	{latlng, title, layer} fired after moved and show markerLocation
        //	search:expanded			{}					   fired after control was expanded
        //  search:collapsed		{}					   fired after control was collapsed
        //
        //Public methods:
        //  setLayer()				L.LayerGroup()         set layer search at runtime
        //  showAlert()             'Text message'         show alert message
        //  searchText()			'Text searched'        search text by external code
        //
        options: {
            url: '',						//url for search by ajax request, ex: "search.php?q={s}". Can be function that returns string for dynamic parameter setting
            layer: null,					//layer where search markers(is a L.LayerGroup)
            sourceData: null,				//function that fill _recordsCache, passed searching text by first param and callback in second
            //TODO implements uniq option 'sourceData' that recognizes source type: url,array,callback or layer
            jsonpParam: null,				//jsonp param name for search by jsonp service, ex: "callback"
            propertyLoc: 'loc',				//field for remapping location, using array: ['latname','lonname'] for select double fields(ex. ['lat','lon'] ) support dotted format: 'prop.subprop.title'
            propertyName: 'title',			//property in marker.options(or feature.properties for vector layer) trough filter elements in layer,
            formatData: null,				//callback for reformat all data from source to indexed data object
            filterData: null,				//callback for filtering data from text searched, params: textSearch, allRecords
            moveToLocation: null,			//callback run on location found, params: latlng, title, map
            buildTip: null,					//function that return row tip html node(or html string), receive text tooltip in first param
            container: '',					//container id to insert Search Control
            zoom: null,						//default zoom level for move to location
            minLength: 1,					//minimal text length for autocomplete
            initial: false,					//search elements only by initial text
            casesensitive: false,			//search elements in case sensitive text
            autoType: true,					//complete input with first suggested result and select this filled-in text.
            delayType: 400,					//delay while typing for show tooltip
            tooltipLimit: -1,				//limit max results to show in tooltip. -1 for no limit.
            tipAutoSubmit: true,			//auto map panTo when click on tooltip
            firstTipSubmit: false,			//auto select first result con enter click
            autoResize: true,				//autoresize on input change
            collapsed: true,				//collapse search control at startup
            autoCollapse: false,			//collapse search control after submit(on button or on tips if enabled tipAutoSubmit)
            autoCollapseTime: 1200,			//delay for autoclosing alert and collapse after blur
            textErr: 'Non trovato',	//error message
            textCancel: 'Cancel',		    //title in cancel button
            textPlaceholder: 'Ricerca...',   //placeholder value
            position: 'topleft',
            hideMarkerOnCollapse: false,    //remove circle and marker on search control collapsed
            marker: {						//custom L.Marker or false for hide
                icon: false,				//custom L.Icon for maker location or false for hide
                animate: true,				//animate a circle over location found
                circle: {					//draw a circle in location found
                    radius: 10,
                    weight: 3,
                    color: '#e70',
                    stroke: true,
                    fillColor: '#e70',
                    fillOpacity: 0.4,
                    fill: true
                }
            }
            //TODO implement can do research on multiple sources layers and remote
            //TODO history: false,		//show latest searches in tooltip
        },
//FIXME option condition problem {autoCollapse: true, markerLocation: true} not show location
//FIXME option condition problem {autoCollapse: false }
//
//TODO here insert function that search inputText FIRST in _recordsCache keys and if not find results.. 
//  run one of callbacks search(sourceData,jsonpUrl or options.layer) and run this.showTooltip
//
//TODO change structure of _recordsCache
//	like this: _recordsCache = {"text-key1": {loc:[lat,lng], ..other attributes.. }, {"text-key2": {loc:[lat,lng]}...}, ...}
//	in this mode every record can have a free structure of attributes, only 'loc' is required

        initialize: function(options) {
            L.Util.setOptions(this, options || {});
            this._inputMinSize = this.options.textPlaceholder ? this.options.textPlaceholder.length : 10;
            this._layer = this.options.layer || new L.LayerGroup();
            this._filterData = this.options.filterData || this._defaultFilterData;
            this._formatData = this.options.formatData || this._defaultFormatData;
            this._moveToLocation = this.options.moveToLocation || this._defaultMoveToLocation;
            this._autoTypeTmp = this.options.autoType;	//useful for disable autoType temporarily in delete/backspace keydown
            this._countertips = 0;		//number of tips items
            this._recordsCache = {};	//key,value table! that store locations! format: key,latlng
            this._curReq = null;
        },

        onAdd: function (map) {
            this._map = map;
            this._container = L.DomUtil.create('div', 'leaflet-control-search');
            this._input = this._createInput(this.options.textPlaceholder, 'search-input');
            this._tooltip = this._createTooltip('search-tooltip');
            this._cancel = this._createCancel(this.options.textCancel, 'search-cancel');
            this._button = this._createButton(this.options.textPlaceholder, 'search-button ms ms-zoom');
            this._alert = this._createAlert('search-alert');

            if(this.options.collapsed===false)
                this.expand(this.options.collapsed);

            if(this.options.marker) {

                if(this.options.marker instanceof L.Marker || this.options.marker instanceof L.CircleMarker)
                    this._markerSearch = this.options.marker;

                else if(_isObject(this.options.marker))
                    this._markerSearch = new L.Control.Search.Marker([0,0], this.options.marker);

                this._markerSearch._isMarkerSearch = true;
            }

            this.setLayer( this._layer );

            map.on({
                // 		'layeradd': this._onLayerAddRemove,
                // 		'layerremove': this._onLayerAddRemove
                'resize': this._handleAutoresize
            }, this);
            return this._container;
        },
        addTo: function (map) {

            if(this.options.container) {
                this._container = this.onAdd(map);
                this._wrapper = L.DomUtil.get(this.options.container);
                this._wrapper.style.position = 'relative';
                this._wrapper.appendChild(this._container);
            }
            else
                L.Control.prototype.addTo.call(this, map);

            return this;
        },

        onRemove: function(map) {
            this._recordsCache = {};
            // map.off({
            // 		'layeradd': this._onLayerAddRemove,
            // 		'layerremove': this._onLayerAddRemove
            // 	}, this);
        },

        // _onLayerAddRemove: function(e) {
        // 	//without this, run setLayer also for each Markers!! to optimize!
        // 	if(e.layer instanceof L.LayerGroup)
        // 		if( L.stamp(e.layer) != L.stamp(this._layer) )
        // 			this.setLayer(e.layer);
        // },

        setLayer: function(layer) {	//set search layer at runtime
            //this.options.layer = layer; //setting this, run only this._recordsFromLayer()
            this._layer = layer;
            this._layer.addTo(this._map);
            return this;
        },

        showAlert: function(text) {
            text = text || this.options.textErr;
            this._alert.style.display = 'block';
            this._alert.innerHTML = text;
            clearTimeout(this.timerAlert);
            var that = this;
            this.timerAlert = setTimeout(function() {
                that.hideAlert();
            },this.options.autoCollapseTime);
            return this;
        },

        hideAlert: function() {
            this._alert.style.display = 'none';
            return this;
        },

        cancel: function() {
            this._input.value = '';
            this._handleKeypress({ keyCode: 8 });//simulate backspace keypress
            this._input.size = this._inputMinSize;
            this._input.focus();
            this._cancel.style.display = 'none';
            this._hideTooltip();
            return this;
        },

        expand: function(toggle) {
            toggle = typeof toggle === 'boolean' ? toggle : true;
            this._input.style.display = 'block';
            L.DomUtil.addClass(this._container, 'search-exp');
            if ( toggle !== false ) {
                this._input.focus();
                this._map.on('dragstart click', this.collapse, this);
            }
            this.fire('search:expanded');
            return this;
        },

        collapse: function() {
            this._hideTooltip();
            this.cancel();
            this._alert.style.display = 'none';
            this._input.blur();
            if(this.options.collapsed)
            {
                this._input.style.display = 'none';
                this._cancel.style.display = 'none';
                L.DomUtil.removeClass(this._container, 'search-exp');
                if (this.options.hideMarkerOnCollapse) {
                    this._map.removeLayer(this._markerSearch);
                }
                this._map.off('dragstart click', this.collapse, this);
            }
            this.fire('search:collapsed');
            return this;
        },

        collapseDelayed: function() {	//collapse after delay, used on_input blur
            if (!this.options.autoCollapse) return this;
            var that = this;
            clearTimeout(this.timerCollapse);
            this.timerCollapse = setTimeout(function() {
                that.collapse();
            }, this.options.autoCollapseTime);
            return this;
        },

        collapseDelayedStop: function() {
            clearTimeout(this.timerCollapse);
            return this;
        },

////start DOM creations
        _createAlert: function(className) {
            var alert = L.DomUtil.create('div', className, this._container);
            alert.style.display = 'none';

            L.DomEvent
                .on(alert, 'click', L.DomEvent.stop, this)
                .on(alert, 'click', this.hideAlert, this);

            return alert;
        },

        _createInput: function (text, className) {
            var label = L.DomUtil.create('label', className, this._container);
            var input = L.DomUtil.create('input', className, this._container);
            input.type = 'text';
            input.size = this._inputMinSize;
            input.value = '';
            input.autocomplete = 'off';
            input.autocorrect = 'off';
            input.autocapitalize = 'off';
            input.placeholder = text;
            input.style.display = 'none';
            input.role = 'search';
            input.id = input.role + input.type + input.size;

            label.htmlFor = input.id;
            label.style.display = 'none';
            label.value = text;

            L.DomEvent
                .disableClickPropagation(input)
                .on(input, 'keydown', this._handleKeypress, this)
                .on(input, 'blur', this.collapseDelayed, this)
                .on(input, 'focus', this.collapseDelayedStop, this);

            return input;
        },

        _createCancel: function (title, className) {
            var cancel = L.DomUtil.create('a', className, this._container);
            cancel.href = '#';
            cancel.title = title;
            cancel.style.display = 'none';
            cancel.innerHTML = "<span>&otimes;</span>";//imageless(see css)

            L.DomEvent
                .on(cancel, 'click', L.DomEvent.stop, this)
                .on(cancel, 'click', this.cancel, this);

            return cancel;
        },

        _createButton: function (title, className) {
            var button = L.DomUtil.create('a', className, this._container);
            button.href = '#';
            button.title = title;

            L.DomEvent
                .on(button, 'click', L.DomEvent.stop, this)
                .on(button, 'click', this._handleSubmit, this)
                .on(button, 'focus', this.collapseDelayedStop, this)
                .on(button, 'blur', this.collapseDelayed, this);

            return button;
        },

        _createTooltip: function(className) {
            var tool = L.DomUtil.create('ul', className, this._container);
            tool.style.display = 'none';

            var that = this;
            L.DomEvent
                .disableClickPropagation(tool)
                .on(tool, 'blur', this.collapseDelayed, this)
                .on(tool, 'mousewheel', function(e) {
                    that.collapseDelayedStop();
                    L.DomEvent.stopPropagation(e);//disable zoom map
                }, this)
                .on(tool, 'mouseover', function(e) {
                    that.collapseDelayedStop();
                }, this);
            return tool;
        },

        _createTip: function(text, val) {//val is object in recordCache, usually is Latlng
            var tip;

            if(this.options.buildTip)
            {
                tip = this.options.buildTip.call(this, text, val); //custom tip node or html string
                if(typeof tip === 'string')
                {
                    var tmpNode = L.DomUtil.create('div');
                    tmpNode.innerHTML = tip;
                    tip = tmpNode.firstChild;
                }
            }
            else
            {
                tip = L.DomUtil.create('li', '');
                tip.innerHTML = text;
            }

            L.DomUtil.addClass(tip, 'search-tip');
            tip._text = text; //value replaced in this._input and used by _autoType

            if(this.options.tipAutoSubmit)
                L.DomEvent
                    .disableClickPropagation(tip)
                    .on(tip, 'click', L.DomEvent.stop, this)
                    .on(tip, 'click', function(e) {
                        this._input.value = text;
                        this._handleAutoresize();
                        this._input.focus();
                        this._hideTooltip();
                        this._handleSubmit();
                    }, this);

            return tip;
        },

//////end DOM creations

        _getUrl: function(text) {
            return (typeof this.options.url === 'function') ? this.options.url(text) : this.options.url;
        },

        _defaultFilterData: function(text, records) {

            var I, icase, regSearch, frecords = {};

            text = text.replace(/[.*+?^${}()|[\]\\]/g, '');  //sanitize remove all special characters
            if(text==='')
                return [];

            I = this.options.initial ? '^' : '';  //search only initial text
            icase = !this.options.casesensitive ? 'i' : undefined;

            regSearch = new RegExp(I + text, icase);

            //TODO use .filter or .map
            for(var key in records) {
                if( regSearch.test(key) )
                    frecords[key]= records[key];
            }

            return frecords;
        },

        showTooltip: function(records) {
            var tip;

            this._countertips = 0;

            this._tooltip.innerHTML = '';
            this._tooltip.currentSelection = -1;  //inizialized for _handleArrowSelect()

            for(var key in records)//fill tooltip
            {
                if(++this._countertips == this.options.tooltipLimit) break;

                tip = this._createTip(key, records[key] );

                this._tooltip.appendChild(tip);
            }

            if(this._countertips > 0)
            {
                this._tooltip.style.display = 'block';
                if(this._autoTypeTmp)
                    this._autoType();
                this._autoTypeTmp = this.options.autoType;//reset default value
            }
            else
                this._hideTooltip();

            this._tooltip.scrollTop = 0;
            return this._countertips;
        },

        _hideTooltip: function() {
            this._tooltip.style.display = 'none';
            this._tooltip.innerHTML = '';
            return 0;
        },

        _defaultFormatData: function(json) {	//default callback for format data to indexed data
            var propName = this.options.propertyName,
                propLoc = this.options.propertyLoc,
                i, jsonret = {};

            if( L.Util.isArray(propLoc) )
                for(i in json)
                    jsonret[ _getPath(json[i],propName) ]= L.latLng( json[i][ propLoc[0] ], json[i][ propLoc[1] ] );
            else
                for(i in json)
                    jsonret[ _getPath(json[i],propName) ]= L.latLng( _getPath(json[i],propLoc) );
            //TODO throw new Error("propertyName '"+propName+"' not found in JSON data");
            return jsonret;
        },

        _recordsFromJsonp: function(text, callAfter) {  //extract searched records from remote jsonp service
            L.Control.Search.callJsonp = callAfter;
            var script = L.DomUtil.create('script','leaflet-search-jsonp', document.getElementsByTagName('body')[0] ),
                url = L.Util.template(this._getUrl(text)+'&'+this.options.jsonpParam+'=L.Control.Search.callJsonp', {s: text}); //parsing url
            //rnd = '&_='+Math.floor(Math.random()*10000);
            //TODO add rnd param or randomize callback name! in recordsFromJsonp
            script.type = 'text/javascript';
            script.src = url;
            return { abort: function() { script.parentNode.removeChild(script); } };
        },

        _recordsFromAjax: function(text, callAfter) {	//Ajax request
            if (window.XMLHttpRequest === undefined) {
                window.XMLHttpRequest = function() {
                    try { return new ActiveXObject("Microsoft.XMLHTTP.6.0"); }
                    catch  (e1) {
                        try { return new ActiveXObject("Microsoft.XMLHTTP.3.0"); }
                        catch (e2) { throw new Error("XMLHttpRequest is not supported"); }
                    }
                };
            }
            var IE8or9 = ( L.Browser.ie && !window.atob && document.querySelector ),
                request = IE8or9 ? new XDomainRequest() : new XMLHttpRequest(),
                url = L.Util.template(this._getUrl(text), {s: text});

            //rnd = '&_='+Math.floor(Math.random()*10000);
            //TODO add rnd param or randomize callback name! in recordsFromAjax

            request.open("GET", url);
            var that = this;

            request.onload = function() {
                callAfter( JSON.parse(request.responseText) );
            };
            request.onreadystatechange = function() {
                if(request.readyState === 4 && request.status === 200) {
                    this.onload();
                }
            };

            request.send();
            return request;
        },

        _recordsFromLayer: function() {	//return table: key,value from layer
            var that = this,
                retRecords = {},
                propName = this.options.propertyName,
                loc;

            this._layer.eachLayer(function(layer) {

                if(layer.hasOwnProperty('_isMarkerSearch')) return;

                if(layer instanceof L.Marker || layer instanceof L.CircleMarker)
                {
                    try {
                        if(_getPath(layer.options,propName))
                        {
                            loc = layer.getLatLng();
                            loc.layer = layer;
                            retRecords[ _getPath(layer.options,propName) ] = loc;

                        }
                        else if(_getPath(layer.feature.properties,propName)){

                            loc = layer.getLatLng();
                            loc.layer = layer;
                            retRecords[ _getPath(layer.feature.properties,propName) ] = loc;

                        }
                        else
                            throw new Error("propertyName '"+propName+"' not found in marker");

                    }
                    catch(err){
                        if (console) { console.warn(err); }
                    }
                }
                else if(layer.hasOwnProperty('feature'))//GeoJSON
                {
                    try {
                        if(layer.feature.properties.hasOwnProperty(propName))
                        {
                            loc = layer.getBounds().getCenter();
                            loc.layer = layer;
                            retRecords[ layer.feature.properties[propName] ] = loc;
                        }
                        else
                            throw new Error("propertyName '"+propName+"' not found in feature");
                    }
                    catch(err){
                        if (console) { console.warn(err); }
                    }
                }
                else if(layer instanceof L.LayerGroup)
                {
                    //TODO: Optimize
                    layer.eachLayer(function(m) {
                        loc = m.getLatLng();
                        loc.layer = m;
                        retRecords[ m.feature.properties[propName] ] = loc;
                    });
                }

            },this);

            return retRecords;
        },

        _autoType: function() {

            //TODO implements autype without selection(useful for mobile device)

            var start = this._input.value.length,
                firstRecord = this._tooltip.firstChild._text,
                end = firstRecord.length;

            if (firstRecord.indexOf(this._input.value) === 0) { // If prefix match
                this._input.value = firstRecord;
                this._handleAutoresize();

                if (this._input.createTextRange) {
                    var selRange = this._input.createTextRange();
                    selRange.collapse(true);
                    selRange.moveStart('character', start);
                    selRange.moveEnd('character', end);
                    selRange.select();
                }
                else if(this._input.setSelectionRange) {
                    this._input.setSelectionRange(start, end);
                }
                else if(this._input.selectionStart) {
                    this._input.selectionStart = start;
                    this._input.selectionEnd = end;
                }
            }
        },

        _hideAutoType: function() {	// deselect text:

            var sel;
            if ((sel = this._input.selection) && sel.empty) {
                sel.empty();
            }
            else if (this._input.createTextRange) {
                sel = this._input.createTextRange();
                sel.collapse(true);
                var end = this._input.value.length;
                sel.moveStart('character', end);
                sel.moveEnd('character', end);
                sel.select();
            }
            else {
                if (this._input.getSelection) {
                    this._input.getSelection().removeAllRanges();
                }
                this._input.selectionStart = this._input.selectionEnd;
            }
        },

        _handleKeypress: function (e) {	//run _input keyup event

            switch(e.keyCode)
            {
                case 27://Esc
                    this.collapse();
                    break;
                case 13://Enter
                    if(this._countertips == 1 || (this.options.firstTipSubmit && this._countertips > 0))
                        this._handleArrowSelect(1);
                    this._handleSubmit();	//do search
                    break;
                case 38://Up
                    this._handleArrowSelect(-1);
                    break;
                case 40://Down
                    this._handleArrowSelect(1);
                    break;
                case  8://Backspace
                case 45://Insert
                case 46://Delete
                    this._autoTypeTmp = false;//disable temporarily autoType
                    break;
                case 37://Left
                case 39://Right
                case 16://Shift
                case 17://Ctrl
                case 35://End
                case 36://Home
                    break;
                default://All keys

                    if(this._input.value.length)
                        this._cancel.style.display = 'block';
                    else
                        this._cancel.style.display = 'none';

                    if(this._input.value.length >= this.options.minLength)
                    {
                        var that = this;

                        clearTimeout(this.timerKeypress);	//cancel last search request while type in
                        this.timerKeypress = setTimeout(function() {	//delay before request, for limit jsonp/ajax request

                            that._fillRecordsCache();

                        }, this.options.delayType);
                    }
                    else
                        this._hideTooltip();
            }

            this._handleAutoresize();
        },

        searchText: function(text) {
            var code = text.charCodeAt(text.length);

            this._input.value = text;

            this._input.style.display = 'block';
            L.DomUtil.addClass(this._container, 'search-exp');

            this._autoTypeTmp = false;

            this._handleKeypress({keyCode: code});
        },

        _fillRecordsCache: function() {
//TODO important optimization!!! always append data in this._recordsCache
//  now _recordsCache content is emptied and replaced with new data founded
//  always appending data on _recordsCache give the possibility of caching ajax, jsonp and layersearch!
//
//TODO here insert function that search inputText FIRST in _recordsCache keys and if not find results.. 
//  run one of callbacks search(sourceData,jsonpUrl or options.layer) and run this.showTooltip
//
//TODO change structure of _recordsCache
//	like this: _recordsCache = {"text-key1": {loc:[lat,lng], ..other attributes.. }, {"text-key2": {loc:[lat,lng]}...}, ...}
//	in this way every record can have a free structure of attributes, only 'loc' is required

            var inputText = this._input.value,
                that = this, records;

            if(this._curReq && this._curReq.abort)
                this._curReq.abort();
            //abort previous requests

            L.DomUtil.addClass(this._container, 'search-load');

            if(this.options.layer)
            {
                //TODO _recordsFromLayer must return array of objects, formatted from _formatData
                this._recordsCache = this._recordsFromLayer();

                records = this._filterData( this._input.value, this._recordsCache );

                this.showTooltip( records );

                L.DomUtil.removeClass(this._container, 'search-load');
            }
            else
            {
                if(this.options.sourceData)
                    this._retrieveData = this.options.sourceData;

                else if(this.options.url)	//jsonp or ajax
                    this._retrieveData = this.options.jsonpParam ? this._recordsFromJsonp : this._recordsFromAjax;

                this._curReq = this._retrieveData.call(this, inputText, function(data) {

                    that._recordsCache = that._formatData(data);

                    //TODO refact!
                    if(that.options.sourceData)
                        records = that._filterData( that._input.value, that._recordsCache );
                    else
                        records = that._recordsCache;

                    that.showTooltip( records );

                    L.DomUtil.removeClass(that._container, 'search-load');
                });
            }
        },

        _handleAutoresize: function() {	//autoresize this._input
            //TODO refact _handleAutoresize now is not accurate
            if (this._input.style.maxWidth != this._map._container.offsetWidth) //If maxWidth isn't the same as when first set, reset to current Map width
                this._input.style.maxWidth = L.DomUtil.getStyle(this._map._container, 'width');

            if(this.options.autoResize && (this._container.offsetWidth + 45 < this._map._container.offsetWidth))
                this._input.size = this._input.value.length<this._inputMinSize ? this._inputMinSize : this._input.value.length;
        },

        _handleArrowSelect: function(velocity) {

            var searchTips = this._tooltip.hasChildNodes() ? this._tooltip.childNodes : [];

            for (i=0; i<searchTips.length; i++)
                L.DomUtil.removeClass(searchTips[i], 'search-tip-select');

            if ((velocity == 1 ) && (this._tooltip.currentSelection >= (searchTips.length - 1))) {// If at end of list.
                L.DomUtil.addClass(searchTips[this._tooltip.currentSelection], 'search-tip-select');
            }
            else if ((velocity == -1 ) && (this._tooltip.currentSelection <= 0)) { // Going back up to the search box.
                this._tooltip.currentSelection = -1;
            }
            else if (this._tooltip.style.display != 'none') {
                this._tooltip.currentSelection += velocity;

                L.DomUtil.addClass(searchTips[this._tooltip.currentSelection], 'search-tip-select');

                this._input.value = searchTips[this._tooltip.currentSelection]._text;

                // scroll:
                var tipOffsetTop = searchTips[this._tooltip.currentSelection].offsetTop;

                if (tipOffsetTop + searchTips[this._tooltip.currentSelection].clientHeight >= this._tooltip.scrollTop + this._tooltip.clientHeight) {
                    this._tooltip.scrollTop = tipOffsetTop - this._tooltip.clientHeight + searchTips[this._tooltip.currentSelection].clientHeight;
                }
                else if (tipOffsetTop <= this._tooltip.scrollTop) {
                    this._tooltip.scrollTop = tipOffsetTop;
                }
            }
        },

        _handleSubmit: function() {	//button and tooltip click and enter submit

            this._hideAutoType();

            this.hideAlert();
            this._hideTooltip();

            if(this._input.style.display == 'none')	//on first click show _input only
                this.expand();
            else
            {
                if(this._input.value === '')	//hide _input only
                    this.collapse();
                else
                {
                    var loc = this._getLocation(this._input.value);

                    if(loc===false)
                        this.showAlert();
                    else
                    {
                        this.showLocation(loc, this._input.value);
                        this.fire('search:locationfound', {
                            latlng: loc,
                            text: this._input.value,
                            layer: loc.layer ? loc.layer : null
                        });
                    }
                }
            }
        },

        _getLocation: function(key) {	//extract latlng from _recordsCache

            if( this._recordsCache.hasOwnProperty(key) )
                return this._recordsCache[key];//then after use .loc attribute
            else
                return false;
        },

        _defaultMoveToLocation: function(latlng, title, map) {
            if(this.options.zoom)
                this._map.setView(latlng, this.options.zoom);
            else
                this._map.panTo(latlng);
        },

        showLocation: function(latlng, title) {	//set location on map from _recordsCache
            var self = this;

            self._map.once('moveend zoomend', function(e) {

                if(self._markerSearch) {
                    self._markerSearch.addTo(self._map).setLatLng(latlng);
                }

            });

            self._moveToLocation(latlng, title, self._map);
            //FIXME autoCollapse option hide self._markerSearch before that visualized!!
            if(self.options.autoCollapse)
                self.collapse();

            return self;
        }
    });

    L.Control.Search.Marker = L.Marker.extend({

        includes: L.Mixin.Events,

        options: {
            icon: new L.Icon.Default(),
            animate: true,
            circle: {
                radius: 10,
                weight: 3,
                color: '#e03',
                stroke: true,
                fill: false
            }
        },

        initialize: function (latlng, options) {
            L.setOptions(this, options);

            if(options.icon === true)
                options.icon = new L.Icon.Default();

            L.Marker.prototype.initialize.call(this, latlng, options);

            if( _isObject(this.options.circle) )
                this._circleLoc = new L.CircleMarker(latlng, this.options.circle);
        },

        onAdd: function (map) {
            L.Marker.prototype.onAdd.call(this, map);
            if(this._circleLoc) {
                map.addLayer(this._circleLoc);
                if(this.options.animate)
                    this.animate();
            }
        },

        onRemove: function (map) {
            L.Marker.prototype.onRemove.call(this, map);
            if(this._circleLoc)
                map.removeLayer(this._circleLoc);
        },

        setLatLng: function (latlng) {
            L.Marker.prototype.setLatLng.call(this, latlng);
            if(this._circleLoc)
                this._circleLoc.setLatLng(latlng);
            return this;
        },

        _initIcon: function () {
            if(this.options.icon)
                L.Marker.prototype._initIcon.call(this);
        },

        _removeIcon: function () {
            if(this.options.icon)
                L.Marker.prototype._removeIcon.call(this);
        },

        animate: function() {
            //TODO refact animate() more smooth! like this: http://goo.gl/DDlRs
            if(this._circleLoc)
            {
                var circle = this._circleLoc,
                    tInt = 200,	//time interval
                    ss = 5,	//frames
                    mr = parseInt(circle._radius/ss),
                    oldrad = this.options.circle.radius,
                    newrad = circle._radius * 2,
                    acc = 0;

                circle._timerAnimLoc = setInterval(function() {
                    acc += 0.5;
                    mr += acc;	//adding acceleration
                    newrad -= mr;

                    circle.setRadius(newrad);

                    if(newrad<oldrad)
                    {
                        clearInterval(circle._timerAnimLoc);
                        circle.setRadius(oldrad);//reset radius
                        //if(typeof afterAnimCall == 'function')
                        //afterAnimCall();
                        //TODO use create event 'animateEnd' in L.Control.Search.Marker
                    }
                }, tInt);
            }

            return this;
        }
    });

    L.Map.addInitHook(function () {
        if (this.options.searchControl) {
            this.searchControl = L.control.search(this.options.searchControl);
            this.addControl(this.searchControl);
        }
    });

    L.control.search = function (options) {
        return new L.Control.Search(options);
    };

    return L.Control.Search;

});


GV.Models.RlLayer = Backbone.Model.extend({
/*    defaults: {
        id: 0,
        name: '',
        type: '',
        title: '',
        visible: false,
        visible: '',
        cacheMinZoomLevel: 0,
        minScale: 0,
        maxScale: 0,
        opacity: 0,
        url: '',
        legend_label: '',
    }*/
    initialize: function () {
        if (this.get('minScale') === 0) {
            this.set('minScale', 591657550);
        }
        // calcolo zIndex
        this.set('zIndex', GV.layerFactory.lastZIndex++);
        // calcolo inRange
        if (GV.app.map) {
            this.set('inRange', GV.app.map.layerInRange(this.attributes));
        } else {
            this.set('inRange', true);
        }

    }
});

GV.Models.RlLayers = Backbone.Collection.extend({
    model: GV.Models.RlLayer
});

GV.Models.RlMap = Backbone.Model.extend({
/*    defaults: {
        id: 0,
        name: '',
        extent: '',
        type: '',
        layers: []
    },*/

    urlRoot: '/geoservices/REST/config/map/',

    initialize: function() {
        var layers = new GV.Models.RlLayers(this.get('layers'));

        layers.models = layers.models.reverse();
        this.set('layers', layers);
        this.get('layers').on('change', this.layersChanged, this);
        this.set('type', 'map');
    },

    layersChanged: function(model) {
        // trigger new event.
        this.trigger('layer:change', model);
    },

    parse: function(response) {
        //console.log(response);
        return response.data;
    },

    toJSON: function() {
        var data = Backbone.Model.prototype.toJSON.call(this);
        if (data.layers && data.layers.toJSON) {
            data.layers = data.layers.toJSON();
        }
        return data;
    }
});
/**
 * Created by parodi on 08/08/2016.
 */
GV.Models.RlMaps = Backbone.Collection.extend({
    model: GV.Models.RlMap,
    url: '/geoservices/REST/config/map/',
    add: function(models, options) {
        "use strict";
        // carico mappe in ordine inverso
        var opts = {at: 0};
        if (options) {
            _.extend(opts,options);
        }
        Backbone.Collection.prototype.add.call(this, models, opts);
    },
    getLayerConfig: function (layerName) {
        "use strict";
        var foundLayer = null;
        _.each(this.models, function (map) {
            var layers = map.get('layers').models;
            foundLayer = _.find(layers, function (layer) {
                return layer.attributes.name === layerName;
            });
        });
        if (foundLayer) {
            return foundLayer.attributes;
        }
    },
    getAllLayersConfig: function () {
        "use strict";
        var layers = [];
        _.each(this.models, function (map) {
            _.each(map.get('layers').toJSON(), function (layer) {
                layers.push(layer);
            });
        });
        return layers;
    },
    setLayerAttribute: function (layerName, attribute, value) {
        "use strict";
        var foundLayer = null;
        _.each(this.models, function (map) {
            var layers = map.get('layers').models;
            _.each(layers, function (layer) {
                if (layer.get("name") === layerName) {
                    layer.set(attribute, value);
                }
            });
        });
    }
});


GV.rlMaps = {
    maps: [],
    getAllLayersConfig: function () {
        var layers = [];
        _.each(this.maps, function (map) {
            _.each(map.layers, function (layer) {
                layers.push(layer);
            });
        });
        return layers;
    },
    setLayerAttribute: function (layerName, attribute, value) {
        var foundLayer = null;
        _.each(this.maps, function (map) {
            var layers = map.layers;
            _.each(layers, function (layer) {
                if (layer.name === layerName) {
                    layer[attribute] = value;
                }
            });
        });
    },
    addMapConfig: function(mapConfig) {
        _.each(mapConfig.layers, function (layer) {
            if (layer.minScale === 0) {
                layer.minScale = 591657550;
            }
            layer.zIndex = GV.layerFactory.lastZIndex++;
            if (GV.map) {
                layer.inRange = GV.map.layerInRange(layer);
            } else {
                layer.inRange = true;
            }
        });
        mapConfig.layers.reverse();
        this.maps.unshift(mapConfig);
    },
    getLayerConfig: function (layerName) {
        "use strict";
        var foundLayer = null;
        _.each(this.maps, function (map) {
            var layers = map.layers;
            foundLayer = _.find(layers, function (layer) {
                return layer.name === layerName;
            });
        });
        if (foundLayer) {
            return foundLayer;
        }
    }
};

GV.Views.HtmlPanelTitle = Mn.View.extend({
    className: 'gv-panel-title gv-bgcolor',
    events: {
        'click .gv-close': 'hide'
    },
    hide: function () {
//        GV.app.layout.getRegion(this.options.regionId).empty();
        GV.app.layout.removeRegion(this.options.regionId);
        var element = document.getElementById(this.options.regionId);
        if (element) {
            element.outerHTML = "";
            delete element;
        }
        if (this.options.closeAction) {
            this.options.closeAction();
        }
    },
    getTemplate: function () {
        var tpl = [
            '<div>',
            '<b>' + this.options.title + '</b>',
            '<button class="gv-close" type="button">Ã</button>',
            '</div>',
            ''
        ].join('\n');
        return _.template(tpl);
    }
});

GV.Views.HtmlPanelBody = Mn.View.extend({
    tagName: 'div',
    className: 'gv-html-panel-body',
    getTemplate: function () {
        var tpl = [
            "<iframe id='",
            this.options.iFrameId,
            "' style='border:none'  width=",
            this.options.width,
            " height= ",
            this.options.height,
            '<% if (url){ %>',
            ' src = <%= url %>',
            '<% } %>',
            " ></iframe>",
            ''
        ].join('');
        return _.template(tpl)({
            url: this.options.url
        });
    },
    render: function() {
        this.el.innerHTML = this.getTemplate();
        return this;
    }
});


GV.Views.HtmlPanelLayout = Mn.View.extend({
    template: _.template("<div id='gv-html-panel-title'></div><div id='gv-html-panel-body'></div>"),
    regions: {
        title: "#gv-html-panel-title",
        body: "#gv-html-panel-body"
    },
    onRender: function() {
        "use strict";
        this.options.iFrameId = this.options.divId + '-frame';
        this.showChildView('title', new GV.Views.HtmlPanelTitle({
            regionId: this.options.regionId,
            title: this.options.title,
            closeAction: this.options.closeAction
        }));
        this.showChildView('body', new GV.Views.HtmlPanelBody({
            width: this.options.width,
            height: this.options.height,
            url: this.options.url,
            iFrameId: this.options.iFrameId
        }));
        $('#' + this.options.regionId).css({ display: 'block' });
    },
    onAttach: function() {
        "use strict";
        var frameSelector = '#' + this.options.iFrameId;
        if (this.options.html) {
            $(frameSelector).contents().find('body').html(this.options.html);
        }
        setTimeout(function() {
            // Set the height of the iframe to the height of the content
            var height = parseInt($(frameSelector).contents().find('body').height() + 8);
            $(frameSelector).css('height', height + 'px');
            var width = parseInt($(frameSelector).contents().find('body').width() );
            $(frameSelector).css('width', width + 'px');
        },50);
    }

});GV.Views.InfoWmsListItem = Mn.View.extend({
    tagName: "ul",
    className: "gv-list-group",
    getTemplate: function () {
        var tpl = [
            '<li class= "gv-info-wms-list-item">',
            '<span class="gv-info-wms-list-item-span"><%= label %> ( <%= layer.legend.label %> )</span>',
            '</li>'
        ].join('\n');
        return _.template(tpl);
    },
    events: {
        'click .gv-info-wms-list-item-span': 'featureInfo'
    },
    featureInfo: function (e) {
        "use strict";
        GV.app.infoWmsManager.showFeatureInfo(this.model);
    }
});

GV.Views.InfoWmsListBody = Mn.CollectionView.extend({
    tagName: "ul",
    className: "gv-list-group",
    childView: GV.Views.InfoWmsListItem
});

GV.Views.InfoWmsListTitle = Mn.View.extend({
    className: 'gv-panel-title gv-bgcolor',
    events: {
        'click .gv-close': 'hide'
    },
    hide: function () {
        GV.app.layout.getRegion('infowms').empty();
        GV.app.infoWmsManager.clearHiliteLayer();
    },
    getTemplate: function () {
        var tpl = [
            '<div>',
            '<b>RISULTATO INFO</b>',
            '<button class="gv-close" type="button">Ã</button>',
            '</div>',
            ''
        ].join('\n');
        return _.template(tpl);
    }
});

GV.Views.InfoWmsListLayout = Mn.View.extend({
    template: _.template("<div id='gv-info-wms-list-title'></div><div id='gv-info-wms-list-body'></div>"),
    regions: {
        title: "#gv-info-wms-list-title",
        body: "#gv-info-wms-list-body"
    },
    onRender: function() {
        "use strict";
        this.showChildView('title', new GV.Views.InfoWmsListTitle());
        this.showChildView('body', new GV.Views.InfoWmsListBody({ collection: GV.app.infoWmsList }));
        $('#gv-info-wms').css({ display: 'block' });
    }
});

GV.Views.Layout = Mn.View.extend({

    template: false,

    controls: [],

    initialize: function(options) {
        "use strict";

        this.setDrag();

        this.el = options.el;

        this.config = options.config.application.layout;

        // creo mappa leaflet
        this.addMapView(options);

        if (options.config.application.mapOptions && options.config.application.mapOptions.infoWms && !GV.Util.isTouch()) {
            GV.app.infoWmsManager = new GV.InfoWmsManager();
            GV.app.infoWmsManager.activate(this.map, options.config);
            GV.app.infoWmsList = new Backbone.Collection();
            GV.app.getContainer().append("<div id='gv-info-wms' class='draggable'></div>");
            this.addRegion('infowms', '#gv-info-wms');
        }


        // gestione eventi
        this.listenTo(GV.rlMaps, "add", this.onAddMap);
    },

    setDrag: function() {
        "use strict";
        interact('.draggable')
            .draggable({
                // enable inertial throwing
                inertia: true,
                // keep the element within the area of it's parent
                restrict: {
                    restriction: "parent",
                    endOnly: true,
                    elementRect: { top: 0, left: 0, bottom: 1, right: 1 }
                },
                // enable autoScroll
                autoScroll: true,

                // call this function on every dragmove event
                onmove: dragMoveListener,
                // call this function on every dragend event
                onend: function (event) {
                    var textEl = event.target.querySelector('p');

                    textEl && (textEl.textContent = 'moved a distance of ' + (Math.sqrt(event.dx * event.dx + event.dy * event.dy)|0) + 'px');
                }
            });

        function dragMoveListener (event) {
            var target = event.target,
            // keep the dragged position in the data-x/data-y attributes
                x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx,
                y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

            // translate the element
            target.style.webkitTransform = target.style.transform = 'translate(' + x + 'px, ' + y + 'px)';

            // update the posiion attributes
            target.setAttribute('data-x', x);
            target.setAttribute('data-y', y);
        }

        // this is used later in the resizing and gesture demos
        window.dragMoveListener = dragMoveListener;
    },

    render: function (options){
        "use strict";

        // aggiungo layer di base
        if (this.map && this.map.loadBaseLayers) {
            this.map.loadBaseLayers(options.config.baseLayers);
        }
        // aggiungo controlli
        if (this.map && this.map.loadControls) {
            this.map.loadControls(options);
        }

        // aggiungo toolbar
        if (this.config.toolbar) {
            this.addToolbars(this.config.toolbar);
        }

        return this;
    },

    addMapView: function (options) {
        "use strict";

        var mapView = new GV.Views.MapView();
        $(options.el).append(mapView.el);
        mapView.render(options);
        this.map = mapView.map;


    },


    addToolbars: function (toolbar) {
        "use strict";
        _.each(toolbar, function (tb) {
            var position = tb.position || "topleft";
            _.each(tb.items, function (item) {
                item.options = item.options || {};
                item.options.position = item.options.position || position;
                this.addButton(item);
            }, this);
        }, this);

    },

    addButton: function (item) {
        "use strict";

        if (GV.Buttons[item.name]) {
            var button = GV.Buttons[item.name](item.options, this.map);
            if (button) {
                button.name = item.name;
                this.controls.push(button);
                button.addTo(this.map);
            }
        } else {
            console.log("Bottone " + item.name + " non esistente");
        }
    },

    // Funzione richiamata quando si aggiungono mappe alla collection GV.rlMaps
    onAddMap: function(data){
        "use strict";
        var layers = data.attributes.layers.toJSON();
        this.map.loadLayers(layers);
    },

    getControl: function(controlName) {
        "use strict";
        return _.find(GV.app.layout.controls, function(control) {
            return control.name === controlName;
        });
    },

    getControlOption: function(controlName, optionName) {
        "use strict";
        var control = this.getControl(controlName);
        if (control) {
            return control.options[optionName];
        }
    }



});
GV.Views.LegendItem = Mn.CompositeView.extend({
    tagName: "ul",
    className: "gv-list-group",
    getTemplate: function () {

        var tpl;
        if (this.model.get("type") === "map") {
            tpl = [
                '<li class="gv-list-legend-map-item"><%= name %>',
                '<% if (!GV.app.layout.getControlOption("legend", "noInfoMap")){ %>',
                '<a class="gv-legend-map-info ms ms-information" title="Scheda metadati" href="/geoservices/REST/metadata/scheda_xml/<%= id %>?style=metadati.xsl" target="_blank"></a>',
                '<% } %>',
                '</li>'
            ].join('\n');
        } else {
            tpl = [
                '<li class= <%= (inRange) ? "gv-list-legend-layer-item" : "gv-list-legend-layer-disabled-item" %> >',
                '<img class="gv-legend-layer-icon" src="<%= legend.icon %>" width="24px" height="24px">',
                '<% if (inRange){ %>',
                '<span class="gv-layer-visibility-span"><input type="checkbox" class="gv-layer-visibility-cb" <%= (visible) ? "checked" : "" %> ></span>',
                '<% } else { %>',
                '<span class="gv-layer-visibility-span"><input type="checkbox" class="gv-layer-visibility-cb" disabled></span>',
                '<% } %>',
                '<span class="gv-layer-title-span"><%= legend.label %></span>',
                '</li>'
            ].join('\n');
        }
        return _.template(tpl);
    },
    initialize: function () {
        this.collection = this.model.get("layers");
        this.listenTo(this.collection, "change:inRange", this.onChangeInRangeLayer);
    },
    onChangeInRangeLayer: function (layer) {
        GV.Util.log('GV.Views.LegendItem: onChangeInRangeLayer');
        this.render();
    },
    events: {
        'click .gv-layer-visibility-cb': 'setLayerVisibility',
        'click .gv-legend-layer-icon': 'showLegendPanel'
        //,'click .gv-legend-map-info' : 'showMapInfo'
    },
    showLegendPanel: function (e) {
        "use strict";
        var layerConfig = this.model.attributes;
        if (layerConfig.inRange && (layerConfig.multiClasse || layerConfig.legend.popUpFlag)) {
            var url, html, width, height;
            if (layerConfig.legend.popUpUrl && layerConfig.legend.popUpFlag) {
                // se impostato attributo legendPopupUrl apro una finestra con il documento
                url = layerConfig.legend.popUpUrl;
                width = (GV.Util.SMALL_SCREEN) ? 400 : 600;
                height = (GV.Util.SMALL_SCREEN) ? 400 : 600;
            } else if (layerConfig.multiClasse) {
                // se livello multiclasse apro una finestra con la legenda dei livelli multiclasse
                if (layerConfig.flagGeoserver) {
                    var multiClassUrl = layerConfig.wmsParams.url + "LAYER=" + layerConfig.name + "&REQUEST=GetLegendGraphic&VERSION=1.0.0&FORMAT=image/png&WIDTH=20&HEIGHT=20&";
                    html = '<img src=' + multiClassUrl + '>';
                    width = 350;
                    height = 300;
                } else {
                    var classes = layerConfig.classes;
                    html = '<table width=100% border=0>';
                    _.each(classes, function (cls) {
                        html += '<tr>';
                        html += '<td width=30><img src="' + cls.legendIcon + '"></td>';
                        html += '<td >' + cls.legendLabel + '</td>';
                        html += '</tr>';
                    });
                    html += '</table>';
                }
            }
            var region = GV.app.layout.getRegion('gv-legend-multi');
            if (!region) {
                var cls;
                if (!GV.Util.isTouch()) {
                    cls = "draggable";
                }
                GV.app.getContainer().append("<div id='gv-legend-multi' class='" + cls + "'></div>");
                region = GV.app.layout.addRegion('gv-legend-multi', '#gv-legend-multi');
            }
            region.show(new GV.Views.HtmlPanelLayout({
                regionId: 'gv-legend-multi',
                title: 'LEGENDA - ' + layerConfig.legend.label,
                url: url,
                html: html,
                width: width,
                height: height,
                closeAction: function() {
                }
            }));
        }
    },

    setLayerVisibility: function (e) {
        var layerConfig = this.model.attributes;
        if (layerConfig.type !== "map") {
            var checked = e.currentTarget.checked;
            e.stopPropagation();
            this.model.set("visible", checked);
            GV.app.map.setLayerVisible(layerConfig, checked);
        }
    }
});

GV.Views.LegendBody = Mn.CollectionView.extend({
    tagName: "ul",
    className: "gv-list-group",
    childView: GV.Views.LegendItem
});

GV.Views.LegendTitle = Mn.View.extend({
    className: 'gv-panel-title gv-bgcolor',
    events: {
        'click .gv-close': 'hideLegend',
        'click .gv-legend-add': 'addMap'
    },
    hideLegend: function () {
//                $('#gv-legend').fadeOut("slow");
        $('#gv-legend').css({display: 'none'});
        $('#gv-legend-button').css({display: 'block'});
    },
    addMap: function () {
        //TODO finestra aggiungi mappa
    },
    getTemplate: function () {
        var tpl = [
            '<div>',
            '<b>LEGENDA</b>',
            '<button class="gv-close" type="button">Ã</button>',
            '<% if (!noAddMapButton){ %>',
                '<button class="gv-legend-add ms ms-layers-add" title="Aggiungi Mappa" type="button"></button>',
            '<% } %>',
            '</div>',
            ''
        ].join('\n');
        return _.template(tpl)({
            noAddMapButton: this.options.noAddMap
        });
    }
});

GV.Views.LegendLayout = Mn.View.extend({
    template: _.template("<div id='gv-legend-title'></div><div id='gv-legend-body'></div>"),
    regions: {
        title: "#gv-legend-title",
        body: "#gv-legend-body"
    },
    onRender: function() {
        "use strict";
        this.showChildView('title', new GV.Views.LegendTitle({ noAddMap: this.options.noAddMap }));
        this.showChildView('body', new GV.Views.LegendBody({ collection: GV.rlMaps }));
    }
});

GV.Views.MapView = Backbone.View.extend({
    id: "gv-map",
    render: function (options) {
        'use strict';

        // creazione mappa leaflet
        var mapType = options.mapType || 'leaflet';
        if (mapType === 'leaflet') {
            this.map = new GV.Map(options);
        }

        return this;
    }
});
