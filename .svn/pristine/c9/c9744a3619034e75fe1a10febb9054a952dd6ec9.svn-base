/**
 * Created by parodi on 02/08/2016.
 */

GV.Util = function () {
    "use strict";

    // Public API
    return {

        /**
         *  Function: getUrlParam
         *
         *  Ritorna il valore di un parametro nella queryString
         *
         *  Parameters:
         *  paramName - {String} Nome del parametro
         *
         *  Returns:
         *  {String} Valore del parametro (se non trovato ritorna 0)
         *
         */

        getUrlParam: function (paramName) {
            var results = new RegExp("[\\?&]" + paramName + "=([^&#]*)").exec(window.location.href);
            GV.Util.log("GV.Util.getUrlParam");

            return results ? decodeURIComponent(results[1]) : null;
        },

        /**
         *  Function: getUrlParam
         *
         *  Ritorna il valore di un parametro nella queryString
         *
         *  Parameters:
         *  url - {String} Stringa contenente la URL
         *  paramName - {String} Nome del parametro
         *
         *  Returns:
         *  {String} Valore del parametro (se non trovato ritorna 0)
         *
         */

        getUrlParamFromString: function (url, paramName) {
            var results = new RegExp("[\\?&]" + paramName + "=([^&#]*)").exec(url);
            if (!results) {
                return 0;
            }
            return results[1] || 0;
        },

        /**
         *  Function: log
         *
         *  Scrive un messaggio sulla console
         *
         *  Parameters:
         *  msg - {String} Messaggio da scrivere
         *
         */

        log: function (message, level) {
            var action = "log";

            if (!GV.debug) {
                return;
            }

            switch (level) {
            case 0:
                action = "warn";
                break;
            case 1:
            case 2:
                action = "error";
                break;
            default:
                action = "info";
                break;
            }

            try {
                console[action](message);
            } catch (e) {
            }
        },

        /**
         *  Function: msgBox
         *
         *  Manda un alert di avviso all'utente
         *
         *  Parameters:
         *  msg - {string} Messaggio da scrivere sull'alert
         *
         */

        msgBox: function (msg) {
            window.alert(msg);
        },


        setUnderscoreTemplate: function () {
            if (_) {
                _.templateSettings = {
                    interpolate: /\{\{(.+?)\}\}/g
                };
            }
        },

        /**
         * Function: getXML
         *
         * Funzione per caricare un oggetto xml remoto
         *
         * Ritorna un oggetto xml
         *
         */
        getXML: function (options, callback) {
            var url = options.url,
                data = options.data,
                method = options.method;

            $.ajax({
                url: url,
                dataType: (GV.Util.isBrowserIE()) ? "text" : "xml",
                data: data,
                method: method || 'GET'
            }).done(function (response) {
                try {
                    var xml = response;
                    if (GV.Util.isBrowserIE()) {    // Only for IE
                        var xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                        xmlDoc.async = "false";
                        xmlDoc.loadXML(response);
                        xml = xmlDoc;
                    }
                    callback(xml);
                } catch (exception) {
                    console.log(exception);
                }
            });

        },

        /**
         * Function: parseXML
         *
         * Funzione per fare il parsing di una stringa xml
         *
         * Ritorna un oggetto doc xml
         *
         * Parameters:
         * xmlString - {String} Stringa xml
         *
         * Returns:
         * {object} Oggetto xmlDoc
         *
         */
        parseXML: function (xmlString) {
            GV.Util.log("GV.Util.parseXML");
            try {
                var xmlDoc = null;
                if (window.DOMParser && window.XSLTProcessor) {
                    var parser = new DOMParser();
                    xmlDoc = parser.parseFromString(xmlString, "text/xml");
                } else {
                    xmlDoc = new ActiveXObject("Msxml2.DOMDocument.3.0");
                    xmlDoc.async = false;
                    xmlDoc.loadXML(xmlString);
                }
                return xmlDoc;
            } catch (exception) {
                throw {
                    name: "xmlTransformation",
                    message: "GV.Util.parseXml: errore parsing xml - " + exception.message,
                    level: 1
                };
            }
        },


        /**
         *
         * Function: isPointInLig
         *
         * Controlla se un punto appartenga al BBOX del territorio ligure
         *
         * Parameters:
         * x - {number} Coordinata X
         * y - {number} Coordinata Y
         *
         * Returns:
         * {boolean} true/false
         *
         */
        isPointInLig: function (x, y) {
            GV.Util.log("GV.Util.isPointInLig");

            if (!x || !y) {
                return false;
            }

            var minX = 7.4, minY = 43.7, maxX = 10.1, maxY = 44.8;

            return (x > minX) && (x < maxX) && (y > minY) && (y < maxY);
        },

        /**
         * Function: toArray
         *
         * Converte Oggetto in Array
         *
         * Parameters:
         * obj - {Object} Oggetto da clonare
         *
         * Returns:
         * {Array} Array
         *
         */
        toArray: function (obj) {
            return Array.prototype.slice.call(obj);
        },

        /**
         * Function: bind
         *
         * Effettua la bind di una funzione ad uno scope
         *
         * Parameters:
         * scope - {Object} Oggetto da utilizzare come scope
         * fn - {Function} Funzione su cui effettuare la bind
         *
         * Returns:
         * {Function} Funzione con bind effettuato
         *
         */
        bind: function (scope, fn) {
            return function () {
                return fn.apply(scope, GV.Util.toArray(arguments));
            };
        },

        /**
         * Function: getArrayElementByAttribute
         *
         * Ritorna un elemento di un array contenente un attributo con un determinato valore
         *
         * Parameters:
         * array - {Array} array su cui cercare l'elemento
         * attributo - {string} Nome dell'attributo dell'elemento
         * value - {string} Valore dell'attributo
         *
         * Returns:
         * {Object} Oggetto
         *
         */
        getArrayElementByAttribute: function (array, attribute, value) {
            if (!array) {
                return null;
            }

            var i,
                len = array.length;

            for (i = 0; i < len; i++) {
                if (array[i][attribute] === value) {
                    return array[i];
                }
            }

            return null;
        },
        /**
         * Function: geoCode
         *
         * Effettua il geocode di un indirizzo utilizzando i servizi google
         *
         * Parameters:
         * address - {string} Indirizzo
         * properties - {Object} oggetto contenente le proprietÃ  da aggiungere all'oggetto properties della feature
         * callback - {function} funzione di callback
         *
         * Returns:
         * {GeoJSON Object}
         *
         */
        geoCode: function (address, properties, callback) {

            var geocoder = new google.maps.Geocoder();

            geocoder.geocode({"address": address}, function (results, status) {
                if (status === google.maps.GeocoderStatus.OK) {

                    var x = results[0].geometry.location.lng();
                    var y = results[0].geometry.location.lat();
                    var feature = {
                        "type": "FeatureCollection",
                        "features": [
                            {
                                "type": "Feature",
                                "geometry": {"type": "Point", "coordinates": [x, y]},
                                "properties": {
                                    "address": address
                                }
                            }
                        ]
                    };
                    if (properties) {
                        for (var p in properties) {
                            if (properties.hasOwnProperty(p)) {
                                feature.features[0].properties[p] = properties[p];
                            }
                        }
                    }
                    callback(feature);
                } else {
                    if (status === google.maps.GeocoderStatus.ZERO_RESULTS) {
                        GV.Util.msgBox("Indirizzo '" + address + "' non trovato");
                    } else {
                        console.error("Errore di geocoding: " + status);
                    }
                }
            });

        },

        getParamString: function (obj, existingUrl, uppercase) {
            var params = [];
            for (var i in obj) {
                params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
            }
            return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
        },

        template: function (str, data) {
            var templateRe = /\{ *([\w_\-]+) *\}/g;
            return str.replace(templateRe, function (str, key) {
                var value = data[key];

                if (value === undefined) {
                    throw new Error('No value provided for variable ' + str);

                } else if (typeof value === 'function') {
                    value = value(data);
                }
                return value;
            });
        },

        getZoomFromScaleDenom: function (scaleDenom) {
            return _.findIndex(GV.Globals.BASE_SCALES, function (scale) {
                return scaleDenom > scale;
            });
        },

        getScaleLabelsFromZoom: function (zoom) {
            return GV.Globals.BASE_SCALE_LABELS[zoom]
        },

        getScaleFromZoom: function (zoom) {
            return GV.Globals.BASE_SCALES[zoom]
        },

        endsWith: function (str, suffix) {
            return str.indexOf(suffix, str.length - suffix.length) !== -1;
        },

        enableDrag: function (divId) {
            function drag_start(event) {
                var style = window.getComputedStyle(event.target, null);
                if (L.Browser.ie) {
                    event.dataTransfer.setData("text", '' + (parseInt(style.getPropertyValue("left"),10) - event.clientX) + ',' + (parseInt(style.getPropertyValue("top"),10) - event.clientY));
                } else {
                    event.dataTransfer.setData("text/plain", (parseInt(style.getPropertyValue("left"),10) - event.clientX) + ',' + (parseInt(style.getPropertyValue("top"),10) - event.clientY));
                }
            }

            function drag_over(event) {
                event.preventDefault();
                return false;
            }

            function drop(event) {
                var offset;
                if (L.Browser.ie) {
                    offset = event.dataTransfer.getData("text").split(',');
                } else {
                    offset = event.dataTransfer.getData("text/plain").split(',');
                }
                var dm = document.getElementById(divId);
                dm.style.left = (event.clientX + parseInt(offset[0],10)) + 'px';
                dm.style.top = (event.clientY + parseInt(offset[1],10)) + 'px';
                event.preventDefault();
                return false;
            }
            var dm = document.getElementById(divId);
            dm.addEventListener('dragstart',drag_start,false);
            document.body.addEventListener('dragover',drag_over,false);
            document.body.addEventListener('drop',drop,false);
        },

        isTouch: function () {
            return window.matchMedia('(pointer: coarse)').matches;
            //return false;
        },

        isBrowserIE: function () {
            return navigator.userAgent.indexOf("MSIE ") > 0 || navigator.userAgent.indexOf("Trident") > 0 || navigator.userAgent.indexOf("Edge") > 0;
        }
    };
}();

