/**
 * Created by parodi on 02/08/2016.
 */

LdMaps.Util = (function(){

    /*global LdMaps:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false , console:false  , opera:false  , google:false  */
    "use strict";

    //TODO rivedere
    //TODO eliminare OpenLayers
    /*
     *  PROPRIETA' PRIVATE
     */

    /*
     *  METODI PRIVATI
     */

    //  Ritorna il valore di un parametro nella queryString
    function getUrlParam(paramName) {

        LdMaps.Util.log("LdMaps.Util.getUrlParam");

        var results = new RegExp("[\\?&]" + paramName + "=([^&#]*)").exec(window.location.href);
//        if (!results) { return 0; }
//        return results[1] || 0;

        return results? decodeURIComponent(results[1]) : null;

    }

    //  Ritorna il valore di un parametro nella queryString
    function getUrlParamFromString(url,paramName) {

        LdMaps.Util.log("LdMaps.Util.getUrlParam");

        var results = new RegExp("[\\?&]" + paramName + "=([^&#]*)").exec(url);
        if (!results) { return 0; }
        return results[1] || 0;

    }

    function assert(condition, error){
        if (!condition){
            throw error;
        }
    }

    // Gestione Exception
    // level:
    // - 0 = warning (non viene mandato messaggio all'utente
    // - 1 = errore
    // - 2 = errore bloccante
    function handleException(exception){

        LdMaps.Util.log(exception.message,exception.level);

        if (exception.level>0)
        {
            LdMaps.Util.messageBox(exception.message);
        }

    }



    // Scrive un messaggio sulla console
    // level:
    // - undefined = info
    // - 0 = warn
    // - 1/2 = error

    function log(message,level) {
return;
        if (!LdMaps.debug) {
            return;
        }

        var action = "log";

        switch (level) {
            case undefined:
                action = "info";
                break;
            case 0:
                action = "warn";
                break;
            case 1: case 2:
                action = "error";
                break;
        }

        try {
            console[action]( message );
        } catch(e) {}
    }

    //  Manda un alert di avviso all'utente
    function messageBox(msg) {
        if (Ext) {
            Ext.MessageBox.show({
                title: '',
                msg: msg,
                buttons: {ok: 'OK'}
            });
        } else {
            window.alert(msg);
        }
    }

    // Funzione per caricare un oggetto json remoto con protocollo JSONP.
    function getJSONP(url,urlParams,callBack) {

        LdMaps.Util.log("LdMaps.Util.getJSONP");

        // funzione richiamata in caso di errore http
        function onErrorCB(jqXHR, textStatus, errorThrown) {
            throw {
                name: "BadAjaxCall",
                message: "LdMaps.Util.getJSONP - Non sono riuscito a caricare la url:\n" + url + "\nErrore: " + jqXHR.status + " - " + textStatus + " - " + errorThrown,
                level: 1
            };
        }

        $.ajax({
            url: url,
            dataType: "jsonp",
            data: urlParams,
            contentType: "application/javascript",
            type: "GET"
        }).done(function(json) {
            try {
                callBack(json);
            }
            catch (exception) {
                LdMaps.Util.handleException(exception);
            }
        }).fail(function(jqXHR, textStatus, errorThrown) {
            if (jqXHR.statusText !== "OK") {
                try {
                    onErrorCB(jqXHR, textStatus, errorThrown);
                }
                catch (exception) {
                    LdMaps.Util.handleException(exception);
                }
            }
        });

    }

    // Funzione per caricare un oggetto json remoto in maniera sincrona o asincrona.
    function getJSON(url,urlParams,aSync,callBack,args) {

        LdMaps.Util.log("LdMaps.Util.getJSON");


        function onErrorCB(textStatus, errorThrown, url) {
            throw {
                name: "BadAjaxCall",
                message: "LdMaps.Util.getJSON: " + url + " - " + errorThrown,
                level: 1
            };
        }

        $.ajax({
            type: "GET",
            url: url,
            dataType: "json",
            success: function(json) {
                try {
                    callBack(json,args);
                }
                catch (exception) {
                    LdMaps.Util.handleException(exception);
                }
            },
            error: function(jqXHR, textStatus, errorThrown) {
                try {
                    onErrorCB(textStatus,errorThrown,url);
                }
                catch (exception) {
                    LdMaps.Util.handleException(exception);
                }

            },
            data: urlParams,
            async: aSync
        });

    }

    // Funzione per caricare un oggetto xml remoto in maniera sincrona o asincrona.
    function getXML(url,urlParams,aSync,callBack,args) {

        LdMaps.Util.log("LdMaps.Util.getXML");


        function onErrorCB(textStatus, errorThrown, url) {
            throw {
                name: "BadAjaxCall",
                message: "LdMaps.Util.getXML: " + url + " - " + errorThrown,
                level: 1
            };
        }

        $.ajax({
            type: "GET",
            url: url,
            dataType: "xml",
            beforeSend: function (xhr, settings) {
                try { xhr.responseType = "msxml-document"; } catch(err){}
            },
            success: function(data) {
                try {
                    callBack(data,args);
                }
                catch (exception) {
                    LdMaps.Util.handleException(exception);
                }
            },
            error: function(jqXHR, textStatus, errorThrown) {
                try {
                    onErrorCB(textStatus,errorThrown,url);
                }
                catch (exception) {
                    LdMaps.Util.handleException(exception);
                }

            },
            data: urlParams,
            async: aSync
        });

    }

    // Funzione per fare il parsing xml
    // ritorna un xmlDoc
    function parseXML(xmlString) {

        LdMaps.Util.log("LdMaps.Util.parseXML");
        try {
            var xmlDoc = null;
            if (window.DOMParser && window.XSLTProcessor) {
                var parser = new DOMParser();
                xmlDoc = parser.parseFromString(xmlString,"text/xml");
            } else {
//                xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                xmlDoc = new ActiveXObject("Msxml2.DOMDocument.3.0");
                xmlDoc.async = false;
                xmlDoc.loadXML(xmlString);
            }
            return xmlDoc;
        } catch (exception) {
            throw {
                name: "xmlTransformation",
                message: "LdMaps.Util.parseXml: errore parsing xml - " + exception.message ,
                level: 1
            };
        }
    }
    // Controlla se un punto appartiene al BBOX del territorio ligure
    function isPointInLig(x,y){

        LdMaps.Util.log("LdMaps.findManager.isPointInLig");

        if (!x || !y) {
            return false;
        }
        var minX = 7.4,
            minY = 43.7,
            maxX = 10.1,
            maxY = 44.8;

        return (x > minX) && (x < maxX) && (y > minY) && (y < maxY);

    }

/*
    // controlla che il punto ricada dentro la finestra di maxExtent
    function isPointInMaxExtent(lat,lon,map,epsg) {

        if (!map) {
            return true;
        }
        if (!map.restrictedExtent) {
            return true;
        }

        var pointEpsg = epsg || "EPSG:4326";

        var point = new OpenLayers.LonLat(lon,lat);
        if (map.projection !== pointEpsg) {
            point.transform(
                new OpenLayers.Projection(pointEpsg),
                map.getProjectionObject()
            );
        }

        var minX = map.restrictedExtent.left,
            minY = map.restrictedExtent.bottom,
            maxX = map.restrictedExtent.right,
            maxY = map.restrictedExtent.top,
            x = point.lon,
            y = point.lat;

        return (x > minX) && (x < maxX) && (y > minY) && (y < maxY);

    }

*/
/*

    // Trasforma un bound in forma string da un sistema di coordinate ad un altro
    function transformStrBounds(fromProjStr,toProjStr,boundsStr){

        LdMaps.Util.log("LdMaps.Util.transformStrBounds");

        var fromProj = new OpenLayers.Projection(fromProjStr),
            toProj = new OpenLayers.Projection(toProjStr);

        var boundStrIn = boundsStr;
        // Hack per shift lungo asse Y e y
        if (fromProjStr === "EPSG:3003") {
            var boundArray = boundStrIn.split(",");
            boundArray[0] = parseInt(boundArray[0]) - parseInt(40);
            boundArray[2] = parseInt(boundArray[2]) - parseInt(40);
            boundArray[1] = parseInt(boundArray[1]) + parseInt(170);
            boundArray[3] = parseInt(boundArray[3]) + parseInt(170);
            boundStrIn = boundArray.join(",");
        }
        var bounds = new OpenLayers.Bounds.fromString(boundStrIn);
        return bounds.transform(fromProj, toProj).toString();

    }

*/

    // Clona un oggetto JS
    function cloneObj(inObj){
        return jQuery.extend({}, inObj);
    }

    // Public API
    return {

        /**
         *  Function: getUrlParam
         *
         *  Ritorna il valore di un parametro nella queryString
         *
         *  Parameters:
         *  paramName - {String} Nome del parametro
         *
         *  Returns:
         *  {String} Valore del parametro (se non trovato ritorna 0)
         *
         */

        getUrlParam : getUrlParam,

        /**
         *  Function: getUrlParam
         *
         *  Ritorna il valore di un parametro nella queryString
         *
         *  Parameters:
         *  url - {String} Stringa contenente la URL
         *  paramName - {String} Nome del parametro
         *
         *  Returns:
         *  {String} Valore del parametro (se non trovato ritorna 0)
         *
         */

        getUrlParamFromString : getUrlParamFromString,

        /**
         *  Function: log
         *
         *  Scrive un messaggio sulla console
         *
         *  Parameters:
         *  msg - {String} Messaggio da scrivere
         *
         */

        log : log,

        /**
         *  Function: messageBox
         *
         *  Manda un alert di avviso all'utente
         *
         *  Parameters:
         *  msg - {string} Messaggio da scrivere sull'alert
         *
         */

        messageBox : messageBox,

        /**
         *  Function: assert
         *
         *  Assert per i controlli.
         *
         *  Controlla che l'espressione passata sia vera, altrimenti effettua la throw dell'errore
         *
         *  Parameters:
         *  test - {Expression} Condizione da verificare
         *  error - {Object} Oggetto errore
         *
         */

        assert : assert,

        /**
         * Function: handleException
         *
         * Gestione exception
         *
         * Parameters:
         * exception - {Object} Oggetto exception
         *
         */
        handleException: handleException,

        /**
         * Function: getJSON
         *
         * Funzione per caricare un oggetto json remoto in maniera sincrona o asincrona.
         *
         * Ritorna un oggetto javascript contentente la deserializzazione del json
         *
         * Parameters:
         * url - {String} Url del file o del servizio
         * urlParams - {Object} Oggetto map contenente i parametri da passare. Vedi http://api.jquery.com/jQuery.ajax/
         * aSync - {Boolean} Flag che indica se effettuare una richiesta asincrona
         * callBack {Function} Funzione da richiamare dopo il caricamento
         * args - {Object/Array} Aregomento o Array degli argumuments opzionali dal passare alla funzione di callback
         *
         * Returns:
         * {object} L'oggetto contenente la deserializzazione del JSON
         *
         */
        getJSON: getJSON,

        /**
         * Function: parseXML
         *
         * Funzione per fare il parsing di una stringa xml
         *
         * Ritorna un oggetto doc xml
         *
         * Parameters:
         * xmlString - {String} Stringa xml
         *
         * Returns:
         * {object} Oggetto xmlDoc
         *
         */
        parseXML: parseXML,


        /**
         * Function: getXML
         *
         * Funzione per caricare un oggetto xml remoto in maniera sincrona o asincrona.
         *
         * Ritorna un oggetto javascript contentente la deserializzazione del xml
         *
         * Parameters:
         * url - {String} Url del file o del servizio
         * urlParams - {Object} Oggetto map contenente i parametri da passare. Vedi http://api.jquery.com/jQuery.ajax/
         * aSync - {Boolean} Flag che indica se effettuare una richiesta asincrona
         * callBack {Function} Funzione da richiamare dopo il caricamento
         * args - {Object/Array} Aregomento o Array degli argumuments opzionali dal passare alla funzione di callback
         *
         * Returns:
         * {object} L'oggetto contenente la deserializzazione del JSON
         *
         */
        getXML: getXML,
        /**
         * Function: getJSONP
         *
         * Funzione per caricare un oggetto json remoto utilizzando il protocollo JSONP.
         *
         * Ritorna un oggetto javascript contentente la deserializzazione del json
         *
         * Parameters:
         * url - {String} Url del file o del servizio
         * urlParams - {Object} Oggetto map contenente i parametri da passare. Vedi http://api.jquery.com/jQuery.ajax/
         * callBack {Function} Funzione da richiamare dopo il caricamento
         *
         * Returns:
         * {object} L'oggetto contenente la deserializzazione del JSON
         *
         */
        getJSONP: getJSONP,


        /**
         *
         * Function: isPointInLig
         *
         * Controlla se un punto appartenga al BBOX del territorio ligure
         *
         * Parameters:
         * x - {number} Coordinata X
         * y - {number} Coordinata Y
         *
         * Returns:
         * {boolean} true/false
         *
         */
        isPointInLig: isPointInLig,


        /**
         *
         * Function: isPointInMaxExtent
         *
         * Controlla se un punto è all'interno del maxExtent della mappa
         *
         * Parameters:
         * lat - {number} Latitudine WGS84
         * lon - {number} Longitudine WGS84
         *
         * Returns:
         * {boolean} true/false
         *
         */
        //isPointInMaxExtent: isPointInMaxExtent,

        /**
         * Function: transformStrBounds
         *
         * Trasforma un bound in forma string da un sistema di coordinate ad un altro
         *
         * Parameters:
         * fromProjStr - {string} Codice EPSG del sistema di coordinate di partenza (es: "EPSG:3003")
         * toProjStr - {string} Codice EPSG del sistema di coordinate di arrivo
         *
         * Returns:
         * {string} Stringa del bound con coordinate separate da virgole
         *
         */
        //transformStrBounds: transformStrBounds,

        /**
         * Function: cloneObj
         *
         * Clona oggetto JS (deep copy)
         *
         * Parameters:
         * inObj - {Object} Oggetto da clonare
         * Returns: {Object} Oggetto clonato
         *
         */
        cloneObj: cloneObj,

        /**
         * Function: toArray
         *
         * Converte Oggetto in Array
         *
         * Parameters:
         * obj - {Object} Oggetto da clonare
         *
         * Returns:
         * {Array} Array
         *
         */
        toArray: function(obj) {
            return Array.prototype.slice.call(obj);
        },

        /**
         * Function: bind
         *
         * Effettua la bind di una funzione ad uno scope
         *
         * Parameters:
         * scope - {Object} Oggetto da utilizzare come scope
         * fn - {Function} Funzione su cui effettuare la bind
         *
         * Returns:
         * {Function} Funzione con bind effettuato
         *
         */
        bind: function(scope, fn) {
            return function() {
                return fn.apply(scope, LdMaps.Util.toArray(arguments));
            };
        },

        /**
         * Function: getArrayElementByAttribute
         *
         * Ritorna un elemento di un array contenente un attributo con un determinato valore
         *
         * Parameters:
         * array - {Array} array su cui cercare l'elemento
         * attributo - {string} Nome dell'attributo dell'elemento
         * value - {string} Valore dell'attributo
         *
         * Returns:
         * {Object} Oggetto
         *
         */
        getArrayElementByAttribute: function(array,attribute,value) {
            if (!array) {
                return null;
            }

            var i,
                len = array.length;

            for (i = 0; i < len; i++) {
                if (array[i][attribute] === value) {
                    return array[i];
                }
            }

            return null;
        },
        /**
         * Function: geoCode
         *
         * Effettua il geocode di un indirizzo utilizzando i servizi google
         *
         * Parameters:
         * address - {string} Indirizzo
         * properties - {Object} oggetto contenente le proprietà da aggiungere all'oggetto properties della feature
         * callback - {function} funzione di callback
         *
         * Returns:
         * {GeoJSON Object}
         *
         */
        geoCode: function(address,properties,callback) {

            var geocoder = new google.maps.Geocoder();

            geocoder.geocode({ "address": address }, function(results, status) {
                if (status === google.maps.GeocoderStatus.OK) {

                    var x = results[0].geometry.location.lng();
                    var y = results[0].geometry.location.lat();
                    var feature = { "type": "FeatureCollection",
                        "features": [
                            { "type": "Feature",
                                "geometry": {"type": "Point", "coordinates": [x, y]},
                                "properties": {
                                    "address" : address
                                }
                            }
                        ]
                    };
                    if (properties) {
                        for (var p in properties) {
                            if (properties.hasOwnProperty(p)) {
                                feature.features[0].properties[p] = properties[p];
                            }
                        }
                    }
                    callback(feature);
                } else {
                    if (status === google.maps.GeocoderStatus.ZERO_RESULTS) {
                        LdMaps.Util.messageBox("Indirizzo '" + address + "' non trovato");
                    } else {
                        LdMaps.Util.handleException({
                            name: "BadGeocoding",
                            message: "Errore di geocoding: " + status,
                            level: 1
                        });
                    }
                }
            });

        },

        /**
         * Function: unescapeHtmlEntities
         *
         * Decodifica caratteri html da una stringa contenente caratteri speciali codificati :
         * &amp; (&)
         * &quot; (")
         * &lt; (<)
         * &gt; (>)
         *
         * Parameters:
         * encodedString - {String} Stringa da decodificare
         *
         * Returns:
         * {String} - Stringa decodificata
         *
         * */
        unescapeHtmlEntities: function(encodedString) {
            encodedString= encodedString.replace(/\&amp;/g,'&');
            encodedString= encodedString.replace(/\&quot;/g,'\"');
            encodedString= encodedString.replace(/\&lt;/g,'<');
            encodedString= encodedString.replace(/\&gt;/g,'>');
            return encodedString;
        },

        /**
         * Function: loadMarker
         *
         * Carica un marker sul layer per le ricerche (findLayer)
         *
         * Parameters:
         * initConfig - {Object} Oggetto Configurazione
         *  - map - {LdMaps.Map} MAppa su cui caricare il marker
         *  - x - {Number} Coordinata X del marker
         *  - y - {Number} Coordinata Y del marker
         *  - classes - {Object} Stile di vestizione del marker
         *  - label - {String} Etichetta
         *  - epsgCode - {String} Codice EPSG (nel formato "EPSG:3003")
         */
/*
        loadMarker: function (initConfig){

            var classes,
                hiliteLayer,
                featureStr,
                feature,
                config,
                label,
                x,
                y,
                layerConfig,
                epsgCode,
                map,
                zoomLevel,
                setInitialExtent;

            map = initConfig.map;
            x = initConfig.x;
            y = initConfig.y;
            classes = initConfig.classes;
            label = initConfig.label;
            epsgCode = initConfig.epsgCode;
            zoomLevel = initConfig.zoomLevel;
            setInitialExtent = initConfig.setInitialExtent;

            if (epsgCode && epsgCode !== "EPSG:4326") {
                var point = new OpenLayers.LonLat(x,y);
                point.transform(
                    new OpenLayers.Projection(epsgCode),
                    new OpenLayers.Projection("EPSG:4326")
                );
                x = point.lon;
                y = point.lat;
            }

            layerConfig = {
                name: "findLayer",
                format: "GeoJSON",
                classes: classes
            };
            hiliteLayer = map.layerManager.createVectorLayer(layerConfig);

            // carico l'oggetto sul layer
            featureStr = "{ \"type\": \"FeatureCollection\",\"features\": [{ \"type\": \"Feature\",";
            featureStr += "\"geometry\": {\"type\": \"Point\", \"coordinates\": [" + x + "," + y + " ]},";
            featureStr += "\"properties\": {\"label\": \"" + label + "\"}}]}";
            feature = jQuery.parseJSON(featureStr);

            config = {
                layer: hiliteLayer,
                features: feature,
                url: null,
                epsgCode: epsgCode,
                options: {
                    zoom: initConfig.zoom,
                    clean: true,
                    zoomLevel : zoomLevel,
                    setInitialExtent : setInitialExtent
                }
            };

            LdMaps.featureLoader.loadFeatures(config);

        },
        */

        /**
         * Function: getWFSBound
         *
         * Ritorna il bound degli elementi attraverso un servizio WFS
         *
         * Parameters:
         * wfsUrl - {string} URL del servizio WFS
         * typeName - {string} nome della feature
         * sldFilter - {string} Filtro SLD
         * map - {OpenLayers.Map} Mappa OL
         * callback - {Function} Funzione di callback da richiamare
         *
         * Returns:
         * {OpenLayers.Bound}
         *
         */

/*
        getWFSBound: function (wfsUrl,typeName,sldFilter,map,callback){

            LdMaps.Util.getXML(
                wfsUrl,
                null,
                true,
                function (wfsResponse) {

                    if (wfsResponse) {
                        var json = $.xml2json(wfsResponse),
                            bbox = null,
                            srs = null,
                            bounds;
                        var exception = {};

                        // Gestione Exception server WFS
                        var serviceException = json["ServiceException"];
                        if (serviceException) {
                            exception.message = "LdMaps.Util.getWFSBound - Service Exception: " + serviceException.text;
                            exception.level = 2;
                            LdMaps.Util.handleException(exception);
                            return;
                        }
                        // Prendo il bbox
                        var boundedBy = json["boundedBy"] || json["gml:boundedBy"];
                        if (boundedBy) {
                            // Gestione not found
                            if (boundedBy["null"] || boundedBy["gml:null"]) {
                                exception.message = "LdMaps.Util.getWFSBound - elemento non trovato";
                                exception.level = 2;
                                LdMaps.Util.handleException(exception);
                                return;
                            }
                            if(boundedBy["Box"]) {
                                bbox = boundedBy["Box"]["coordinates"];
                                srs = boundedBy["Box"].srsName;
                            } else {
                                bbox = boundedBy["gml:Box"]["gml:coordinates"];
                                srs = boundedBy["gml:Box"].srsName;
                            }
                            if (bbox && srs) {
                                callback(OpenLayers.Bounds.fromString(LdMaps.Util.transformStrBounds(srs, map.projection, bbox.replace(" ", ","))));
                                return;
                            }
                        }
                        // se non trovo bbox e srs
                        exception.message = "LdMaps.Util.getWFSBound - bbox non ritornato dal servizio ";
                        exception.level = 1;
                        LdMaps.Util.handleException(exception);
                    }

                }
            )
        },
*/

        // Funzione per il decode di html
        htmlDecode: function (string, quote_style) {

            function get_html_translation_table (table, quote_style) {
                var entities = {},
                    hash_map = {},
                    decimal;
                var constMappingTable = {},
                    constMappingQuoteStyle = {};
                var useTable = {},
                    useQuoteStyle = {};

                // Translate arguments
                constMappingTable[0] = 'HTML_SPECIALCHARS';
                constMappingTable[1] = 'HTML_ENTITIES';
                constMappingQuoteStyle[0] = 'ENT_NOQUOTES';
                constMappingQuoteStyle[2] = 'ENT_COMPAT';
                constMappingQuoteStyle[3] = 'ENT_QUOTES';

                useTable = !isNaN(table) ? constMappingTable[table] : table ? table.toUpperCase() : 'HTML_SPECIALCHARS';
                useQuoteStyle = !isNaN(quote_style) ? constMappingQuoteStyle[quote_style] : quote_style ? quote_style.toUpperCase() : 'ENT_COMPAT';

                if (useTable !== 'HTML_SPECIALCHARS' && useTable !== 'HTML_ENTITIES') {
                    throw new Error("Table: " + useTable + ' not supported');
                    // return false;
                }

                entities['38'] = '&amp;';
                if (useTable === 'HTML_ENTITIES') {
                    entities['160'] = '&nbsp;';
                    entities['161'] = '&iexcl;';
                    entities['162'] = '&cent;';
                    entities['163'] = '&pound;';
                    entities['164'] = '&curren;';
                    entities['165'] = '&yen;';
                    entities['166'] = '&brvbar;';
                    entities['167'] = '&sect;';
                    entities['168'] = '&uml;';
                    entities['169'] = '&copy;';
                    entities['170'] = '&ordf;';
                    entities['171'] = '&laquo;';
                    entities['172'] = '&not;';
                    entities['173'] = '&shy;';
                    entities['174'] = '&reg;';
                    entities['175'] = '&macr;';
                    entities['176'] = '&deg;';
                    entities['177'] = '&plusmn;';
                    entities['178'] = '&sup2;';
                    entities['179'] = '&sup3;';
                    entities['180'] = '&acute;';
                    entities['181'] = '&micro;';
                    entities['182'] = '&para;';
                    entities['183'] = '&middot;';
                    entities['184'] = '&cedil;';
                    entities['185'] = '&sup1;';
                    entities['186'] = '&ordm;';
                    entities['187'] = '&raquo;';
                    entities['188'] = '&frac14;';
                    entities['189'] = '&frac12;';
                    entities['190'] = '&frac34;';
                    entities['191'] = '&iquest;';
                    entities['192'] = '&Agrave;';
                    entities['193'] = '&Aacute;';
                    entities['194'] = '&Acirc;';
                    entities['195'] = '&Atilde;';
                    entities['196'] = '&Auml;';
                    entities['197'] = '&Aring;';
                    entities['198'] = '&AElig;';
                    entities['199'] = '&Ccedil;';
                    entities['200'] = '&Egrave;';
                    entities['201'] = '&Eacute;';
                    entities['202'] = '&Ecirc;';
                    entities['203'] = '&Euml;';
                    entities['204'] = '&Igrave;';
                    entities['205'] = '&Iacute;';
                    entities['206'] = '&Icirc;';
                    entities['207'] = '&Iuml;';
                    entities['208'] = '&ETH;';
                    entities['209'] = '&Ntilde;';
                    entities['210'] = '&Ograve;';
                    entities['211'] = '&Oacute;';
                    entities['212'] = '&Ocirc;';
                    entities['213'] = '&Otilde;';
                    entities['214'] = '&Ouml;';
                    entities['215'] = '&times;';
                    entities['216'] = '&Oslash;';
                    entities['217'] = '&Ugrave;';
                    entities['218'] = '&Uacute;';
                    entities['219'] = '&Ucirc;';
                    entities['220'] = '&Uuml;';
                    entities['221'] = '&Yacute;';
                    entities['222'] = '&THORN;';
                    entities['223'] = '&szlig;';
                    entities['224'] = '&agrave;';
                    entities['225'] = '&aacute;';
                    entities['226'] = '&acirc;';
                    entities['227'] = '&atilde;';
                    entities['228'] = '&auml;';
                    entities['229'] = '&aring;';
                    entities['230'] = '&aelig;';
                    entities['231'] = '&ccedil;';
                    entities['232'] = '&egrave;';
                    entities['233'] = '&eacute;';
                    entities['234'] = '&ecirc;';
                    entities['235'] = '&euml;';
                    entities['236'] = '&igrave;';
                    entities['237'] = '&iacute;';
                    entities['238'] = '&icirc;';
                    entities['239'] = '&iuml;';
                    entities['240'] = '&eth;';
                    entities['241'] = '&ntilde;';
                    entities['242'] = '&ograve;';
                    entities['243'] = '&oacute;';
                    entities['244'] = '&ocirc;';
                    entities['245'] = '&otilde;';
                    entities['246'] = '&ouml;';
                    entities['247'] = '&divide;';
                    entities['248'] = '&oslash;';
                    entities['249'] = '&ugrave;';
                    entities['250'] = '&uacute;';
                    entities['251'] = '&ucirc;';
                    entities['252'] = '&uuml;';
                    entities['253'] = '&yacute;';
                    entities['254'] = '&thorn;';
                    entities['255'] = '&yuml;';
                }

                if (useQuoteStyle !== 'ENT_NOQUOTES') {
                    entities['34'] = '&quot;';
                }
                if (useQuoteStyle === 'ENT_QUOTES') {
                    entities['39'] = '&#39;';
                }
                entities['60'] = '&lt;';
                entities['62'] = '&gt;';


                // ascii decimals to real symbols
                for (decimal in entities) {
                    if (entities.hasOwnProperty(decimal)) {
                        hash_map[String.fromCharCode(decimal)] = entities[decimal];
                    }
                }

                return hash_map;
            }

            var hash_map = {},
                symbol = '',
                tmp_str = '',
                entity = '';
            tmp_str = string.toString();

            if (false === (hash_map = get_html_translation_table('HTML_ENTITIES', quote_style))) {
                return false;
            }

            // fix &amp; problem
            // http://phpjs.org/functions/get_html_translation_table:416#comment_97660
            delete(hash_map['&']);
            hash_map['&'] = '&amp;';

            for (symbol in hash_map) {
                entity = hash_map[symbol];
                tmp_str = tmp_str.split(entity).join(symbol);
            }
            tmp_str = tmp_str.split('&#039;').join("'");
            tmp_str = tmp_str.split('&#39;').join("'");

            return tmp_str;
        }

    };
}());