
GV.AppVue = Vue.extend({
    template:
        '<div id="gv-container">' +
            '<gv-map ref="gv-map" :options="this.$options" :maps="this.maps"></gv-map>' +
            '<gv-legend ref="gv-legend" :showAddMap="showAddMap" :showInfoMap="showInfoMap" :maps="this.maps"></gv-legend>' +
        '</div>',
    data: function () {
        return GV.rlMaps;
    },
    created: function () {
        //console.log('value ' + this.models[0].id);
        this.options = this.$options;

        console.log('GV.AppVue created ');

        GV.debug = this.options.debug;
        this.proxy = this.options.proxy || GV.Globals.DEFAULT_PROXY;

        // imposto metodo per drag panelli
        this.setDrag();

        // inizializzo layerFactory
        GV.layerFactory = new GV.LayerFactory();


    },
    mounted: function() {
        console.log('GV.AppVue mounted', this.options);

        var self = this;

        this.map = this.$refs['gv-map'].map;

        // aggiungo toolbar
        this.addToolbars(this.options.config.application.layout.toolbar);

        //TODO gestione infoWms
        if (this.options.config.application.mapOptions && this.options.config.application.mapOptions.infoWms && !GV.Util.isTouch()) {
            this.infoWmsManager = new GV.InfoWmsManager();
            this.infoWmsManager.activate(this.map, this.infoWmsManager.request);
//                this.infoWmsList = new Backbone.Collection();
//                GV.app.getContainer().append("<div id='gv-info-wms' class='draggable'></div>");
//                this.addRegion('infowms', '#gv-info-wms');
        }

        // Gestione caricamento mappe/livelli da configurazione (options.config.maps)
        if (this.options.config && this.options.config.maps && this.options.config.maps.length > 0) {
            _.each(this.options.config.maps, function (mapConfig) {
                self.addMap(mapConfig);
            });
        }

        // Gestione caricamento mappe RL da servizio
        if (this.options.idMap) {
            this.addRlMap(this.options);
        } else {
            if (this.options && this.options.callback) {
                this.options.callback(this);
            }
        }
    },
    computed: {
        showAddMap: function() {
            return !this.getButtonOption("legend", "noAddMap");
        },
        showInfoMap: function() {
            return !this.getButtonOption("legend", "noInfoMap");
        }

    },
    methods: {
        getMaps: function () {
            return this.maps;
        },
        addToolbars: function () {
            if (this.options.config.application.layout.toolbar) {
                var toolbar = this.options.config.application.layout.toolbar;
                _.each(toolbar, function (tb) {
                    var position = tb.position || "topleft";
                    _.each(tb.items, function (item) {
                        item.options = item.options || {};
                        item.options.position = item.options.position || position;
                        this.addButton(item);
                    }, this);
                }, this);
            }
        },
        addButton: function (item) {
            if (GV.Buttons[item.name]) {
                var button = GV.Buttons[item.name](item.options, GV.map);
                if (button) {
                    button.name = item.name;
                    button.addTo(GV.map);
                }
            } else {
                GV.Util.log("Bottone " + item.name + " non esistente");
            }
        },
        getButtonOption: function(buttonName, optionName) {
            "use strict";
            var option = null;
            _.each(this.options.config.application.layout.toolbar, function (tb) {
                _.each(tb.items, function (item) {
                    if(item.name === buttonName) {
                        option = item.options[optionName]
                    }
                }, this);
            }, this);
            return option;
        },
        addRlMap: function (options) {
            var self = this,
                idMap = options.idMap;
            $.ajax({
                url: GV.Globals.RL_MAP_CONFIG_SERVICE + idMap,
                //url: '/geoservices/REST/config/map/' + idMap,
                dataType: 'jsonp'
            }).done(function (response) {
                if (!response.success) {
                    GV.Util.log('Errore Caricamento Configurazione Mappa: ' + response.message, 2);
                    return;
                }
                self.addMap(response.data);
                // Gestione callback
                if (options && options.callback) {
                    options.callback(self);
                }
                //TODO gestione titolo
                if (options.setMapTitle && !GV.Globals.SMALL_SCREEN) {
                    //GV.app.getContainer().append("<div id='gv-title' title='" + mapConfig.name + "'>" + mapConfig.name + "</div>");
                }
            }).fail(function (jqXHR, textStatus, errorThrown) {
                GV.Util.log(errorThrown,2);
            });
        },
        addMap: function (mapConfig) {
            // Aggiorno array delle mappe
            GV.rlMaps.addMapConfig(mapConfig);
            // Aggiungo livelli alla mappa
            this.map.loadLayers(mapConfig.layers);
            //gestione extent
            if (mapConfig.extent_3857) {
                this.map.setInitialExtent(mapConfig.extent_3857);
            }
            //TODO: gestione find

        },
        setDrag: function() {
            "use strict";
            interact('.draggable')
                .draggable({
                    // enable inertial throwing
                    inertia: true,
                    // keep the element within the area of it's parent
                    restrict: {
                        restriction: "parent",
                        endOnly: true,
                        elementRect: { top: 0, left: 0, bottom: 1, right: 1 }
                    },
                    // enable autoScroll
                    autoScroll: true,

                    // call this function on every dragmove event
                    onmove: dragMoveListener,
                    // call this function on every dragend event
                    onend: function (event) {
                        var textEl = event.target.querySelector('p');

                        textEl && (textEl.textContent = 'moved a distance of ' + (Math.sqrt(event.dx * event.dx + event.dy * event.dy)|0) + 'px');
                    }
                });

            function dragMoveListener (event) {
                var target = event.target,
                // keep the dragged position in the data-x/data-y attributes
                    x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx,
                    y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

                // translate the element
                target.style.webkitTransform = target.style.transform = 'translate(' + x + 'px, ' + y + 'px)';

                // update the posiion attributes
                target.setAttribute('data-x', x);
                target.setAttribute('data-y', y);
            }

            // this is used later in the resizing and gesture demos
            window.dragMoveListener = dragMoveListener;
        }

    }
});
