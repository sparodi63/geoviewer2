/**
*
* Namespace: LdMaps
*
* Namespace LdMaps, contiene tutti gli oggetti della libreria
*
*/
var LdMaps = {};


//------------------------------------------------------------------------//
LdMaps.Map = L.Map.extend({
    //https://github.com/mapbox/mapbox.js/blob/mb-pages/src/map.js

    initialize: function(element, options) {
        //TODO lettura options
        //TODO gestione default options
        console.log(element)

        L.Map.prototype.initialize.call(this, element, L.extend({}, L.Map.prototype.options, options));

        this.proxy = options.proxy || LdMaps.Globals.DEFAULT_PROXY;

        //TODO gestione initialExtent se presente in options.config.mapOptions.initialExtent
        this.setView([44.3, 8.7], 9);

        // carico baselayers
        this.baseMaps = {};
        this.loadBaseLayers(options.config.baseLayers);

        this.overlayMaps = {};
        // carico layers
        this.loadLayers(options.config.layers);


        // carico mappa o livello RL, altrimenti richiamo callback se presente
        (options.idMap)? this.loadMap(options) : (options.idLayer)? this.loadLayers(options) : (options.callback)? options.callback(this) : null;

        //this.loadMap(options)

        // controlli
        L.control.layers(this.baseMaps,this.overlayMaps).addTo(this);
    },

    // caricamento baseLayers
    loadBaseLayers: function(baseLayers) {
        var self = this;
        this.baseLayers = [];
        $.each(baseLayers,function( index, baseLayer ) {
            var layer = LdMaps.layerFactory.create(baseLayer);
            if (layer) {
                layer.addTo(self);
            }
            baseLayer.layer = layer;
            self.baseLayers.push(baseLayer);

            var label = baseLayer.legend.label;
            self.baseMaps[label] = layer;
        });
    },


    // caricamento Layers
    loadLayers: function(layers) {
        var self = this;
        this.layers = [];
        $.each(layers,function( index, layerConfig ) {
            var layer = LdMaps.layerFactory.create(layerConfig);
//            if (layer && layerConfig.type !== 'JSON') {
                layer.addTo(self);
//            }
            layerConfig.layer = layer;
            self.layers.push(layer);

            var label = layerConfig.legend.label;
            self.overlayMaps[label] = layer;
        });
    },



    // caricamento mappa RL
    loadMap: function(options) {
        var self = this;

        var mapConfig = {
            "id": 56,
            "name": "Limiti Amministrativi (Comunali, Provinciali, Regionali) sc. 1:5000 - ed. 2011",
            "extent": null,
            "type": "V",
            "projection": "EPSG:3003",
            "layers": [
                {
                    "id": 1429,
                    "idMap": 735,
                    "type": "WMS",
                    "name": "L1429",
                    "title": "Province 1:500000",
                    "visible": true,
                    "attribution": null,
                    "minScale": 0,
                    "maxScale": 0,
                    "opacity": 0.0,
                    "geomType": "VECTOR",
                    "geomSubType": "POLYGON",
                    "queryable": false,
                    "order": 101,
                    "multiClasse": false,
                    "wmsParams": {
                        "url": "http://geoservizi.regione.liguria.it/geoserver/M735/wms?",
                        "name": "L1429",
                        "transparent": true,
                        "format": "image/png8",
                        "format_options": "antialias:text"
                    },
                    "wfsParams": {
                        "url": "http://geoservizi.regione.liguria.it/geoserver/M735/wms?",
                        "typeName": "L1429"
                    },
                    "legend": {
                        "label": "Province 1:500000",
                        "icon": "http://geoservizi.regione.liguria.it/geoserver/M735/wms?LAYER=L1429&RULE=R0&REQUEST=GetLegendGraphic&VERSION=1.0.0&FORMAT=image/png&WIDTH=20&HEIGHT=20&LEGEND_OPTIONS=forceLabels:off",
                        "popUpFlag": 0,
                        "popUpUrl": null,
                        "popUpWidth": 0,
                        "popUpHeight": 0
                    },
                    "infoOptions": {
                        "infoUrl": "http://www.cartografiarl.regione.liguria.it/mapfiles/info/repertoriocartografico/PROVINCE_500000.xsl",
                        "infoTarget": "info",
                        "infoWidth": 0,
                        "infoHeight": 0,
                        "infoIdAttr": "ID",
                        "infoLabelAttr": "NOME_PROV"
                    },
                    "classes": [
                        {
                            "filter": null,
                            "legendLabel": "Classe Base",
                            "legendIcon": null
                        }
                    ],
                    "dbSchema": {
                        "schema": "CBASE",
                        "tableName": "PROVINCE_500000",
                        "columns": [
                            {
                                "name": "COD_PROV",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "NOME_PROV",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "ID",
                                "type": "NUMBER"
                            }
                        ]
                    },
                    "rasterFilePath": null,
                    "flagGeoserver": true,
                    "cacheMinZoomLevel": 7,
                    "cacheMaxZoomLevel": 13,
                    "footprint": null
                },
                {
                    "id": 3,
                    "idMap": 56,
                    "type": "WMS",
                    "name": "L3",
                    "title": "Comuni 1:5000",
                    "visible": true,
                    "attribution": null,
                    "minScale": 250000,
                    "maxScale": 0,
                    "opacity": 0.5,
                    "geomType": "VECTOR",
                    "geomSubType": "POLYGON",
                    "queryable": true,
                    "order": 101,
                    "multiClasse": false,
                    "wmsParams": {
                        "url": "http://geoservizi.regione.liguria.it/geoserver/M56/wms?",
                        "name": "L3",
                        "transparent": true,
                        "format": "image/png8",
                        "format_options": "antialias:text"
                    },
                    "wfsParams": {
                        "url": "http://geoservizi.regione.liguria.it/geoserver/M56/wms?",
                        "typeName": "L3"
                    },
                    "legend": {
                        "label": "Comuni 1:5000",
                        "icon": "http://geoservizi.regione.liguria.it/geoserver/M56/wms?LAYER=L3&RULE=R0&REQUEST=GetLegendGraphic&VERSION=1.0.0&FORMAT=image/png&WIDTH=20&HEIGHT=20&LEGEND_OPTIONS=forceLabels:off",
                        "popUpFlag": 0,
                        "popUpUrl": null,
                        "popUpWidth": 0,
                        "popUpHeight": 0
                    },
                    "infoOptions": {
                        "infoUrl": "http://www.cartografiarl.regione.liguria.it/mapfiles/info/repertoriocartografico/COMUNI_5000_TEMI.xsl",
                        "infoTarget": "info",
                        "infoWidth": 0,
                        "infoHeight": 0,
                        "infoIdAttr": "ID",
                        "infoLabelAttr": "NOME_COMUNE"
                    },
                    "classes": [
                        {
                            "filter": null,
                            "legendLabel": "Classe Base",
                            "legendIcon": null
                        }
                    ],
                    "dbSchema": {
                        "schema": "CBASE",
                        "tableName": "COMUNI_5000_2015",
                        "columns": [
                            {
                                "name": "COD_PROV",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "COD_COM",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "CODICE_COMUNE",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "COD_CATASTALE",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "CAP_PRINCIPALE",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "NOME_PROVINCIA",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "NOME_COMUNE",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "NOME_DOP",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "ID_COMUNE_SISMICO",
                                "type": "NUMBER"
                            },
                            {
                                "name": "SISMICO",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "DESCR_SISMICO",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "EX_OB2_DOCUP_97_99",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "AMBITO_EDILIZIA",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "Z_SV_DLGS_146_97_M",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "DESCR_ZONE_SV_P_M",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "Z_SV_DLGS_146_97_R",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "DESCR_ZONE_SV_P_R",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "A_SV_EX_CEE_268_75",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "DESCR_AREE_SV",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "Z_MON_99152_110271",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "DESCR_ZONE_MON",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "COD_ASL",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "NOME_ASL",
                                "type": "VARCHAR2"
                            },
                            {
                                "name": "POPOLAZIONE_FM_1991",
                                "type": "FLOAT"
                            },
                            {
                                "name": "POPOLAZIONE_FM_2001",
                                "type": "FLOAT"
                            },
                            {
                                "name": "POPOLAZIONE_F_2001",
                                "type": "FLOAT"
                            },
                            {
                                "name": "POPOLAZIONE_M_2001",
                                "type": "FLOAT"
                            },
                            {
                                "name": "POPOLAZIONE_FM_2011",
                                "type": "NUMBER"
                            },
                            {
                                "name": "COD_DOP",
                                "type": "NUMBER"
                            },
                            {
                                "name": "AREA_HA",
                                "type": "FLOAT"
                            },
                            {
                                "name": "PERIMETRO_KM",
                                "type": "FLOAT"
                            },
                            {
                                "name": "AREA_KMQ",
                                "type": "FLOAT"
                            },
                            {
                                "name": "ID",
                                "type": "NUMBER"
                            }
                        ]
                    },
                    "rasterFilePath": null,
                    "flagGeoserver": true,
                    "cacheMinZoomLevel": 11,
                    "cacheMaxZoomLevel": 13,
                    "footprint": null
                }
            ]
        }

        $.each(mapConfig.layers, function(index, layerConfig) {
            var layer = LdMaps.layerFactory.create(layerConfig);
            if (layer) {
                layer.addTo(self);
            }
            var label = layerConfig.legend.label;
            self.overlayMaps[label] = layer;
        });

    }
});

LdMaps.map = function (element, options) {
    return new LdMaps.Map(element, options);
};



//---------------------------------------------------------------------//

LdMaps.Globals = {
    DEFAULT_PROXY: "/geoservices/proxy/proxy.jsp?url=",

    RL_MAP_CONFIG_SERVICE: "http://geoportale.regione.liguria.it/geoservices/REST/config/map/",
    RL_CREATE_SLD_SERVICE: "http://geoportale.regione.liguria.it/geoservices/REST/config/create_sld/",

    INFO_WMS_MAX_FEATURES: 10,

    BASE_SCALES: [
        591657550.500000,
        295828775.300000,
        147914387.600000,
        73957193.820000,
        36978596.910000,
        18489298.450000,
        9244649.227000,
        4622324.614000,
        2311162.307000,
        1155581.153000,
        577790.576700,
        288895.288400,
        144447.644200,
        72223.822090,
        36111.911040,
        18055.955520,
        9027.977761,
        4513.988880,
        2256.994440,
        1128.497220
    ]

};


//---------------------------------------------------------------------//
LdMaps.layerFactory = (function() {

    return {
        getZoomFromScaleDenom: function(minScale) {
            var ind;
            $.each(LdMaps.Globals.BASE_SCALES, function(index, scale) {
                if (minScale > scale) {
                    ind = index;
                    return false;
                }
            });
            return ind;
        },

        create: function (layerConfig,map) {
            var layer = this[layerConfig.type](layerConfig,map);
            layer.legend = layerConfig.legend;
            layer.config = layerConfig;
            return layer;
        },

        OSM: function (layerConfig) {
            layerConfig.legend = {
                label: "OpenStreetMap"
            };
            return L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Map data © <a href="http://openstreetmap.org">OpenStreetMap</a> contributors'
            });
        },

        ESRI_IMAGERY: function (layerConfig) {
            layerConfig.legend = {
                label: "ESRI Imagery"
            };
            return L.esri.basemapLayer("Imagery");
        },

        ESRI_STREETS: function (layerConfig) {
            layerConfig.legend = {
                label: "ESRI Streets"
            };
            return L.esri.basemapLayer("Streets");
        },

        ESRI_TOPOGRAPHIC: function (layerConfig) {
            layerConfig.legend = {
                label: "ESRI Topographic"
            };
            return L.esri.basemapLayer("Topographic");
        },

        ESRI_GRAY: function (layerConfig) {
            layerConfig.legend = {
                label: "ESRI Gray"
            };
            return L.esri.basemapLayer("Gray");
        },

        ESRI_DARKGRAY: function (layerConfig) {
            layerConfig.legend = {
                label: "ESRI Dark Gray"
            };
            return L.esri.basemapLayer("DarkGray");
        },

        WMS: function (layerConfig) {
            var format = (layerConfig.geomType === 'VECTOR')? 'image/png8' : 'image/jpeg';
            var minZoom = (layerConfig.minScale)? this.getZoomFromScaleDenom(layerConfig.minScale): 8;
            var maxZoom = (layerConfig.maxScale)? this.getZoomFromScaleDenom(layerConfig.maxScale): 20;

            if (layerConfig.cacheMinZoomLevel) {
                return L.tileLayer.wms(layerConfig.wmsParams.url, {
                    'layers': layerConfig.name,
                    'tiled': true,
                    'transparent': true,
                    'TILESORIGIN':'-20037508,-20037508',
                    'FORMAT_OPTIONS':'antialias:text',
                    'format': format,
                    'minZoom': minZoom,
                    'maxZoom': maxZoom
                });
            } else {
                return LdMaps.untiledWms('http://geoservizi.regione.liguria.it/geoserver/M735/wms?', {
                    'layers': layerConfig.name,
                    'transparent': true,
                    'format': format,
                    'minZoom': minZoom,
                    'maxZoom': maxZoom
                })
            }
        },

        JSON: function (layerConfig,map) {
            var url = layerConfig.url,
                typeName = layerConfig.typeName;

            var layer = L.geoJson(null,{});
            if (typeName) {
                var parameters = {
                    service: 'WFS',
                    version: '2.0.0',
                    request: 'GetFeature',
                    srsName: 'EPSG:4326',
                    outputFormat: 'text/javascript',
                    format_options: 'callback: getJson',
                    typeName: typeName
                };
                url += L.Util.getParamString(parameters)
            }

            $.ajax({
                url: url,
                dataType: 'jsonp',
                jsonpCallback: 'getJson',
                success: function (data) {
                    layer.addData(data);
                }
            });

/*
                    //TODO gestione configurazione tooltip/popup
                    onEachFeature: function(feature, marker) {
                        var tooltipTemplate = '{DENOMINAZIONE}';
                        var popupTemplate = '<h2>{DENOMINAZIONE}</h2><p>{INDIRIZZO} <br />{CAP} {COMUNE}</p>';
                        marker.bindPopup(L.Util.template(popupTemplate, feature.properties));
                        marker.options.title = L.Util.template(tooltipTemplate, feature.properties);
                    }
                    //TODO gestione stile
                    //style: function (feature) {
                    //  return {color: feature.properties.color};
                    //},
//                map.fitBounds(layer.getBounds());
*/

            return layer;

        }

    };

}());


LdMaps.loadJson = function(options) {
    var url = options.url,
        layerName = options.layerName;

    var layer;
    if (layerName) {
        var parameters = {
            service: 'WFS',
            version: '2.0.0',
            request: 'GetFeature',
            srsName: 'EPSG:4326',
            outputFormat: 'text/javascript',
            format_options: 'callback: getJson',
            typeName: layerName
        };
        url += L.Util.getParamString(parameters)
    }

    $.ajax({
        url: url,
        dataType: 'jsonp',
        jsonpCallback: 'getJson',
        success: loadData
    });

    function loadData(data) {
        layer = L.geoJson(data, {
            //TODO gestione configurazione tooltip/popup
            onEachFeature: function(feature, marker) {
                var tooltipTemplate = '{DENOMINAZIONE}';
                var popupTemplate = '<h2>{DENOMINAZIONE}</h2><p>{INDIRIZZO} <br />{CAP} {COMUNE}</p>';
                marker.bindPopup(L.Util.template(popupTemplate, feature.properties));
                marker.options.title = L.Util.template(tooltipTemplate, feature.properties);
            }
            //TODO gestione stile
            //style: function (feature) {
            //  return {color: feature.properties.color};
            //},
        }).addTo(map);
        map.fitBounds(layer.getBounds());
        jsonLayer = layer;
    }
}

//---------------------------------------------------------------------//

LdMaps.UntiledWms = L.Layer.extend({
    'defaultWmsParams': {
        'service': 'WMS',
        'request': 'GetMap',
        'version': '1.3.0',
        'layers': '',
        'styles': '',
        'transparent': true
    },

    'options': {
        'crs': null,
        'uppercase': false,
        'attribution': '',
        'opacity': 1,
        'isBack': false,
        'minZoom': 0,
        'maxZoom': 18
    },

    'initialize': function(url, options) {
        this._url = url;

        // Move WMS parameters to params object
        var params = {};
        for (var opt in options) {
            if (!(opt in this.options)) {
                params[opt] = options[opt];
                delete options[opt];
            }
        }
        L.setOptions(this, options);
        this.wmsParams = L.extend({}, this.defaultWmsParams, params);
    },

    'setParams': function(params) {
        L.extend(this.wmsParams, params);
        this.update();
    },

    'getAttribution': function() {
        return this.options.attribution;
    },

    'onAdd': function() {
        this.update();
    },

    'onRemove': function(map) {
        if (this._currentOverlay) {
            map.removeLayer(this._currentOverlay);
            delete this._currentOverlay;
        }
        if (this._currentUrl) {
            delete this._currentUrl;
        }
    },

    'getEvents': function() {
        return {
            'moveend': this.update
        };
    },

    'update': function() {
        if (!this._map) {
            return;
        }
        // Determine image URL and whether it has changed since last update
        this.updateWmsParams();
        var url = this.getImageUrl();
        if (this._currentUrl == url) {
            return;
        }
        this._currentUrl = url;

        // Keep current image overlay in place until new one loads
        // (inspired by esri.leaflet)
        var bounds = this._map.getBounds();
        var overlay = L.imageOverlay(url, bounds, {'opacity': 0});
        overlay.addTo(this._map);
        overlay.once('load', _swap, this);
        function _swap() {
            if (!this._map) {
                return;
            }
            if (overlay._url != this._currentUrl) {
                this._map.removeLayer(overlay);
                return;
            } else if (this._currentOverlay) {
                this._map.removeLayer(this._currentOverlay);
            }
            this._currentOverlay = overlay;
            overlay.setOpacity(
                this.options.opacity ? this.options.opacity : 1
            );
            if (this.options.isBack === true) {
                overlay.bringToBack();
            }
            if (this.options.isBack === false) {
                overlay.bringToFront();
            }
        }
        if ((this._map.getZoom() < this.options.minZoom) ||
            (this._map.getZoom() > this.options.maxZoom)){
            this._map.removeLayer(overlay);
        }
    },

    'setOpacity': function(opacity) {
        this.options.opacity = opacity;
        if (this._currentOverlay) {
            this._currentOverlay.setOpacity(opacity);
        }
    },

    'bringToBack': function() {
        this.options.isBack = true;
        if (this._currentOverlay) {
            this._currentOverlay.bringToBack();
        }
    },

    'bringToFront': function() {
        this.options.isBack = false;
        if (this._currentOverlay) {
            this._currentOverlay.bringToFront();
        }
    },

    // See L.TileLayer.WMS: onAdd() & getTileUrl()
    'updateWmsParams': function(map) {
        if (!map) {
            map = this._map;
        }
        // Compute WMS options
        var bounds = map.getBounds();
        var size = map.getSize();
        var wmsVersion = parseFloat(this.wmsParams.version);
        var crs = this.options.crs || map.options.crs;
        var projectionKey = wmsVersion >= 1.3 ? 'crs' : 'srs';
        var nw = crs.project(bounds.getNorthWest());
        var se = crs.project(bounds.getSouthEast());

        // Assemble WMS parameter string
        var params = {
            'width': size.x,
            'height': size.y
        };
        params[projectionKey] = crs.code;
        params.bbox = (
            wmsVersion >= 1.3 && crs === L.CRS.EPSG4326 ?
                [se.y, nw.x, nw.y, se.x] :
                [nw.x, se.y, se.x, nw.y]
        ).join(',');

        L.extend(this.wmsParams, params);
    },

    'getImageUrl': function() {
        var uppercase = this.options.uppercase || false;
        var pstr = L.Util.getParamString(this.wmsParams, this._url, uppercase);
        return this._url + pstr;
    }
});

LdMaps.untiledWms = function (url, options) {
    return new LdMaps.UntiledWms(url, options);
};

//---------------------------------------------------------------------//

LdMaps.infoWmsManager = function() {
    return {
        activate: function (map,config) {

            // GESTIONE getFeatureInfo
            map.on('click', function(e) {
                // Build the URL for a GetFeatureInfo
                var url = getFeatureInfoUrl(
                    map,
                    untiled,
                    e.latlng,
                    {
                        'info_format': 'application/json',
                        'propertyName': 'COD_PROV'
                    }
                );

                // chiamata ajax
                $.ajax({
                    url: url,
                    dataType: 'json',
                    success: loadData
                });

                function loadData(data) {
                    var feature = data.features[0];
                    if (feature) {
                        L.popup()
                            .setLatLng(e.latlng)
                            .setContent(L.Util.template("<h2>{COD_PROV}</h2>", feature.properties))
                            .openOn(map);
                    }
                }
            });

            /**
             * Return the WMS GetFeatureInfo URL for the passed map, layer and coordinate.
             * Specific parameters can be passed as params which will override the
             * calculated parameters of the same name.
             */
            function getFeatureInfoUrl(map, layer, latlng, params) {

                //TODO passare come parametro RDMap che contiene
                // i parametri che adesso sono in layer
                //
                var point = map.latLngToContainerPoint(latlng, map.getZoom()),
                    size = map.getSize(),
                    bounds = map.getBounds(),
                    sw = map.options.crs.project(bounds.getSouthWest()),
                    ne = map.options.crs.project(bounds.getNorthEast());

                var defaultParams = {
                    request: 'GetFeatureInfo',
                    service: 'WMS',
                    srs: 'EPSG:3857',
                    styles: '',
                    version: layer._wmsVersion,
                    format: layer.options.format,
                    bbox: sw.x + ',' + sw.y + ',' + ne.x + ',' + ne.y,
                    height: size.y,
                    width: size.x,
                    layers: layer.options.layers,
                    query_layers: layer.options.layers,
                    info_format: 'text/html'
                };

                params = L.Util.extend(defaultParams, params || {});
                params[params.version === '1.3.0' ? 'i' : 'x'] = point.x;
                params[params.version === '1.3.0' ? 'j' : 'y'] = point.y;

                //TODO gestione PROXY
                return '/geoservices/proxy/proxy.jsp?url=' + layer._url + L.Util.getParamString(params, layer._url, true);

            }
        }
    }

}

//---------------------------------------------------------------------------//


/**
 *
 * Class: LdMaps.Util
 *
 * Namespace contenente metodi di utilità
 *
 *
 */

LdMaps.Util = (function(){

    /*global LdMaps:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false , console:false  , opera:false  , google:false  */
    "use strict";

    //TODO rivedere
    //TODO eliminare OpenLayers
	/*
	*  PROPRIETA' PRIVATE 
	*/
	
	/*
	*  METODI PRIVATI 
	*/

    //  Ritorna il valore di un parametro nella queryString
    function getUrlParam(paramName) {

        LdMaps.Util.log("LdMaps.Util.getUrlParam");

        var results = new RegExp("[\\?&]" + paramName + "=([^&#]*)").exec(window.location.href);
//        if (!results) { return 0; }
//        return results[1] || 0;

        return results? decodeURIComponent(results[1]) : null;

    }

    //  Ritorna il valore di un parametro nella queryString
    function getUrlParamFromString(url,paramName) {

        LdMaps.Util.log("LdMaps.Util.getUrlParam");

        var results = new RegExp("[\\?&]" + paramName + "=([^&#]*)").exec(url);
        if (!results) { return 0; }
        return results[1] || 0;

    }

    function assert(condition, error){
            if (!condition){
            throw error;
        }
    }

    // Gestione Exception
    // level:
    // - 0 = warning (non viene mandato messaggio all'utente
    // - 1 = errore
    // - 2 = errore bloccante
    function handleException(exception){

        LdMaps.Util.log(exception.message,exception.level);

        if (exception.level>0)
        {
            LdMaps.Util.messageBox(exception.message);
        }

    }



    // Scrive un messaggio sulla console
    // level:
    // - undefined = info
    // - 0 = warn
    // - 1/2 = error

    function log(message,level) {

        if (!LdMaps.debug) {
            return;
        }

        var action = "log";

        switch (level) {
            case undefined:
                action = "info";
                break;
            case 0:
                action = "warn";
                break;
            case 1: case 2:
                action = "error";
                break;
        }

        // console di firebug e IE8
        try {
            console[action]( message );
        } catch(e) {
            // console di opera
            try {
                opera.postError(message);
            }
            // nessuna console
            catch (e2) {
                // apertura finestra
                //var win = window.open("", "log", "status=yes, toolbar=yes, menubar=no, width=400, height=400, resizable=yes, scrollbars=yes");
                //win.document.write(message + "<br>");
            }
        }
    }

    //  Manda un alert di avviso all'utente
    function messageBox(msg) {
        if (Ext) {
            Ext.MessageBox.show({
              title: '',
              msg: msg,
              buttons: {ok: 'OK'}
            });
        } else {
            window.alert(msg);
        }
    }

    // Funzione per caricare un oggetto json remoto con protocollo JSONP.
    function getJSONP(url,urlParams,callBack) {

        LdMaps.Util.log("LdMaps.Util.getJSONP");

        // funzione richiamata in caso di errore http
        function onErrorCB(jqXHR, textStatus, errorThrown) {
            throw {
                name: "BadAjaxCall",
                message: "LdMaps.Util.getJSONP - Non sono riuscito a caricare la url:\n" + url + "\nErrore: " + jqXHR.status + " - " + textStatus + " - " + errorThrown,
                level: 1
            };
        }

        $.ajax({
            url: url,
            dataType: "jsonp",
            data: urlParams,
            contentType: "application/javascript",
            type: "GET"
        }).done(function(json) {
            try {
                callBack(json);
            }
            catch (exception) {
                LdMaps.Util.handleException(exception);
            }
        }).fail(function(jqXHR, textStatus, errorThrown) {
            if (jqXHR.statusText !== "OK") {
                try {
                    onErrorCB(jqXHR, textStatus, errorThrown);
                }
                catch (exception) {
                    LdMaps.Util.handleException(exception);
                }
            }
        });

    }

    // Funzione per caricare un oggetto json remoto in maniera sincrona o asincrona.
    function getJSON(url,urlParams,aSync,callBack,args) {

        LdMaps.Util.log("LdMaps.Util.getJSON");


        function onErrorCB(textStatus, errorThrown, url) {
            throw {
                name: "BadAjaxCall",
                message: "LdMaps.Util.getJSON: " + url + " - " + errorThrown,
                level: 1
            };
        }

        $.ajax({
            type: "GET",
            url: url,
            dataType: "json",
            success: function(json) {
                try {
                    callBack(json,args);
                }
                catch (exception) {
                    LdMaps.Util.handleException(exception);
                }
            },
            error: function(jqXHR, textStatus, errorThrown) {
                try {
                    onErrorCB(textStatus,errorThrown,url);
                }
                catch (exception) {
                    LdMaps.Util.handleException(exception);
                }

            },
            data: urlParams,
            async: aSync
        });

    }

    // Funzione per caricare un oggetto xml remoto in maniera sincrona o asincrona.
    function getXML(url,urlParams,aSync,callBack,args) {

        LdMaps.Util.log("LdMaps.Util.getXML");


        function onErrorCB(textStatus, errorThrown, url) {
            throw {
                name: "BadAjaxCall",
                message: "LdMaps.Util.getXML: " + url + " - " + errorThrown,
                level: 1
            };
        }

        $.ajax({
            type: "GET",
            url: url,
            dataType: "xml",
            beforeSend: function (xhr, settings) {
                try { xhr.responseType = "msxml-document"; } catch(err){}
            },
            success: function(data) {
                try {
                    callBack(data,args);
                }
                catch (exception) {
                    LdMaps.Util.handleException(exception);
                }
            },
            error: function(jqXHR, textStatus, errorThrown) {
                try {
                    onErrorCB(textStatus,errorThrown,url);
                }
                catch (exception) {
                    LdMaps.Util.handleException(exception);
                }

            },
            data: urlParams,
            async: aSync
        });

    }

    // Funzione per fare il parsing xml
    // ritorna un xmlDoc
    function parseXML(xmlString) {

        LdMaps.Util.log("LdMaps.Util.parseXML");
        try {
            var xmlDoc = null;
            if (window.DOMParser && window.XSLTProcessor) {
                var parser = new DOMParser();
                xmlDoc = parser.parseFromString(xmlString,"text/xml");
            } else {
//                xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                xmlDoc = new ActiveXObject("Msxml2.DOMDocument.3.0");
                xmlDoc.async = false;
                xmlDoc.loadXML(xmlString);
            }
            return xmlDoc;
        } catch (exception) {
            throw {
                name: "xmlTransformation",
                message: "LdMaps.Util.parseXml: errore parsing xml - " + exception.message ,
                level: 1
            };
        }
    }
    // Controlla se un punto appartiene al BBOX del territorio ligure
    function isPointInLig(x,y){

        LdMaps.Util.log("LdMaps.findManager.isPointInLig");

       if (!x || !y) {
           return false;
       }
        var minX = 7.4,
            minY = 43.7,
            maxX = 10.1,
            maxY = 44.8;

        return (x > minX) && (x < maxX) && (y > minY) && (y < maxY);

    }

    // controlla che il punto ricada dentro la finestra di maxExtent
    function isPointInMaxExtent(lat,lon,map,epsg) {

        if (!map) {
            return true;
        }
        if (!map.restrictedExtent) {
            return true;
        }

        var pointEpsg = epsg || "EPSG:4326";

        var point = new OpenLayers.LonLat(lon,lat);
        if (map.projection !== pointEpsg) {
            point.transform(
                new OpenLayers.Projection(pointEpsg),
                map.getProjectionObject()
            );
        }

        var minX = map.restrictedExtent.left,
            minY = map.restrictedExtent.bottom,
            maxX = map.restrictedExtent.right,
            maxY = map.restrictedExtent.top,
            x = point.lon,
            y = point.lat;

        return (x > minX) && (x < maxX) && (y > minY) && (y < maxY);

    }

    // Trasforma un bound in forma string da un sistema di coordinate ad un altro
    function transformStrBounds(fromProjStr,toProjStr,boundsStr){

        LdMaps.Util.log("LdMaps.Util.transformStrBounds");

        var fromProj = new OpenLayers.Projection(fromProjStr),
            toProj = new OpenLayers.Projection(toProjStr);

        var boundStrIn = boundsStr;
        // Hack per shift lungo asse Y e y
        if (fromProjStr === "EPSG:3003") {
            var boundArray = boundStrIn.split(",");
            boundArray[0] = parseInt(boundArray[0]) - parseInt(40);
            boundArray[2] = parseInt(boundArray[2]) - parseInt(40);
            boundArray[1] = parseInt(boundArray[1]) + parseInt(170);
            boundArray[3] = parseInt(boundArray[3]) + parseInt(170);
            boundStrIn = boundArray.join(",");
        }
        var bounds = new OpenLayers.Bounds.fromString(boundStrIn);
        return bounds.transform(fromProj, toProj).toString();

    }

    // Clona un oggetto JS
    function cloneObj(inObj){
        return jQuery.extend({}, inObj);
    }

	// Public API
	return {
	
        /**
        *  Function: getUrlParam
        *
        *  Ritorna il valore di un parametro nella queryString
        *
        *  Parameters:
        *  paramName - {String} Nome del parametro
        *
        *  Returns:
        *  {String} Valore del parametro (se non trovato ritorna 0)
        *
        */

		getUrlParam : getUrlParam,

        /**
        *  Function: getUrlParam
        *
        *  Ritorna il valore di un parametro nella queryString
        *
        *  Parameters:
         *  url - {String} Stringa contenente la URL
         *  paramName - {String} Nome del parametro
        *
        *  Returns:
        *  {String} Valore del parametro (se non trovato ritorna 0)
        *
        */

        getUrlParamFromString : getUrlParamFromString,

        /**
         *  Function: log
         *
         *  Scrive un messaggio sulla console
         *
         *  Parameters:
         *  msg - {String} Messaggio da scrivere
         *
         */

		log : log,

        /**
         *  Function: messageBox
         *
         *  Manda un alert di avviso all'utente
         *
         *  Parameters:
         *  msg - {string} Messaggio da scrivere sull'alert
         *
         */

        messageBox : messageBox,

        /**
         *  Function: assert
         *
         *  Assert per i controlli.
         *
         *  Controlla che l'espressione passata sia vera, altrimenti effettua la throw dell'errore
         *
         *  Parameters:
         *  test - {Expression} Condizione da verificare
         *  error - {Object} Oggetto errore
         *
         */

        assert : assert,

        /**
         * Function: handleException
         *
         * Gestione exception
         *
         * Parameters:
         * exception - {Object} Oggetto exception
         *
         */
        handleException: handleException,

        /**
        * Function: getJSON
        *
        * Funzione per caricare un oggetto json remoto in maniera sincrona o asincrona.
        *
        * Ritorna un oggetto javascript contentente la deserializzazione del json
        *
        * Parameters:
        * url - {String} Url del file o del servizio
        * urlParams - {Object} Oggetto map contenente i parametri da passare. Vedi http://api.jquery.com/jQuery.ajax/
        * aSync - {Boolean} Flag che indica se effettuare una richiesta asincrona
        * callBack {Function} Funzione da richiamare dopo il caricamento
        * args - {Object/Array} Aregomento o Array degli argumuments opzionali dal passare alla funzione di callback
        *
        * Returns:
        * {object} L'oggetto contenente la deserializzazione del JSON
        *
        */
		getJSON: getJSON,

        /**
        * Function: parseXML
        *
        * Funzione per fare il parsing di una stringa xml
        *
        * Ritorna un oggetto doc xml
        *
        * Parameters:
        * xmlString - {String} Stringa xml
        *
        * Returns:
        * {object} Oggetto xmlDoc
        *
        */
        parseXML: parseXML,


        /**
        * Function: getXML
        *
        * Funzione per caricare un oggetto xml remoto in maniera sincrona o asincrona.
        *
        * Ritorna un oggetto javascript contentente la deserializzazione del xml
        *
        * Parameters:
        * url - {String} Url del file o del servizio
        * urlParams - {Object} Oggetto map contenente i parametri da passare. Vedi http://api.jquery.com/jQuery.ajax/
        * aSync - {Boolean} Flag che indica se effettuare una richiesta asincrona
        * callBack {Function} Funzione da richiamare dopo il caricamento
        * args - {Object/Array} Aregomento o Array degli argumuments opzionali dal passare alla funzione di callback
        *
        * Returns:
        * {object} L'oggetto contenente la deserializzazione del JSON
        *
        */
        getXML: getXML,
        /**
         * Function: getJSONP
         *
         * Funzione per caricare un oggetto json remoto utilizzando il protocollo JSONP.
         *
         * Ritorna un oggetto javascript contentente la deserializzazione del json
         *
         * Parameters:
         * url - {String} Url del file o del servizio
         * urlParams - {Object} Oggetto map contenente i parametri da passare. Vedi http://api.jquery.com/jQuery.ajax/
         * callBack {Function} Funzione da richiamare dopo il caricamento
         *
         * Returns:
         * {object} L'oggetto contenente la deserializzazione del JSON
         *
         */
        getJSONP: getJSONP,


        /**
        *
        * Function: isPointInLig
        *
        * Controlla se un punto appartenga al BBOX del territorio ligure
        *
        * Parameters:
        * x - {number} Coordinata X
        * y - {number} Coordinata Y
        *
        * Returns:
        * {boolean} true/false
        *
        */
		isPointInLig: isPointInLig,


        /**
         *
         * Function: isPointInMaxExtent
         *
         * Controlla se un punto è all'interno del maxExtent della mappa
         *
         * Parameters:
         * lat - {number} Latitudine WGS84
         * lon - {number} Longitudine WGS84
         *
         * Returns:
         * {boolean} true/false
         *
        */
        isPointInMaxExtent: isPointInMaxExtent,

        /**
         * Function: transformStrBounds
         *
         * Trasforma un bound in forma string da un sistema di coordinate ad un altro
         *
         * Parameters:
         * fromProjStr - {string} Codice EPSG del sistema di coordinate di partenza (es: "EPSG:3003")
         * toProjStr - {string} Codice EPSG del sistema di coordinate di arrivo
         *
         * Returns:
         * {string} Stringa del bound con coordinate separate da virgole
         *
         */
        transformStrBounds: transformStrBounds,

        /**
         * Function: cloneObj
         *
         * Clona oggetto JS (deep copy)
         *
         * Parameters:
         * inObj - {Object} Oggetto da clonare
         * Returns: {Object} Oggetto clonato
         *
         */
        cloneObj: cloneObj,

        /**
         * Function: toArray
         *
         * Converte Oggetto in Array
         *
         * Parameters:
         * obj - {Object} Oggetto da clonare
         *
         * Returns:
         * {Array} Array
         *
         */
        toArray: function(obj) {
            return Array.prototype.slice.call(obj);
        },

        /**
         * Function: bind
         *
         * Effettua la bind di una funzione ad uno scope
         *
         * Parameters:
         * scope - {Object} Oggetto da utilizzare come scope
         * fn - {Function} Funzione su cui effettuare la bind
         *
         * Returns:
         * {Function} Funzione con bind effettuato
         *
         */
        bind: function(scope, fn) {
            return function() {
                return fn.apply(scope, LdMaps.Util.toArray(arguments));
            };
        },

        /**
         * Function: getArrayElementByAttribute
         *
         * Ritorna un elemento di un array contenente un attributo con un determinato valore
         *
         * Parameters:
         * array - {Array} array su cui cercare l'elemento
         * attributo - {string} Nome dell'attributo dell'elemento
         * value - {string} Valore dell'attributo
         *
         * Returns:
         * {Object} Oggetto
         *
         */
        getArrayElementByAttribute: function(array,attribute,value) {
            if (!array) {
                return null;
            }

            var i,
                len = array.length;

            for (i = 0; i < len; i++) {
                if (array[i][attribute] === value) {
                    return array[i];
                }
            }

            return null;
        },
        /**
         * Function: geoCode
         *
         * Effettua il geocode di un indirizzo utilizzando i servizi google
         *
         * Parameters:
         * address - {string} Indirizzo
         * properties - {Object} oggetto contenente le proprietà da aggiungere all'oggetto properties della feature
         * callback - {function} funzione di callback
         *
         * Returns:
         * {GeoJSON Object}
         *
         */
        geoCode: function(address,properties,callback) {

            var geocoder = new google.maps.Geocoder();

            geocoder.geocode({ "address": address }, function(results, status) {
                if (status === google.maps.GeocoderStatus.OK) {

                    var x = results[0].geometry.location.lng();
                    var y = results[0].geometry.location.lat();
                    var feature = { "type": "FeatureCollection",
                         "features": [
                             { "type": "Feature",
                                 "geometry": {"type": "Point", "coordinates": [x, y]},
                                 "properties": {
                                     "address" : address
                                 }
                             }
                         ]
                    };
                    if (properties) {
                        for (var p in properties) {
                            if (properties.hasOwnProperty(p)) {
                                feature.features[0].properties[p] = properties[p];
                            }
                        }
                    }
                    callback(feature);
                } else {
                    if (status === google.maps.GeocoderStatus.ZERO_RESULTS) {
                        LdMaps.Util.messageBox("Indirizzo '" + address + "' non trovato");
                    } else {
                        LdMaps.Util.handleException({
                            name: "BadGeocoding",
                            message: "Errore di geocoding: " + status,
                            level: 1
                        });
                    }
                }
            });

        },

        /**
         * Function: unescapeHtmlEntities
         *
         * Decodifica caratteri html da una stringa contenente caratteri speciali codificati :
         * &amp; (&)
         * &quot; (")
         * &lt; (<)
         * &gt; (>)
         *
         * Parameters:
         * encodedString - {String} Stringa da decodificare
         *
         * Returns:
         * {String} - Stringa decodificata
         *
         * */
        unescapeHtmlEntities: function(encodedString) {
            encodedString= encodedString.replace(/\&amp;/g,'&');
            encodedString= encodedString.replace(/\&quot;/g,'\"');
            encodedString= encodedString.replace(/\&lt;/g,'<');
            encodedString= encodedString.replace(/\&gt;/g,'>');
            return encodedString;
        },

        /**
         * Function: loadMarker
         *
         * Carica un marker sul layer per le ricerche (findLayer)
         *
         * Parameters:
         * initConfig - {Object} Oggetto Configurazione
         *  - map - {LdMaps.Map} MAppa su cui caricare il marker
         *  - x - {Number} Coordinata X del marker
         *  - y - {Number} Coordinata Y del marker
         *  - classes - {Object} Stile di vestizione del marker
         *  - label - {String} Etichetta
         *  - epsgCode - {String} Codice EPSG (nel formato "EPSG:3003")
         */
        loadMarker: function (initConfig){

            var classes,
                hiliteLayer,
                featureStr,
                feature,
                config,
                label,
                x,
                y,
                layerConfig,
                epsgCode,
                map,
                zoomLevel,
                setInitialExtent;

            map = initConfig.map;
            x = initConfig.x;
            y = initConfig.y;
            classes = initConfig.classes;
            label = initConfig.label;
            epsgCode = initConfig.epsgCode;
            zoomLevel = initConfig.zoomLevel;
            setInitialExtent = initConfig.setInitialExtent;

            if (epsgCode && epsgCode !== "EPSG:4326") {
                var point = new OpenLayers.LonLat(x,y);
                point.transform(
                    new OpenLayers.Projection(epsgCode),
                    new OpenLayers.Projection("EPSG:4326")
                );
                x = point.lon;
                y = point.lat;
            }

            layerConfig = {
                name: "findLayer",
                format: "GeoJSON",
                classes: classes
            };
            hiliteLayer = map.layerManager.createVectorLayer(layerConfig);

            // carico l'oggetto sul layer
            featureStr = "{ \"type\": \"FeatureCollection\",\"features\": [{ \"type\": \"Feature\",";
            featureStr += "\"geometry\": {\"type\": \"Point\", \"coordinates\": [" + x + "," + y + " ]},";
            featureStr += "\"properties\": {\"label\": \"" + label + "\"}}]}";
            feature = jQuery.parseJSON(featureStr);

            config = {
                layer: hiliteLayer,
                features: feature,
                url: null,
                epsgCode: epsgCode,
                options: {
                   zoom: initConfig.zoom,
                   clean: true,
                   zoomLevel : zoomLevel,
                   setInitialExtent : setInitialExtent
                }
            };

            LdMaps.featureLoader.loadFeatures(config);

        },

        /**
         * Function: getWFSBound
         *
         * Ritorna il bound degli elementi attraverso un servizio WFS
         *
         * Parameters:
         * wfsUrl - {string} URL del servizio WFS
         * typeName - {string} nome della feature
         * sldFilter - {string} Filtro SLD
         * map - {OpenLayers.Map} Mappa OL
         * callback - {Function} Funzione di callback da richiamare
         *
         * Returns:
         * {OpenLayers.Bound}
         *
         */
        getWFSBound: function (wfsUrl,typeName,sldFilter,map,callback){

            LdMaps.Util.getXML(
                wfsUrl,
                null,
                true,
                function (wfsResponse) {

                    if (wfsResponse) {
                        var json = $.xml2json(wfsResponse),
                            bbox = null,
                            srs = null,
                            bounds;
                        var exception = {};

                        // Gestione Exception server WFS
                        var serviceException = json["ServiceException"];
                        if (serviceException) {
                            exception.message = "LdMaps.Util.getWFSBound - Service Exception: " + serviceException.text;
                            exception.level = 2;
                            LdMaps.Util.handleException(exception);
                            return;
                        }
                        // Prendo il bbox
                        var boundedBy = json["boundedBy"] || json["gml:boundedBy"];
                        if (boundedBy) {
                            // Gestione not found
                            if (boundedBy["null"] || boundedBy["gml:null"]) {
                                exception.message = "LdMaps.Util.getWFSBound - elemento non trovato";
                                exception.level = 2;
                                LdMaps.Util.handleException(exception);
                                return;
                            }
                            if(boundedBy["Box"]) {
                                bbox = boundedBy["Box"]["coordinates"];
                                srs = boundedBy["Box"].srsName;
                            } else {
                                bbox = boundedBy["gml:Box"]["gml:coordinates"];
                                srs = boundedBy["gml:Box"].srsName;
                            }
                            if (bbox && srs) {
                                callback(OpenLayers.Bounds.fromString(LdMaps.Util.transformStrBounds(srs, map.projection, bbox.replace(" ", ","))));
                                return;
                            }
                        }
                        // se non trovo bbox e srs
                        exception.message = "LdMaps.Util.getWFSBound - bbox non ritornato dal servizio ";
                        exception.level = 1;
                        LdMaps.Util.handleException(exception);
                    }

                }
            )
        },

        // Funzione per il decode di html
        htmlDecode: function (string, quote_style) {

            function get_html_translation_table (table, quote_style) {
              var entities = {},
                hash_map = {},
                decimal;
              var constMappingTable = {},
                constMappingQuoteStyle = {};
              var useTable = {},
                useQuoteStyle = {};

              // Translate arguments
              constMappingTable[0] = 'HTML_SPECIALCHARS';
              constMappingTable[1] = 'HTML_ENTITIES';
              constMappingQuoteStyle[0] = 'ENT_NOQUOTES';
              constMappingQuoteStyle[2] = 'ENT_COMPAT';
              constMappingQuoteStyle[3] = 'ENT_QUOTES';

              useTable = !isNaN(table) ? constMappingTable[table] : table ? table.toUpperCase() : 'HTML_SPECIALCHARS';
              useQuoteStyle = !isNaN(quote_style) ? constMappingQuoteStyle[quote_style] : quote_style ? quote_style.toUpperCase() : 'ENT_COMPAT';

              if (useTable !== 'HTML_SPECIALCHARS' && useTable !== 'HTML_ENTITIES') {
                throw new Error("Table: " + useTable + ' not supported');
                // return false;
              }

              entities['38'] = '&amp;';
              if (useTable === 'HTML_ENTITIES') {
                entities['160'] = '&nbsp;';
                entities['161'] = '&iexcl;';
                entities['162'] = '&cent;';
                entities['163'] = '&pound;';
                entities['164'] = '&curren;';
                entities['165'] = '&yen;';
                entities['166'] = '&brvbar;';
                entities['167'] = '&sect;';
                entities['168'] = '&uml;';
                entities['169'] = '&copy;';
                entities['170'] = '&ordf;';
                entities['171'] = '&laquo;';
                entities['172'] = '&not;';
                entities['173'] = '&shy;';
                entities['174'] = '&reg;';
                entities['175'] = '&macr;';
                entities['176'] = '&deg;';
                entities['177'] = '&plusmn;';
                entities['178'] = '&sup2;';
                entities['179'] = '&sup3;';
                entities['180'] = '&acute;';
                entities['181'] = '&micro;';
                entities['182'] = '&para;';
                entities['183'] = '&middot;';
                entities['184'] = '&cedil;';
                entities['185'] = '&sup1;';
                entities['186'] = '&ordm;';
                entities['187'] = '&raquo;';
                entities['188'] = '&frac14;';
                entities['189'] = '&frac12;';
                entities['190'] = '&frac34;';
                entities['191'] = '&iquest;';
                entities['192'] = '&Agrave;';
                entities['193'] = '&Aacute;';
                entities['194'] = '&Acirc;';
                entities['195'] = '&Atilde;';
                entities['196'] = '&Auml;';
                entities['197'] = '&Aring;';
                entities['198'] = '&AElig;';
                entities['199'] = '&Ccedil;';
                entities['200'] = '&Egrave;';
                entities['201'] = '&Eacute;';
                entities['202'] = '&Ecirc;';
                entities['203'] = '&Euml;';
                entities['204'] = '&Igrave;';
                entities['205'] = '&Iacute;';
                entities['206'] = '&Icirc;';
                entities['207'] = '&Iuml;';
                entities['208'] = '&ETH;';
                entities['209'] = '&Ntilde;';
                entities['210'] = '&Ograve;';
                entities['211'] = '&Oacute;';
                entities['212'] = '&Ocirc;';
                entities['213'] = '&Otilde;';
                entities['214'] = '&Ouml;';
                entities['215'] = '&times;';
                entities['216'] = '&Oslash;';
                entities['217'] = '&Ugrave;';
                entities['218'] = '&Uacute;';
                entities['219'] = '&Ucirc;';
                entities['220'] = '&Uuml;';
                entities['221'] = '&Yacute;';
                entities['222'] = '&THORN;';
                entities['223'] = '&szlig;';
                entities['224'] = '&agrave;';
                entities['225'] = '&aacute;';
                entities['226'] = '&acirc;';
                entities['227'] = '&atilde;';
                entities['228'] = '&auml;';
                entities['229'] = '&aring;';
                entities['230'] = '&aelig;';
                entities['231'] = '&ccedil;';
                entities['232'] = '&egrave;';
                entities['233'] = '&eacute;';
                entities['234'] = '&ecirc;';
                entities['235'] = '&euml;';
                entities['236'] = '&igrave;';
                entities['237'] = '&iacute;';
                entities['238'] = '&icirc;';
                entities['239'] = '&iuml;';
                entities['240'] = '&eth;';
                entities['241'] = '&ntilde;';
                entities['242'] = '&ograve;';
                entities['243'] = '&oacute;';
                entities['244'] = '&ocirc;';
                entities['245'] = '&otilde;';
                entities['246'] = '&ouml;';
                entities['247'] = '&divide;';
                entities['248'] = '&oslash;';
                entities['249'] = '&ugrave;';
                entities['250'] = '&uacute;';
                entities['251'] = '&ucirc;';
                entities['252'] = '&uuml;';
                entities['253'] = '&yacute;';
                entities['254'] = '&thorn;';
                entities['255'] = '&yuml;';
              }

              if (useQuoteStyle !== 'ENT_NOQUOTES') {
                entities['34'] = '&quot;';
              }
              if (useQuoteStyle === 'ENT_QUOTES') {
                entities['39'] = '&#39;';
              }
              entities['60'] = '&lt;';
              entities['62'] = '&gt;';


              // ascii decimals to real symbols
              for (decimal in entities) {
                if (entities.hasOwnProperty(decimal)) {
                  hash_map[String.fromCharCode(decimal)] = entities[decimal];
                }
              }

              return hash_map;
            }

          var hash_map = {},
            symbol = '',
            tmp_str = '',
            entity = '';
          tmp_str = string.toString();

          if (false === (hash_map = get_html_translation_table('HTML_ENTITIES', quote_style))) {
            return false;
          }

          // fix &amp; problem
          // http://phpjs.org/functions/get_html_translation_table:416#comment_97660
          delete(hash_map['&']);
          hash_map['&'] = '&amp;';

          for (symbol in hash_map) {
            entity = hash_map[symbol];
            tmp_str = tmp_str.split(entity).join(symbol);
          }
            tmp_str = tmp_str.split('&#039;').join("'");
            tmp_str = tmp_str.split('&#39;').join("'");

          return tmp_str;
        }

	};
}());

/**
*
* Class: LdMaps.i18n
*
* Gestione multilinguismo
*
*/
LdMaps.i18n = (function(){

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    var dict = {
        "Scala" : {
            "en" : "Scale"
        },
        "Coordinate:" : {
            "en" : "Coordinates:"
        },
        "Ricerche" : {
            "en" : "Find"
        },
        "Attenzione" : {
            "en" : "Attention"
        },
        "Nessun indirizzo indicato" : {
            "en" : "No Address"
        },
        "Il punto è fuori dai limiti geografici della mappa" : {
            "en" : "Address is outside the map boundary"
        },
        "Indirizzo" : {
            "en" : "Address"
        },
        "Vai" : {
            "en" : "OK"
        },
        "Annulla" : {
            "en" : "Cancel"
        },
        "Aggiunta Livelli" : {
            "en" : "Add Layers"
        },
        "Zoom alla massima estensione" : {
            "en" : "Zoom to max extension"
        },
        "Zoom alla estensione iniziale" : {
            "en" : "Zoom to initial extension"
        },
        "Temi" : {
            "en" : "Themes"
        },
        "Aggiungi" : {
            "en" : "Add"
        },
        "Nessun livello selezionato" : {
            "en" : "No layer selected"
        },
        "Misure Areali" : {
            "en" : "Measure Area"
        },
        "Area" : {
            "en" : "Area"
        },
        "Misure Lineari" : {
            "en" : "Measure Line"
        },
        "Distanza" : {
            "en" : "Distance"
        },
        "Pan" : {
            "en" : "Pan"
        },
        "Togli Livelli" : {
            "en" : "Remove Layers"
        },
        "Seleziona i livelli da eliminare" : {
            "en" : "Select the layers to remove"
        },
        "Calcolo Percorsi" : {
            "en" : "Route Planner"
        },
        "Mezzo" : {
            "en" : "Mode"
        },
        "In auto" : {
            "en" : "Driving"
        },
        "A piedi" : {
            "en" : "Walking"
        },
        "Invio" : {
            "en" : "OK"
        },
        "Inverti direzione" : {
            "en" : "Swap"
        },
        "Seleziona punto di partenza sulla mappa" : {
            "en" : "Select start point on map"
        },
        "Seleziona punto di arrivo sulla mappa" : {
            "en" : "Select end point on map"
        },
        "Distanza totale" : {
            "en" : "Distance"
        },
        "Durata totale" : {
            "en" : "Duration"
        },
        "Calcola" : {
            "en" : "OK"
        },
        "Reset" : {
            "en" : "Reset"
        },
        "Zoom In" : {
            "en" : "Zoom In"
        },
        "Zoom Successivo" : {
            "en" : "Zoom Next"
        },
        "Zoom Out" : {
            "en" : "Zoom Out"
        },
        "Zoom Precedente" : {
            "en" : "Zoom Previous"
        },
        "Trasparenza" : {
            "en" : "Transparency"
        },
        "Sfondi" : {
            "en" : "Base Layer"
        },
        "Livelli" : {
            "en" : "Overlays"
        },
        "": {
            "en" : ""

        }

    };

    function get(string) {

//        console.log(string);

        if (dict[string]) {
            return dict[string][LdMaps.i18n.language] || string;
        } else {
            return string;
        }

    }

    // Public API
    return {

           /**
            *  Property: dict
            *  Dizionario dei termini
           */

           dict: dict,

           /**
            *  Property: language
            *  Lingua
           */

           language: "it",

           /**
           *
           *  Function: get
           *
           *  Ritorna una stringa dal dizionario nella lingua impostata.
           *
           *  Parameters:
           *  string - {string} Stringa

           */
           get : get
	};

}());


/**
* 
* Class:  LdMaps.Application
*
* Contiene i metodi per inizializzare e gestire la applicazione
*
*
*/

LdMaps.Application = function(initOptions) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    var appConfig = initOptions.appConfig;

    this.initOptions = initOptions;
    this.id = null;
    this.loadend = false;
    this.map = null;
    this.layout = null;
    this.configuration = null;
    this.extRequired = false;

    // imposto le variabili globali
    LdMaps.Application.setGlobals(initOptions);

    LdMaps.Util.log("LdMaps.Application");

    // Carico la configurazione
    this.loadConfig(appConfig,initOptions);

};

/**
 *  Function: buildApp
*
*  Carica la configurazione
* Parameters:
* appConfig - {string / Object} Oggetto di configurazione o URL della configurazione
* initOptions - {Object} Oggetto contenente le opzioni di inizializzazione
*
*/
LdMaps.Application.prototype.loadConfig = function(appConfig,initOptions) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    // Richiamo il metodo che costruisce l'applicazione
    if (typeof appConfig === "string") {
        LdMaps.Util.getJSONP(
            appConfig,
            null,
            LdMaps.Util.bind(this, function(appConfig) {
                this.buildApp(appConfig, initOptions);
            })
        );
    } else {
        this.buildApp(appConfig, initOptions);
    }
};


//region  Metodi pubblici statici

/**
 *
 * Function: checkServiceException
 *
 * Effettua il controllo che il servizio non abbia ritornato una eccezzione.
 * Metodo statico
 *
 * Parameters:
 * config -  {Object} oggetto configurazione
 *
*/
LdMaps.Application.checkServiceException = function(config) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    if (config.exception) {
        throw {
            name:"ServiceError",
            message:"LdMaps.Application: " + config.exception.message,
            level:2
        };
    }
};

/**
 *
 * Function: checkConfig
 *
 * Effettua dei controlli di base sulla configurazione.
 * Metodo statico
 *
 * Parameters:
 * config -  {Object} oggetto configurazione
 *
*/
LdMaps.Application.checkConfig = function(config) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    LdMaps.Util.assert(config,
        {
            name: "BadConfiguration",
            message: "LdMaps.Application.checkConfig: configuration deve essere valorizzato",
            level: 2
        }
    );

    LdMaps.Util.assert(config.application,
        {
            name: "BadConfiguration",
            message: "LdMaps.Application.checkConfig: application deve essere valorizzato",
            level: 2
        }
    );

    LdMaps.Util.assert(config.application.mapOptions,
        {
            name: "BadConfiguration",
            message: "LdMaps.Application.checkConfig: mapOptions deve essere valorizzato",
            level: 2
        }
    );

    LdMaps.Util.assert(config.application.layout,
        {
            name: "BadConfiguration",
            message: "LdMaps.Application.checkConfig: layout deve essere valorizzato",
            level: 2
        }
    );

    LdMaps.Util.assert(
        (
            (config.application.layout.type === "simple") ||
            (config.application.layout.type === "panel") ||
            (config.application.layout.type === "window") ||
            (config.application.layout.type === "viewport")
        ),
        {
            name: "BadConfiguration",
            message: "LdMaps.Application.checkConfig: layout deve essere di tipo gestito (simple/panel/window/viewport)",
            level: 2
        }
    );

    LdMaps.Util.assert(config.baseLayers,
        {
            name: "BadConfiguration",
            message: "LdMaps.Application.checkConfig: baseLayers deve essere valorizzato",
            level: 2
        }
    );

    LdMaps.Util.assert(config.baseLayers.length > 0,
        {
            name: "BadConfiguration",
            message: "LdMaps.Application.checkConfig: baseLayers deve contenere almeno un layer",
            level: 2
        }
    );

};

/**
 *
 * Function: setGlobals
 *
 * Impostazione variabili globali - Metodo Statico
 *
 * Parameters:
 * initOptions -  {Object} Oggetto opzioni
 *
*/
LdMaps.Application.setGlobals = function(initOptions) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    // variabile globale per il debug
    LdMaps.debug = ((initOptions.debug)||(LdMaps.Util.getUrlParam("debug") === "true"))? true : false;

    // imposto il proxy
    LdMaps.proxy = initOptions.proxy || "";

    // imposto il proxy OL
    OpenLayers.ProxyHost = initOptions.proxy || "/CartoWebNet2/services/proxy/proxy.ashx?url=";

    // imposto il renderer SVG di OpenLayers sulla nuova versione
    OpenLayers.Layer.Vector.prototype.renderers = ["SVG2", "SVG", "VML", "Canvas"];

    // imposto la lingua
    LdMaps.i18n.language = initOptions.language || "it";

    // ket per bing maps
    LdMaps.BING_MAPS_KEY = "Agzh6x2xuNQ4qhwHW_yc0Yd8vhb-5pMRsAHjkneosLHLesOAGqxv35yqxZBlqqVa";


    OpenLayers.ImgPath = "http://srvcarto.regione.liguria.it/cartowebNet2/lib/OL/img/";

};

//endregion

//region  Metodi pubblici di istanza

/**
 *  Function: buildApp
*
*  Costruisce la applicazione
*  Prerequisito: Configurazione caricata
* Parameters:
* configuration - {Object} Oggetto di configurazione della applicazione
* initOptions - {Object} Oggetto contenente le opzioni di inizializzazione
*
*/
LdMaps.Application.prototype.buildApp = function(configuration,initOptions) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    var layerManager;

    try {

        // controllo che il servizio non abbia ritornato un errore
        LdMaps.Application.checkServiceException(configuration);

        // controllo la configurazione (controlli base)
        LdMaps.Application.checkConfig(configuration);

        // imposto le proprieta' della applicazione
        this.setAppProperties(configuration);

        // impostazioni ExtJS
        if (this.extRequired) {
            // abilito i tooltip sui bottoni
            Ext.QuickTips.init();
            // imposto i bottoni per i messageBoxS
            if (LdMaps.i18n.language === 'it') {
                Ext.MessageBox.buttonText = {yes: "Si", no: "No"};
            }
        }

        // registro la applicazione
        LdMaps.appRegistry.add(this);

        // inizializzo il layer manager
        layerManager = new LdMaps.LayerManager(configuration.baseLayers,configuration.layers,this.id);

        // costruisco la mappa OL
        this.map = new LdMaps.Map(configuration.application.mapOptions,layerManager,this.id);

        // costruisco l'interfaccia
        if (initOptions.divID) {
            configuration.application.layout.divID = initOptions.divID;
        }
        this.layout = new LdMaps.Layout(configuration.application.layout,this.id);

        // faccio zoom su initialExtent

        this.map.zoomToInitialExtent();

        // imposto il flag di fine caricamento
        this.loadend = true;

        // se impostato idMap carico la mappa da catalogo
        // altrimenti richiamo eventuale callback (che viene comunque chiamato nella loadMap)
        if (initOptions.idMap) {  
            this.loadMap(configuration, initOptions);
        } else {
        // se impostato idLayer carico i layer da catalogo
            if (initOptions.idLayer) {
                this.loadLayers(configuration, initOptions);
            } else {
                this.callback(configuration, initOptions);
            }
        }


    } catch (exception) {
        LdMaps.Util.handleException(exception);
        return null;
    }
};


LdMaps.Application.prototype.callback = function(configuration,initOptions) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    // richiamo eventuale callback
    if (configuration.application.onLoadCallback && configuration.application.onLoadCallback.name) {
        LdMaps.OnLoadCallbacksRegistry[configuration.application.onLoadCallback.name](configuration.application.onLoadCallback.params,this);
    }
    else if (initOptions.callBack) {
        initOptions.callBack(this);
    }

};


/**
* Function: setAppProperties
*
* Imposta le proprietà della applicazione.
*
* Parameters:
* configuration - {Object} Oggetto di configurazione della applicazione
*/
LdMaps.Application.prototype.setAppProperties = function(configuration) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    // imposto la configurazione
    this.configuration = configuration;

    // imposto l'id della applicazione (utilizzata dai bottoni)
    this.id = configuration.application.id;

    // imposto il flag extRequired
    this.extRequired = configuration.application.layout.type !== "simple";

};

/**
 *  Function: showMapWindow
*
*  Mostra la finestra mappa.
*  Utilizzata da applicazioni con layout di tipo "window".
*
*/
LdMaps.Application.prototype.showMapWindow = function() {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

   this.layout.layout.show();

};

/**
*
* Function: hiliteFeatures
*
* Evidenziazione dinamica feature di layer vettoriali.
*
* Utilizzata per applicazioni con integrata la cartografia (vedi EsempioWindow.js) o
* da bottoni della applicazione (p.es: ricerche/find/filtri, ecc...)
*
* Parameters:
* hiliteOptions - {Object} Oggetto di configurazione dell'hilite
*  - layerName - {String} Nome del layer
*  - filter - {Object} Oggetto configurazione del filtro
*  -  - type - {String}  Tipo di filtro (BY_ATTRIBUTE,SLD,CQL)
*  -  - attrName - {String} Nome dell'attributo (per filtro di tipo BY_ATTRIBUTE)
*  -  - items - {Array} Array di valori (per filtro di tipo BY_ATTRIBUTE)
*  -  - text - {String} Stringa contentente il filtro nel formato SLD o CQL
*  - options - {Object} Oggetto configurazione delle opzioni
*  -  - zoom - {Boolean} Flag per impostare lo zoom sulle feature caricate
*
*  Esempio:
*  (start code)
* var hiliteConf = {
*			"layerName": "Prova",
*			"filter" : {
*				"type": "BY_ATTRIBUTE",
*				"attrName": "ID",
*				"items": ["1","2"]
*			},
*			"options": {
*				"zoom": false
*			}
*		};
*   (end)
*
*/
LdMaps.Application.prototype.hiliteFeatures = function(hiliteOptions) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    var olLayer = this.map.getLayerByName(hiliteOptions.layerName);
    if (olLayer) {
        hiliteOptions.layer = olLayer;
        LdMaps.featureHiliter.hiliteFeatures(hiliteOptions);
    }

};

/**
*
* Function: resetHilite
*
* Azzeramento evidenziazione feature di layer vettoriali.
*
* Utilizzata per applicazioni con integrata la cartografia (vedi EsempioWindow.js) o da bottoni della applicazione (p.es: ricerche/find/filtri, ecc...)
*
*/
LdMaps.Application.prototype.resetHilite = function() {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    var map = this.map;
    if (map) {
        LdMaps.featureHiliter.resetHilite(map);
    }

};

/**
*
* Function: loadFeatures
*
* Carica le feature in formato GeoJSON in un layer di tipo OpenLayers.Layer.Vector
*
* Parameters:
* options - {Object} Oggetto di configurazione
*  - layerName - {String} Nome del layer
*  - features - {Object} Oggetto GeoJSON contenente le feature
*  - url - {String} URL del servizio/file con serve le feature
*  - options - {Object} Oggetto configurazione delle opzioni
*  - - zoom - {Boolean} Flag per impostare lo zoom sulle feature caricate
*  - - zoomLevel - {Integer} Se negativo effettua uno zoom all'indietro, se positivo e inferiore al livello di zoom attuale va a quel livello di zoom (zoom minimo)
*  - - clean - {Boolean} Flag per indicare se bisogna cancellare eventuali feature preesistenti
*
*  Esempio:
*  (start code)
* var config = {
*			"layerName": "Prova",
*           "features": features,
*           "url": null,
*			"options": {
 *				"zoom": false
 *				"clean": false
*			}
*		};
*   (end)
*
*/
LdMaps.Application.prototype.loadFeatures = function(options) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    var olLayer = this.map.getLayerByName(options.layerName);
    if (olLayer) {
        options.layer = olLayer;
        LdMaps.featureLoader.loadFeatures(options);
    }

};

/**
*
* Function: loadFeatureByAddress
*
* Carica le feature in formato GeoJSON in un layer di tipo OpenLayers.Layer.Vector
*
* Parameters:
* options - {Object} Oggetto di configurazione
*  - layerName - {String} Nome del layer
*  - features - {Object} Oggetto GeoJSON contenente le feature
*  - url - {String} URL del servizio/file con serve le feature
*  - options - {Object} Oggetto configurazione delle opzioni
*  - - zoom - {Boolean} Flag per impostare lo zoom sulle feature caricate
*  - - zoomLevel - {Integer} Se negativo effettua uno zoom all'indietro, se positivo e inferiore al livello di zoom attuale va a quel livello di zoom (zoom minimo)
*  - - clean - {Boolean} Flag per indicare se bisogna cancellare eventuali feature preesistenti
*
*  Esempio:
*  (start code)
* var config = {
*			"layerName": "Prova",
*           "address": " Genova, Liguria",
*			"options": {
*				"zoom": true
*				"zoomLevel": 16
*				"clean": true
*			}
*		};
*   (end)
*
*/
LdMaps.Application.prototype.loadFeatureByAddress = function(options) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    var olLayer = this.map.getLayerByName(options.layerName);
    if (olLayer) {
        options.layer = olLayer;
        LdMaps.featureLoader.loadFeatureByAddress(options);
    }

};

/**
*
* Function: selectFeature
*
* Selezione programmatica feature di un layer vettoriali.
*
* Se più feature soddisfano il criterio di selezione solo la prima viene selezionata.
*
* Se impostato il parametro options.hiliteOnly=true viene fatto solo l'highlight della feaure.
*
* Se impostato il parametro feature viene selezionata la feature,
* altrimenti viene fatta una ricerca della feature sul layer in base alla configurazione del parametro config.
*
*
* Parameters:
* options - {Object} Oggetto di configurazione dell'hilite
*  - layerName - {String} Nome del layer
*  - attrName - {String} Nome dell'attributo
*  - item - {String}/{Number} Valore
*  - options - {Object} Oggetto configurazione delle opzioni
*  -  - zoom - {Boolean} Flag per impostare lo zoom sulle feature caricate
*  -  - hiliteOnly - {Boolean} Flag per effettuare solo l'highlight della feature (default: false)
* feature - {OpenLayers.Feature} Feature da selezionare
*
*  Esempio:
*  (start code)
* var selectConf = {
*			"layerName": "Prova",
*			"attrName": "ID",
*				"items": "1"
*			},
*			"options": {
*				"zoom": false,
*				"hiliteOnly": false
*			}
*		};
*   (end)
*
*/
LdMaps.Application.prototype.selectFeature = function(options) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    var olLayer = this.map.getLayerByName(options.layerName);
    if (olLayer) {
        options.layer = olLayer;
        LdMaps.featureSelecter.selectFeature(options);
    }

};

/**
 *
 * Function: unselectFeature
 *
 * Deselezione programmatica feature di un layer vettoriali.
 *
 * Se più feature soddisfano il criterio di selezione solo la prima viene deselezionata.
 *
 * Se impostato il parametro options.hiliteOnly=true viene fatto solo l'unhighlight della feaure.
 *
 * Se impostato il parametro feature viene deselezionata la feature,
 * altrimenti viene fatta una ricerca della feature sul layer in base alla configurazione del parametro config
 *
 *
  * Parameters:
  * options - {Object} Oggetto di configurazione dell'hilite
  *  - layerName - {String} Nome del layer
  *  - attrName - {String} Nome dell'attributo
  *  - item - {String}/{Number} Valore
  *  - options - {Object} Oggetto configurazione delle opzioni
  *  -  - hiliteOnly - {Boolean} Flag per effettuare solo l'highlight della feature (default: false)
  * feature - {OpenLayers.Feature} Feature da selezionare
  *
  *  Esempio:
  *  (start code)
  * var selectConf = {
  *			"layerName": "Prova",
  *			"attrName": "ID",
  *				"items": "1"
  *			},
  *			"options": {
   *				"hiliteOnly": false
  *			}
  *		};
  *   (end)
  *
  */
LdMaps.Application.prototype.unselectFeature = function(options) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    var olLayer = this.map.getLayerByName(options.layerName);
    if (olLayer) {
        options.layer = olLayer;
        LdMaps.featureSelecter.unselectFeature(options);
    }

};

/**
*
* Function: loadMap
*
* Effettua il caricamento di una mappa definita in Catalogo SIT
*
*
* Parameters:
* configuration - {Object} Oggetto di configurazione della applicazione
* initOptions - {Object} Oggetto di inizializzazione
*
*/
LdMaps.Application.prototype.loadMap = function (configuration, initOptions) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    var idMap = initOptions.idMap;
    var findOptions = initOptions.findOptions;
    var loadBaseLayers = initOptions.loadBaseLayers;


    if (!idMap || idMap === "null") {
        var exception = {};
        exception.message = "manca parametro mappa";
        exception.level = 1;
        LdMaps.Util.handleException(exception);
        return;
    }

//    var layerConfigService = "/cartowebnet2/services/config/map/" + idMap;
    var layerConfigService = LdMaps.proxy + "http://srvcarto.regione.liguria.it/cartowebnet2/services/config/map/" + idMap;
    if (loadBaseLayers) {
        layerConfigService += "?loadBaseLayers=true";
    }

    var app = this;

    LdMaps.Util.getJSON(
        layerConfigService,
        null,
        true,
        function(mapConfig) {
            app.layout.setMapTitle(mapConfig.name);
            app.map.layerManager.addLayers(mapConfig.layers);
            if (mapConfig.extent) {
                setExtent(mapConfig.extent);
            }
            // se tipo mappa è raster imposto lo sfondo bianco
            if (mapConfig.type && mapConfig.type == "R") {
                LdMaps.Map.setBaseLayerOnMap("sfondo_bianco",app.id);
            }
            // se configurata find la effettuo
            if (findOptions) {
                if (findOptions.idList && findOptions.idList !== "null") {
                    app.findWMS(findOptions);
                } else {
                     exception = {};
                    exception.message = "Lista valori find non impostata";
                    exception.level = 0;
                    LdMaps.Util.handleException(exception);
                }
            }
            // richiamo eventuale callback
            app.callback(configuration, initOptions);
        }
    );

};

/**
*
* Function: loadLayers
*
* Effettua il caricamento di layers definita in Catalogo SIT
*
*
* Parameters:
* configuration - {Object} Oggetto di configurazione della applicazione
* initOptions - {Object} Oggetto di inizializzazione
*
*/
LdMaps.Application.prototype.loadLayers = function (configuration, initOptions) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    var idLayer = initOptions.idLayer;
    var findOptions = initOptions.findOptions;


    if (!idLayer || idLayer === "null") {
        var exception = {};
        exception.message = "manca parametro layer";
        exception.level = 1;
        LdMaps.Util.handleException(exception);
        return;
    }

    var layerConfigService = LdMaps.proxy + "http://srvcarto.regione.liguria.it/cartowebnet2/services/config/layer/" + idLayer;

    var app = this;

    LdMaps.Util.getJSON(
        layerConfigService,
        null,
        true,
        function(layerConfig) {
            app.map.layerManager.addLayers(layerConfig);
            // se configurata find la effettuo
            if (findOptions) {
                if (findOptions.idList && findOptions.idList !== "null") {
                    app.findWMS(findOptions);
                } else {
                     exception = {};
                    exception.message = "Lista valori find non impostata";
                    exception.level = 0;
                    LdMaps.Util.handleException(exception);
                }
            }
            // richiamo eventuale callback
            app.callback(configuration, initOptions);
        }
    );

};

/**
*
* Function: findWMS
*
* Effettua una find con evidenziazione su layer WMS
*
*
* Parameters:
* findOptions - {Object} Oggetto di configurazione dell'hilite
 *  - layerName - {String} Nome del layer
 *  - idField - {String} Nome del campo ID su cui fare il filtro
 *  - idList - {String} Lista dei valori separati da virgola
 *  - zoomLevel - {String} Livello di zoom massimo

*
*/
LdMaps.Application.prototype.findWMS = function(findOptions) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";


    var layerName = findOptions.layerName,
        idField = findOptions.idField,
        idList = findOptions.idList,
        zoomLevel = findOptions.zoomLevel,
        map = this.map,
        layerConfig = map.layerManager.getLayerConfigByName(layerName),
        wmsUrl = layerConfig.wmsParams.url,
        typeName = layerConfig.wmsParams.name;

    if (!idList || idList === "null") {
        var exception = {};
        exception.message = "manca parametro idList";
        exception.level = 0;
        LdMaps.Util.handleException(exception);
        return;
    }
    var idListArray = idList.split(',');

    // creo il filtro sld
    var sldFilter = LdMaps.WmsSldHiliter.getFilter(idField,idListArray);

    var wfsUrl = this.initOptions.proxy + layerConfig.wmsParams.url + "VERSION=1.0.0&SERVICE=WFS&REQUEST=GetFeature&TYPENAME=" + typeName + "&Filter=" + sldFilter;

    // funzione di callback richiamata da Util.getWFSBound
    var hiliteFeature = function (bounds) {
        var hiliteLayerName = "_findWMS";
        var wmsSldHiliter = new LdMaps.WmsSldHiliter(map,hiliteLayerName);
        var hiliteLayer = wmsSldHiliter.hiliteFeature(
            layerConfig,
            idField,
            idListArray,
            bounds,
            zoomLevel,
            function() {
                // imposto initial extent della mappa
                map.initialExtent = map.getExtent();
            });
    };

    var bounds = LdMaps.Util.getWFSBound(
        wfsUrl,
        typeName,
        sldFilter,
        this.map,
        hiliteFeature);
};

/**
*
* Function: getButtonOptions
*
* Ritorna un oggetto contenente le opzioni di configurazione di un bottone
*
* Parameters:
* buttonID - {String} Id del bottone
*
*/
LdMaps.Application.prototype.getButtonOptions = function(buttonId) {
    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    var groups = this.configuration.application.layout.toolbar.itemGroups,
        buttons = {};
    $.map(groups,function( val, i ) {
        $.map(val.items,function( val2, i2 ) {
            buttons[val2.name] = val2.options;
        });
    });
    return buttons[buttonId];
};

/**
*
* Function: setButtonOption
*
* Imposta una opzione di configurazione di un bottone
*
* Parameters:
 * buttonID - {String} Id del bottone
 * optionsName - {String} Nome della opzione
 * optionsValue - {String/Function/Object....} Valore della opzione
*
*/
LdMaps.Application.prototype.setButtonOption = function(buttonId,optionName,optionsValue) {
    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    var groups = this.configuration.application.layout.toolbar.itemGroups;
    $.map(groups,function( val, i ) {
        $.map(val.items,function( val2, i2 ) {
            if (val2.name === buttonId) {
                val2.options[optionName] = optionsValue;
            }
        });
    });
};

/**
*
* Function: addToolbarItems
*
* Aggiunge item alla toolbar
*
* Parameters:
 * buttonID - {String} Id del bottone
 * optionsName - {String} Nome della opzione
 * optionsValue - {String/Function/Object....} Valore della opzione
*
*/
LdMaps.Application.prototype.addToolbarItems = function(itemsConfig) {
    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    var toolbar = Ext.getCmp('LdMaps-toolbar-'+this.id);
    toolbar.add(itemsConfig);


};

//endregion

/**
* 
* Class: LdMaps.controlFactory
* 
 * Factory per creazione di controlli OL
 *
*/

LdMaps.controlFactory = (function(){

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    // Crea un controllo OpenLayers basato su una determinata configurazione
    function create (controlConfig) {

        LdMaps.Util.log("LdMaps.controlFactory.create: " + controlConfig.name);

        // provo a creare il controllo
        // guardo prima tra i controlli di LdMaps e poi tra quelli OpenLayers
        // se non riesco mando un'eccezzione
        try {
            return new LdMaps.Control[controlConfig.name](controlConfig.options);
        } catch (exception) {
            try {
                return new OpenLayers.Control[controlConfig.name](controlConfig.options);
            } catch (exception) {
                throw {
                    name: "BadOLControl",
                    message: "LdMaps.controlFactory.create: control " + controlConfig.name + " non implementato",
                    level: 0
                };
            }
        }

    }

	/*
	*  Public API
	*/	
	
	return {
		
		/**
         *
		* Function: create
        *
        * Crea un controllo OpenLayers basato su una determinata configurazione.
        *
		* Parameters:
        * controlConfig - {Object} Oggetto che contiene la configurazione del controllo
        *
		* Returns:
        * {OpenLayers.Control} - Il controllo OL creato
		* 
		*/ 
		
		create: create
	
	};
}());/*
 *
 * Class: LdMaps.Control.DeleteFeature
 *
 * Controllo OpenLayers Custom che permette di cancellare feature sulla mappa.
 *
 *
 */	

/*global LdMaps:false, window:false, OpenLayers:false, Ext:false, GeoExt:false , jQuery:false, $:false*/


/**
* 
* Class: LdMaps.featureHiliter
* 
* Permette di effettuare l'evidenziazione delle feature vettoriali.
*
*/

LdMaps.featureHiliter = (function(){

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";


	/*
      private properties
	*/
	
    var hilitedFeaturesRegistry = {};


	/*
      private methods
	*/


    // Evidenziazione dinamica feature di layer vettoriali
    function hiliteFeatures(hiliteConfig) {
        LdMaps.Util.log("LdMaps.featureHiliter.hiliteFeatures");

        try {
            LdMaps.Util.assert(hiliteConfig,
                {
                    name: "BadParameter",
                    message: "LdMaps.featureHiliter.hiliteFeatures: selectConfig deve essere valorizzato",
                    level: 1
                }
            );
            LdMaps.Util.assert(hiliteConfig.layer,
                {
                    name: "BadParameter",
                    message: "LdMaps.featureHiliter.hiliteFeatures: layer deve essere valorizzato",
                    level: 1
                }
            );
            LdMaps.Util.assert(hiliteConfig.filter,
                {
                    name: "BadParameter",
                    message: "LdMaps.featureHiliter.hiliteFeatures: filter deve essere valorizzato",
                    level: 1
                }
            );
            LdMaps.Util.assert(hiliteConfig.filter.type === "BY_ATTRIBUTE",
                {
                    name: "BadParameter",
                    message: "LdMaps.featureHiliter.hiliteFeatures: filter.type deve essere di tipo BY_ATTRIBUTE",
                    level: 1
                }
            );
            if (hiliteConfig.filter.type === "BY_ATTRIBUTE") {
                LdMaps.Util.assert(hiliteConfig.filter.attrName,
                    {
                        name: "BadParameter",
                        message: "LdMaps.featureHiliter.hiliteFeatures: attrName deve essere valorizzato se filterType = BY_ATTRIBUTE",
                        level: 1
                    }
                );
                LdMaps.Util.assert(hiliteConfig.filter.items,
                    {
                        name: "BadParameter",
                        message: "LdMaps.featureHiliter.hiliteFeatures: items deve essere valorizzato se filterType = BY_ATTRIBUTE",
                        level: 1
                    }
                );
                LdMaps.Util.assert(hiliteConfig.filter.items instanceof Array,
                    {
                        name: "BadParameter",
                        message: "LdMaps.featureHiliter.hiliteFeatures: items deve essere un array se filterType = BY_ATTRIBUTE",
                        level: 1
                    }
                );
            }
        } catch(exception) {
            LdMaps.Util.handleException(exception);
            return;
        }

        var layer = hiliteConfig.layer,
            options = hiliteConfig.options || {"zoom" : true},
            zoom = options.zoom,
            maxZoomLevel = options.maxZoomLevel;

        // cerco nelle feature del layer quelle in configurazione
        // se il layer non si � ancora caricato lo faccio sull'evento "loadend"
        if (!layer.loadend) {
            layer.events.register("loadend", layer, function() {
                hilite(hiliteConfig);
            });
        } else {
            hilite(hiliteConfig);
        }

    }


    // cerca nelle feature del layer quelle in configurazione e le evidenzia
	function hilite(hiliteConfig) {

		// configurazione hilite
		var layer = hiliteConfig.layer,
            filterType = hiliteConfig.filter.type,
            attrName = hiliteConfig.filter.attrName,
            items = hiliteConfig.filter.items,
            foundFeatures,
            mapId = layer.map.id,
            options = hiliteConfig.options || {"zoom" : true},
            zoom = options.zoom,
            maxZoomLevel = options.maxZoomLevel;

		if (filterType==="BY_ATTRIBUTE") {
            var hiliteFeatureControl = layer.map.featureManager.hiliteFeatureControl;
            var hilitedFeatures = [];
            var len = items.length;
            for (var i = 0; i < len; i++) {
				foundFeatures = layer.getFeaturesByAttribute(attrName,items[i]);
                var len2 = foundFeatures.length;
                for (var f = 0; f < len2; f++) {
                    hilitedFeatures.push(foundFeatures[f]);
                    hiliteFeature(hiliteFeatureControl,foundFeatures[f]);
				}
			}
            setHilitedFeatures(mapId,hilitedFeatures);
		}

        // se impostato flag per zoom faccio lo zoom
        if (zoom) {
            layer.map.zoomToFeatures(getHilitedFeatures(mapId),maxZoomLevel);
        }
	}

    // Evidenzia una feature
    function hiliteFeature(hiliteFeatureControl,feature) {
        LdMaps.Util.log("LdMaps.featureHiliter.hiliteFeature");
        hiliteFeatureControl.highlight(feature);
    }


    // Azzeramento evidenziazione feature di layer vettoriali
    function resetHilite(map){
        LdMaps.Util.log("LdMaps.featureHiliter.resetHilite");

        var hilitedFeatures = getHilitedFeatures(map.id);

        if (!hilitedFeatures) {
            return;
        }
        // copio le features selezionate in un array di appoggio
        var appoSelected = [],
            numFeatures = hilitedFeatures.length,
            i,
            i2;

        if (numFeatures) {
            for (i = 0; i < numFeatures; i++) {
                appoSelected.push(hilitedFeatures[i]);
            }
        }

        // azzero l'array delle feature selezionate
        setHilitedFeatures(map.id,[]);

        // azzero la evidenziazione
        numFeatures = appoSelected.length;
        if (numFeatures) {
            var hiliteFeatureControl = map.featureManager.hiliteFeatureControl;
            for (i2 = 0; i2 < numFeatures; i2++) {
                hiliteFeatureControl.unhighlight(appoSelected[i2]);
            }
        }
    }

    // Ritorna le feature evidenziate
    function getHilitedFeatures(mapId) {

        return hilitedFeaturesRegistry[mapId];

    }

    // Ritorna le feature evidenziate
    function setHilitedFeatures(mapId,features) {

        hilitedFeaturesRegistry[mapId] = features;

    }


	/*
  Public API
	*/
	return {

        /**
        *
        * Function: hiliteFeatures
        *
        * Evidenziazione dinamica feature di layer vettoriali.
        *
        * Utilizzata per applicazioni con integrata la cartografia (vedi EsempioWindow.js) o
        * da bottoni della applicazione (p.es: ricerche/find/filtri, ecc...)
        *
        * Parameters:
        * hiliteConfig - {Object} Oggetto di configurazione dell'hilite
        *  - layerName - {String} Nome del layer
        *  - filter - {Object} Oggetto configurazione del filtro
        *  -  - type - {String}  Tipo di filtro (BY_ATTRIBUTE,SLD,CQL)
        *  -  - attrName - {String} Nome dell'attributo (per filtro di tipo BY_ATTRIBUTE)
        *  -  - items - {Array} Array di valori (per filtro di tipo BY_ATTRIBUTE)
        *  -  - text - {String} Stringa contentente il filtro nel formato SLD o CQL
        *  - options - {Object} Oggetto configurazione delle opzioni
        *  -  - zoom - {Boolean} Flag per impostare lo zoom sulle feature caricate
        *
        *  Esempio:
        *  (start code)
        * var hiliteConf = {
        *			"layerName": "Prova",
        *			"filter" : {
        *				"type": "BY_ATTRIBUTE",
        *				"attrName": "ID",
        *				"items": ["1","2"]
        *			},
        *			"options": {
        *				"zoom": false
        *			}
        *		};
        *   (end)
        *
        */
        hiliteFeatures : hiliteFeatures,

        /**
        *
        * Function: hiliteFeature
         *
         * Evidenziazione di una feature
         *
         * Utilizzata da OpenLayersExt: OpenLayers.Control.SelectFeature.prototype.unhighlight
         *
        * Parameters:
         * feature - {OpenLayers.Feature} feature da evidenziare
        */
        hiliteFeature : hiliteFeature,

        /**
        *
        * Function: resetHilite
        *
        * Azzeramento evidenziazione feature di layer vettoriali.
        *
        * Utilizzata per applicazioni con integrata la cartografia (vedi EsempioWindow.js) o da bottoni della applicazione (p.es: ricerche/find/filtri, ecc...)
        *
        */
		resetHilite : resetHilite,

        /**
        * Funzione che ritorna le feature attualmente evidenziate
        * Returns: {Array}
        * Parameters:
        * feature - {OpenLayers.Feature} feature da evidenziare
        */
        getHilitedFeatures: getHilitedFeatures

	};

}());
/**
*
* Class: LdMaps.featureLoader
 *
 * Oggetto per il caricamento delle feature vettoriali
 *
*
*/

LdMaps.featureLoader = (function(){

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

	/*
      private properties
    */

	/*
        private methods
	*/


    // Carica le feature in formato GeoJSON in un layer di tipo OpenLayers.Layer.Vector
    function loadFeatures(config) {
        LdMaps.Util.log("LdMaps.featureLoader.loadFeatures");

        var features,
            url,
            layer;

        // controlli configurazione
        try {
            LdMaps.Util.assert(config,
                {
                    name: "BadParameter",
                    message: "LdMaps.featureLoader.loadFeatures: oggetto di configurazione deve essere valorizzato",
                    level: 1
                }
            );
            LdMaps.Util.assert(config.layer,
                {
                    name: "BadParameter",
                    message: "LdMaps.featureLoader.loadFeatures: Layer non trovato",
                    level: 1
                }
            );
            LdMaps.Util.assert(config.url || config.features,
                {
                    name: "BadParameter",
                    message: "LdMaps.featureLoader.loadFeatures: url o features devono essere valorizzati",
                    level: 1
                }
            );
        } catch(e) { throw e; }

        // impostazione parametri
        layer = config.layer;
        features = config.features;
        url = config.url;


        // se impostato parametro layerLegendUrl
        // cambio la legenda del layer
        if (config.layerLegendUrl) {
            var styles = layer.styleMap.styles;
            for (var stile in styles) {
                var rule = styles[stile].rules[0];
                rule.symbolizer.externalGraphic = config.layerLegendUrl;
            }
        }


        // gestione simbologia custom per singola feature(immagine e dimensioni)
        if (config.customFeatureImg || config.customFeatureSize) {
            var externalGraphic = layer.styleMap.styles["default"].rules[0].symbolizer.externalGraphic,
                graphicTitle = layer.styleMap.styles["default"].rules[0].symbolizer.graphicTitle,
                graphicWidth = layer.styleMap.styles["default"].rules[0].symbolizer.graphicWidth ,
                graphicHeight = layer.styleMap.styles["default"].rules[0].symbolizer.graphicHeight,
                graphicOpacity = layer.styleMap.styles["default"].rules[0].symbolizer.graphicOpacity,
                graphicXOffset = layer.styleMap.styles["default"].rules[0].symbolizer.graphicXOffset,
                graphicYOffset = layer.styleMap.styles["default"].rules[0].symbolizer.graphicYOffset;
            if (config.customFeatureImg) {
                externalGraphic = "${img}";
            }
            if (config.customFeatureSize) {
                graphicWidth = "${width}";
                graphicHeight = "${height}";
            }
            var style = new OpenLayers.Style({
                externalGraphic: externalGraphic,
                graphicTitle: graphicTitle,
                graphicWidth: graphicWidth ,
                graphicHeight: graphicHeight,
                graphicOpacity: graphicOpacity,
                graphicXOffset: graphicXOffset,
                graphicYOffset: graphicYOffset
            });
            layer.styleMap = new OpenLayers.StyleMap(style);
        }

        // imposto il flag loadend sul layer a false
        // viene poi reimpostato alla fine del caricamento richiamando l'evento loadend
        layer.loadend=false;

        // caricamento feature
        try {
            // se impostate le feature carico direttamente
            if (features) {
                loadFeaturesCB(features,config);
            }
            if (url) {
                LdMaps.Util.getJSONP(
                    url,
                    null,
                    function(features) {
                        loadFeaturesCB(features, config);
                    }
                );
            }
        }
        catch (exception) {
            LdMaps.Util.handleException(exception);
        }

    }


    // Carica le feature in formato GeoJSON in un layer di tipo OpenLayers.Layer.Vector a partire da un indirizzo
    function loadFeatureByAddress(config) {
        LdMaps.Util.log("LdMaps.featureLoader.loadFeatureByAddress");

        // controlli configurazione
        try {
            LdMaps.Util.assert(config,
                {
                    name: "BadParameter",
                    message: "LdMaps.featureLoader.loadFeatureByAddress: oggetto di configurazione deve essere valorizzato",
                    level: 1
                }
            );
            LdMaps.Util.assert(config.layer,
                {
                    name: "BadParameter",
                    message: "LdMaps.featureLoader.loadFeatureByAddress: Layer non trovato",
                    level: 1
                }
            );
            LdMaps.Util.assert(config.address,
                {
                    name: "BadParameter",
                    message: "LdMaps.featureLoader.loadFeatureByAddress: indirizzo deve essere valorizzato",
                    level: 1
                }
            );
        } catch(e) { throw e; }

        // impostazione parametri
        var layer = config.layer,
            address = config.address,
            html = config.html,
            properties = {
                "infoPopUp": html,
                "label": address,
                "tooltip": address
            };

        // imposto il flag loadend sul layer a false
        // viene poi reimpostato alla fine del caricamento richiamando l'evento loadend
        layer.loadend=false;

        // geocoding e caricamento feature
        try {
            LdMaps.Util.geoCode(
                address,
                properties,
                function(result) {
                    loadFeaturesCB(result, config);
                }
            );
        }
        catch (exception) {
            LdMaps.Util.handleException(exception);
        }

    }

    // funzione di callback che carica le feature sul layer
	function loadFeaturesCB (features, config) {

        var options,
            zoom,
            zoomLevel,
            clean,
            layer,
            featureCollection,
            setInitialExtent;

        layer = config.layer;
        options = config.options || {"zoom" : true , "zoomLevel" : 16, "clean": false};

        zoom = options.zoom;
        zoomLevel = options.zoomLevel;
        clean = options.clean;
        setInitialExtent = options.setInitialExtent;

        try {
            // deserializzo GeoJSON
            featureCollection = createFeaturesByGeoJSON(layer, features);

            // se impostato il flag clean ripulisco il layer
            if (clean) {
                layer.destroyFeatures();
            }

            // carico le feature sul layer
            layer.addFeatures(featureCollection);

            layer.redraw();

            // se impostato flag per zoom faccio lo zoom
            if (zoom) {
                layer.map.zoomToFeatures(featureCollection,zoomLevel);
            }

            // se impostato flag per impostare initialExtent della mappa lo imposto
            if (setInitialExtent) {
                layer.map.setInitialExtent(layer.map.getExtent());
            }

        }
        catch (exception) {
            throw {
                name: "BadFeatureFormat",
                message: "LdMaps.featureLoader.loadFeatures: Non sono riuscito a caricare le feature",
                level: 1
            };
        }


        // reimposto il loadend a true
        layer.events.triggerEvent("loadend");

    }

    // deserializza il GeoJSON in una featureCollection
    function createFeaturesByGeoJSON(layer, features) {
    // definisco il formato
        var format_geojson = new OpenLayers.Format.GeoJSON({
            "internalProjection": new OpenLayers.Projection(layer.map.projection),
            "externalProjection": layer.projection
        });
        // deserializzo il json nelle feature
        return format_geojson.read(features);
    }


	/*
        Public API
	*/
	return {

        /**
        *
        * Function: loadFeatures
        *
        * Carica le feature in formato GeoJSON in un layer di tipo OpenLayers.Layer.Vector
        *
        * Parameters:
        * loadConfig - {Object} Oggetto di configurazione
        *  - layer - {OpenLayers.Layer} Layer
        *  - features - {Object} Oggetto GeoJSON contenente le feature
		*  - url - {String} URL del servizio/file con serve le feature
        *  - options - {Object} Oggetto configurazione delle opzioni
        *  - - zoom - {Boolean} Flag per impostare lo zoom sulle feature caricate
        *  - - clean - {Boolean} Flag per indicare se bisogna cancellare eventuali feature preesistenti
        *
        *
        */
		loadFeatures : loadFeatures,

        /**
        *
        * Function: loadFeatureByAddress
        *
        * Effettua geocoding e caricamento di un indirizzo
        *
        * Parameters:
        * loadConfig - {Object} Oggetto di configurazione
        *  - layer - {OpenLayers.Layer} Layer
        *  - address - {String} Indirizzo da geocodificare
        *  - options - {Object} Oggetto configurazione delle opzioni
        *  - - zoom - {Boolean} Flag per impostare lo zoom sulle feature caricate
        *  - - zoomLevel - {Int} Livello di zoom
        *  - - clean - {Boolean} Flag per indicare se bisogna cancellare eventuali feature preesistenti
        *
        *
        */
		loadFeatureByAddress : loadFeatureByAddress

	};

}());
/**
* 
* Class: LdMaps.InfoPopupManager
*
* Gestore delle funzioni per la info e le popup
*
*
*/
LdMaps.InfoPopupManager = (function(){
    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    return {

        /**
         *
         * Function: onFeatureSelect
         *
         * Gestisce le operazioni di info e gestione popup.
         * Richiamato sulla select della feature
         *
         * Parameters:
         * feature - {OpenLayers.Feature} Feature
         *
         */
        onFeatureSelect: function(feature) {

            // Imposto la opzioni di configurazione
            var configOptions = LdMaps.InfoPopupManager.getConfigOptions(feature);

            // Gestione infoPopUp
            if (configOptions.infoPopUp) {
                LdMaps.InfoPopupManager.loadPopUp(feature,configOptions);
            } else {
                // Gestione infoUrl
                if (configOptions.infoUrl) {
                    LdMaps.InfoPopupManager.info(feature,configOptions);
                }
            }

        },

        /**
         *
         * Function: onFeatureUnselect
         *
         * Gestisce le operazioni di info e gestione popup.
         * Richiamato sulla unselect della feature
         *
         * Parameters:
         * feature - {OpenLayers.Feature} Feature
         *
         */
        onFeatureUnselect: function(feature) {
            // se esiste una popup la chiudo
            LdMaps.InfoPopupManager.destroyPopup(feature);
        },

        getConfigOptions: function(feature) {

            var infoAppo = {
                "infoLabelAttr" : null,
                "infoUrl" : null,
                "infoTarget" : null,
                "infoWidth" : null,
                "infoHeight" : null,
                "infoPopUp" : null
            },
            configOptions = {};

            configOptions.layerName = feature.layer.name;
            configOptions.layerConfig = feature.layer.map.layerManager.getLayerConfigByName(configOptions.layerName) || {};
            configOptions.infoOptions = configOptions.layerConfig.infoOptions || infoAppo;
            configOptions.infoLabelAttr = feature.attributes.infoLabelAttr || configOptions.infoOptions.infoLabelAttr;
            configOptions.infoUrl = feature.attributes.infoUrl || configOptions.infoOptions.infoUrl;
            configOptions.infoTarget = feature.attributes.infoTarget || configOptions.infoOptions.infoTarget;
            configOptions.infoWidth =  feature.attributes.infoWidth || configOptions.infoOptions.infoWidth;
            configOptions.infoHeight =  feature.attributes.infoHeight || configOptions.infoOptions.infoHeight;
            configOptions.infoPopUp = feature.attributes.infoPopUp || configOptions.infoOptions.infoPopUp;

            return configOptions;
        },

        info: function(feature,configOptions) {

            // attribute replacement {$attribute_name} - utilizzo la funzione OpenLayers.Style.createLiteral
            var infoUrl = OpenLayers.Style.createLiteral(configOptions.infoUrl, feature.attributes, feature);

            var map = feature.layer.map;


            if (configOptions.infoTarget) {
                if (configOptions.infoTarget === "panel") {
                    var id = "layerInfoMediaWin";
                    var mediaWin = new LdMaps.ExtMediaWindow(infoUrl,configOptions.infoWidth,configOptions.infoHeight,id);
                    // gestisco la deselezione della feature quando chiudo la finestra
                    mediaWin.on("destroy",
                            function() {
                                map.featureManager.selectFeatureControl.unselect(this);
                            },
                            feature
                        );
                    mediaWin.show();
                }
                else {
                    var options = "status=yes, toolbar=yes, menubar=no, width=" + configOptions.infoWidth + ", height=" + configOptions.infoHeight + ", resizable=yes, scrollbars=yes";
                    window.open(infoUrl, configOptions.infoTarget, options);
                }
            } else {
                window.document.location.href = infoUrl;
            }

        },


        loadPopUp: function(feature,configOptions) {

            var infoPopUp = configOptions.infoPopUp,
                popUpWidth = 150,
                popUpHeight = 100,
                maxPopUpWidth = 300,
                maxPopUpHeight = 200,
                closeBox = true,
                popup;

            // costruisco l'html per il default
            if (infoPopUp==="default") {
                infoPopUp = LdMaps.InfoPopupManager.buildDefaultPopup(configOptions);
            }

            // se cluster costruisco popup per il cluster
            if(feature.cluster) {
                if (feature.attributes.count > 1) {
                    infoPopUp = LdMaps.InfoPopupManager.buildClusterPopup(configOptions,feature);
                } else {
                    feature.attributes = feature.cluster[0].attributes;
                    feature.attributes.count = 1;
                }
            }

            // attribute replacement {$attribute_name} - utilizzo la funzione OpenLayers.Style.createLiteral
            infoPopUp = OpenLayers.Style.createLiteral(infoPopUp, feature.attributes, feature);

            // decodifico eventuali encoding html (&amp;, ecc...)
            infoPopUp = LdMaps.Util.unescapeHtmlEntities(infoPopUp);

            //costruisco la popup
            //var popup = new OpenLayers.Popup.Anchored(
            popup = new OpenLayers.Popup.FramedCloud(
                "featurePopup",
                 feature.geometry.getBounds().getCenterLonLat(),
                 new OpenLayers.Size(popUpWidth,popUpHeight),
                 infoPopUp,
                 null,
                 closeBox,
                function(evt) {
                    // 'this' is the popup.
                    this.feature.layer.map.featureManager.selectFeatureControl.unselect(this.feature);
                }
            );
            popup.maxSize = new OpenLayers.Size(maxPopUpWidth,maxPopUpHeight);

        // aggiungo alla feature e alla mappa
            // HACK per risolvere il seguente malfunzionamento
            // Se aggiungo un layer vettoriale mi si sputtanano le pop-up (non vengono cancellate sull'unselect, non funziona il tasto close).
            // il problema � legato al fatto che viene chiamato due volte la funzione onFeatureSelect e quindi create due popup sulla feature
            // Quindi creo la popup sulla feature solo se non esiste gi�
            if (!feature.popup) {
                feature.popup = popup;
                popup.feature = feature;
                popup.panMapIfOutOfView = true;
                // imposto lo sfondo delle popup
                popup.backgroundColor = "#BBCCFF";
                popup.opacity=0.9;
                // aggiungo la popup alla mappa
                feature.layer.map.addPopup(popup);
            }
        },

        buildDefaultPopup: function(configOptions) {

            var defaultPopUp = "<div class='defaultPopUpTitle'>" + configOptions.layerConfig.legend.label + "<br><br></div>";
            defaultPopUp += "<div class='defaultPopUpLabel'>${" + configOptions.infoLabelAttr + "}<br><br></div>";
            if (configOptions.infoUrl) {
                defaultPopUp += "<div class='defaultPopUpLink'><a href=" + configOptions.infoUrl;
                if(configOptions.infoTarget) {
                    defaultPopUp += " target='" + configOptions.infoTarget + "'";
                }
                defaultPopUp += ">Dettagli</a></div>";
            }
            return defaultPopUp;

        },

        buildClusterPopup: function(configOptions,feature) {
            var appId = feature.layer.map.appId;
            var layerName = feature.layer.name;
            var featureId = feature.id;

            var clusterPopUp = "<div class='defaultPopUpTitle'>" + configOptions.layerConfig.legend.label + "<br><br></div>";
            clusterPopUp += "<div class='defaultPopUpLabel'>" + feature.attributes.count + " Elementi<br><br></div>";
            clusterPopUp += "<div class='defaultPopUpLink'>"
            clusterPopUp += "<a href=javascript:LdMaps.InfoPopupManager.zoomClusterPopup(" + appId + "," + feature.geometry.x + "," + feature.geometry.y + ",'" + layerName + "','" + featureId + "')>Zoom</a></div>" ;

            return clusterPopUp;
        },

        zoomClusterPopup: function(appId,x,y,layerName,featureId) {
            var map = LdMaps.appRegistry.get(appId).map;
            var layer = map.getLayerByName(layerName);
            var feature = layer.getFeatureById(featureId);

            LdMaps.InfoPopupManager.destroyPopup(feature);

            var zoomLevel = map.zoom + 2;
            map.zoomToPoint(x,y,zoomLevel);
        },

        destroyPopup: function(feature) {
            if (feature.popup) {
                var map = feature.layer.map;
                var popup = feature.popup;
                popup.feature = null;
                map.removePopup(feature.popup);
                feature.popup.destroy();
                feature.popup = null;
            }
        }


    };

}());

/**
*
* Class: LdMaps.FeatureManager
*
* Gestore dei controlli per le features vettoriali.
*
* Crea i controlli OL di tipo FeatureSelect per select/hilite/hover.
*
* Comprende le funzioni di callback richiamate sull'evento "featureselect"
*
*
*/
LdMaps.FeatureManager = function(map) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    LdMaps.Util.log("LdMaps.LayerManager");

    this.hiliteFeatureControl = null;
    this.selectFeatureControl = null;
    this.hoverFeatureControl = null;

    // dizionario delle funzioni di callback registrate
    this.registeredCallbacks = {
        "onFeatureSelect" : [],
        "onFeatureUnselect" : [],
        "onFeatureOver" : [],
        "onFeatureOut" : []
    };


   /**
   *
   * Function: registerCallback
   *
   * Registra una  funzione di callback
   *
   * Parameters:
   * event - {String} evento
   * callback - {Function} funzione di callback
   *
   * Return:
   * {Boolean} true se la feature � tra quelle selezionate
   *
   */
    this.registerCallback = function(event,callback) {
        this.registeredCallbacks[event].push(callback);
    };

    /**
    *
    * Function: getRegisteredCallbacks
    *
    * Ritorna una funzione di callback associata ad un evento
    *
    * Parameters:
    * event - {String} evento
    *
    * Return:
    * {Function} funzione di callback
    *
    */
    this.getRegisteredCallbacks = function(event) {
        return this.registeredCallbacks[event];
    };

   // Attiva il controllo OL
    this.activateHiliteFeatureControl = function(vectLayerArray) {

        this.hiliteFeatureControl = new OpenLayers.Control.SelectFeature(vectLayerArray);
        this.hiliteFeatureControl.renderIntent = "hilite";
        this.hiliteFeatureControl.highlightOnly = true;
        this.hiliteFeatureControl.hover = true;
        this.hiliteFeatureControl.name = "hiliteFeatureControl";

        map.addControl(this.hiliteFeatureControl);
        this.hiliteFeatureControl.activate();

    };


    // Attiva il controllo OL
    this.activateHoverFeatureControl = function(vectLayerArray) {

        // funzione richiamata sull"evento mouseover della feature
        var onFeatureOver = function(feature,callbacks) {

            for(var i=0; i < callbacks.length; i++) {
                if (typeof callbacks[i] === "function") {
                    callbacks[i](feature);
                }
            }

        };

        // funzione richiamata sull'evento mouseout della feature
        var onFeatureOut = function(feature,callbacks) {

            for(var i=0; i < callbacks.length; i++) {
                if (typeof callbacks[i] === "function") {
                    callbacks[i](feature);
                }
            }

        };

        var featureOutCallbacks = this.getRegisteredCallbacks("onFeatureOut");
        var featureOverCallbacks = this.getRegisteredCallbacks("onFeatureOver");

        this.hoverFeatureControl = new OpenLayers.Control.SelectFeature(vectLayerArray, {
            hover: true,
            renderIntent: "hover",
            highlightOnly: true,
            eventListeners: {
                featurehighlighted:function(e){
                    onFeatureOver(e.feature,featureOverCallbacks);
                },
                featureunhighlighted:function(e){
                    onFeatureOut(e.feature,featureOutCallbacks);
                }
            }
        });


        this.hoverFeatureControl.name = "hoverFeatureControl";
        map.addControl(this.hoverFeatureControl);
        this.hoverFeatureControl.activate();

    };

    // Attiva il controllo OL
    this.activateSelectFeatureControl = function(vectLayerArray) {

        // funzione richiamata sull'evento select della feature
        var onFeatureSelect = function(feature,callbacks) {

            // Gestione Info e Popup
            LdMaps.InfoPopupManager.onFeatureSelect(feature);

            // Richiamo delle funzioni di callback registrate
            for(var i=0; i < callbacks.length; i++) {
                if (typeof callbacks[i] === "function") {
                    callbacks[i](feature);
                }
            }

        };

        // funzione richiamata sull'evento unselect della feature
        var onFeatureUnselect = function(feature,callbacks) {

            // Gestione Info e Popup
            LdMaps.InfoPopupManager.onFeatureUnselect(feature);

            // Richiamo delle funzioni di callback registrate
            for(var i=0; i < callbacks.length; i++) {
                if (typeof callbacks[i] === "function") {
                    callbacks[i](feature);
                }
            }

        };

        var featureSelectCallbacks = this.getRegisteredCallbacks("onFeatureSelect");
        var featureUnselectCallbacks = this.getRegisteredCallbacks("onFeatureUnselect");

        this.selectFeatureControl = new OpenLayers.Control.SelectFeature(vectLayerArray);
        this.selectFeatureControl.onSelect = function(feature) {
            onFeatureSelect(feature,featureSelectCallbacks);
        };
        this.selectFeatureControl.onUnselect = function(feature) {
            onFeatureUnselect(feature,featureUnselectCallbacks);
        };
        this.selectFeatureControl.name = "selectFeatureControl";

        map.addControl(this.selectFeatureControl);
        this.selectFeatureControl.activate();

    };

    /**
     *
     * Function: registerAction
     *
     * Registra le azioni collegate adi layer vettoriali
     *
     * Parameters:
     * layersConfig - {Array} Array di configurazione dei layer
     *
     */
    this.registerAction = function(layersConfig) {

        var len = layersConfig.length,
            i,
            j,
            event,
            callbackName,
            callback,
            exception;


        for (i = 0; i < len; i++) {
            if (layersConfig[i].actions && layersConfig[i].actions.length > 0) {
                for (j = 0; j < layersConfig[i].actions.length; j++) {
                    // controllo che esistano actions.event e actions.callback in configurazione
                    event = layersConfig[i].actions[j].event;
                    if (!event) {
                        exception = {
                            name: 'BadAction',
                            message: 'LdMaps.FeatureManager.registerAction: event non definito',
                            level: 1
                        };
                        LdMaps.util.handleException(exception);
                        return;
                    }
                    callbackName = layersConfig[i].actions[j].callback;
                    if (!callbackName) {
                        exception = {
                            name: 'BadAction',
                            message: 'LdMaps.FeatureManager.registerAction: calback non definito',
                            level: 1
                        };
                        LdMaps.util.handleException(exception);
                        return;
                    }
                    callback = LdMaps.featureActionsRegistry[callbackName];
                    if (typeof callback !== "function") {
                        exception = {
                            name: 'BadCallbackName',
                            message: 'LdMaps.FeatureManager.registerAction: funzione di callback ' + callbackName + ' non esiste',
                            level: 1
                        };
                        LdMaps.util.handleException(exception);
                        return;
                    }

                    // registro la action
                    this.registerCallback(
                        layersConfig[i].actions[j].event,
                        callback
                    );
                }
            }
        }

    };

    this.updateControlLayer = function() {
        var vectLayers = map.getLayersByClass("OpenLayers.Layer.Vector");

        // levo i layer _info
        for (var i = 0; i < vectLayers.length; i++) {
            if (vectLayers[i].name.indexOf("_INFO") > 0) {
                vectLayers.splice(i,1);
            }
        }

        // ATTENZIONE:
        // NON MODIFICARE L'ORDINE DI AGGIORNAMENTO DEI CONTROLLI
        this.hoverFeatureControl.setLayer(vectLayers);
        this.hiliteFeatureControl.setLayer(vectLayers);
        this.selectFeatureControl.setLayer(vectLayers);
    };

    this.activateControls = function() {
        // ATTENZIONE:
        // NON MODIFICARE L'ORDINE DI AGGIORNAMENTO DEI CONTROLLI
        this.hoverFeatureControl.activate();
        this.hiliteFeatureControl.activate();
        this.selectFeatureControl.activate();
    };

    this.deactivateControls = function() {
        // ATTENZIONE:
        // NON MODIFICARE L'ORDINE DI AGGIORNAMENTO DEI CONTROLLI
        this.hoverFeatureControl.deactivate();
        this.hiliteFeatureControl.deactivate();
        this.selectFeatureControl.deactivate();
    };

    // carico l'array con i layer vettoriali
    var vectLayerArray = map.getLayersByClass("OpenLayers.Layer.Vector");

    // ATTENZIONE:
    // NON MODIFICARE L'ORDINE DI CREAZIONE DEI CONTROLLI
    // L'ULTIMO DEVE ESSERE QUELLO PER LA SELECT
    // NON MODIFICARE LA MODALITA' DI CREAZIONE DEI CONTROLLI DI HILITE E OVER
    this.activateHoverFeatureControl(vectLayerArray);
    this.activateHiliteFeatureControl(vectLayerArray);
    this.activateSelectFeatureControl(vectLayerArray);

    // registro le action sui layer vettoriali
    this.registerAction(map.layerManager.getLayersConfig());

};


/**
 *
 * Class: LdMaps.featureActionsRegistry
 *
 * Oggetto che raccoglie le funzioni di callback associate agli eventi sulle feature
 *
 *
 */

LdMaps.featureActionsRegistry = (function(){

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";


    // Funzione di test per verificare la registrazione del callback sull'evento mouseover
    function testOver(feature) {
        LdMaps.Util.log(feature);
    }

    // Funzione di test per verificare la registrazione del callback sull'evento mouseout
    function testOut(feature) {
        LdMaps.Util.log(feature);
    }

    // Funzione di test per verificare la registrazione del callback sull'evento select
    function testSelect(feature) {
        LdMaps.Util.log("testSelect");
    }

    // Funzione di test per verificare la registrazione del callback sull'evento unselect
    function testUnselect(feature) {
        LdMaps.Util.log("testUnselect");
    }

	/*
      Public API
	*/
	return {

        /**
        * Function: testOver
        * Funzione di test per verificare la registrazione del callback sull'evento mouseover
        *
        */
        testOver: testOver,

        /**
        * Function: testOut
        * Funzione di test per verificare la registrazione del callback sull'evento mouseout
        *
        */
        testOut: testOut,

        /**
        * Function: testSelect
        * Funzione di test per verificare la registrazione del callback sull'evento select
        *
        */
        testSelect: testSelect,

        /**
        * Function: testUnselect
        * Funzione di test per verificare la registrazione del callback sull'evento unselect
        *
        */
        testUnselect: testUnselect

	};

}());
/**
*
* Class: LdMaps.featureSelecter
* 
 *
 * Oggetto per la selezione programmatica di feature
 *
*/

LdMaps.featureSelecter = (function(){

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";


	/*
      private properties
	*/

	/*
      private methods
	*/

    function selectFeature(selectConfig,feature){

        try {
            LdMaps.Util.assert(selectConfig,
                {
                    name: "BadParameter",
                    message: "LdMaps.featureSelected.selectFeature: selectConfig deve essere valorizzato",
                    level: 1
                }
            );
            LdMaps.Util.assert(selectConfig.layer,
                {
                    name: "BadParameter",
                    message: "LdMaps.featureSelected.selectFeature: layer deve essere valorizzato",
                    level: 1
                }
            );
            LdMaps.Util.assert(feature || selectConfig.attrName,
                {
                    name: "BadParameter",
                    message: "LdMaps.featureSelected.selectFeature: attrName (oppure feature) deve essere valorizzato",
                    level: 1
                }
            );
            LdMaps.Util.assert(
                ( feature ||
                        ( selectConfig.item !== null && selectConfig.item !== undefined )
                ),
                {
                    name: "BadParameter",
                    message: "LdMaps.featureSelected.selectFeature: item (oppure feature) deve essere valorizzato",
                    level: 1
                }
            );
        } catch(e) { throw e; }


        // configurazione hilite
        var layer = selectConfig.layer,
            attrName = selectConfig.attrName,
            item = selectConfig.item,
            options = selectConfig.options || {"zoom" : false, "hiliteOnly": false},
            zoom = options.zoom,
            maxZoomLevel = options.maxZoomLevel,
            hiliteOnly = options.hiliteOnly,
            foundFeatures,
            foundFeature;

        if (feature) {
            foundFeature = feature;
        } else {
            // cerco nelle feature del layer quelle che soddisfano il criterio e seleziono la prima
            foundFeatures = layer.getFeaturesByAttribute(attrName,item);
            if (foundFeatures.length > 0) {
                foundFeature = foundFeatures[0];
            }
        }
        if (foundFeature) {
            if (hiliteOnly) {
                layer.map.featureManager.hoverFeatureControl.highlight(foundFeature);
            } else {
                var selectFeatureControl = layer.map.featureManager.selectFeatureControl;
                selectFeatureControl.unselectAll();
                selectFeatureControl.select(foundFeature);
            }
            // se impostato flag per zoom faccio lo zoom
            if (zoom) {
                layer.map.zoomToFeatures([foundFeature],maxZoomLevel);
            }
        }
    }

    function  unselectFeature(selectConfig,feature){

        //LdMaps.Util.log("LdMaps.featureSelected.unselectFeature");


        try {
            LdMaps.Util.assert(selectConfig,
                {
                    name: "BadParameter",
                    message: "LdMaps.featureSelected.unselectFeature: selectConfig deve essere valorizzato",
                    level: 1
                }
            );
            LdMaps.Util.assert(selectConfig.layer,
                {
                    name: "BadParameter",
                    message: "LdMaps.featureSelected.unselectFeature: layer deve essere valorizzato",
                    level: 1
                }
            );
            LdMaps.Util.assert(feature || selectConfig.attrName,
                {
                    name: "BadParameter",
                    message: "LdMaps.featureSelected.unselectFeature: attrName (oppure feature) deve essere valorizzato",
                    level: 1
                }
            );
            LdMaps.Util.assert(feature || selectConfig.item,
                {
                    name: "BadParameter",
                    message: "LdMaps.featureSelected.unselectFeature: item (oppure feature) deve essere valorizzato",
                    level: 1
                }
            );
        } catch(e) { throw e; }


        // configurazione hilite
        var layer = selectConfig.layer,
            attrName = selectConfig.attrName,
            item = selectConfig.item,
            options = selectConfig.options || {"hiliteOnly": false},
            hiliteOnly = options.hiliteOnly,
            foundFeatures,
            foundFeature,
            selectConfig2 = {};

        if (feature) {
            foundFeature = feature;
        } else {
            // cerco nelle feature del layer quelle che soddisfano il criterio e seleziono la prima
            foundFeatures = layer.getFeaturesByAttribute(attrName,item);
            if (foundFeatures.length > 0) {
                foundFeature = foundFeatures[0];
            }
        }


        if (foundFeature) {
            if (hiliteOnly) {
                layer.map.featureManager.hoverFeatureControl.unhighlight(foundFeature);
                if (foundFeature.isSelected()) {
                    selectConfig2.layer = selectConfig.layer;
                    selectConfig2.attrName = selectConfig.attrName;
                    selectConfig2.item = selectConfig.item;
                    selectConfig2.options = {"hiliteOnly": false};
                    selectFeature(selectConfig2,foundFeature);

                }
            } else {
                layer.map.featureManager.selectFeatureControl.unselect(foundFeature);
            }
        }
    }

	/*
      Public API
	*/
	return {


        /**
        *
        * Function: selectFeature
        *
        * Selezione programmatica feature di un layer vettoriali.
        *
        * Se pi� feature soddisfano il criterio di selezione solo la prima viene selezionata.
        *
        * Se impostato il parametro options.hiliteOnly=true viene fatto solo l'highlight della feaure.
        *
        * Se impostato il parametro feature viene selezionata la feature,
        * altrimenti viene fatta una ricerca della feature sul layer in base alla configurazione del parametro config.
        *
        *
        * Parameters:
        * config - {Object} Oggetto di configurazione dell'hilite
        *  - layerName - {String} Nome del layer
        *  - attrName - {String} Nome dell'attributo
        *  - item - {String}/{Number} Valore
        *  - options - {Object} Oggetto configurazione delle opzioni
        *  -  - zoom - {Boolean} Flag per impostare lo zoom sulle feature caricate
        *  -  - hiliteOnly - {Boolean} Flag per effettuare solo l'highlight della feature (default: false)
         * feature - {OpenLayers.Feature} Feature da selezionare
        *
        *  Esempio:
        *  (start code)
        * var selectConf = {
        *			"layerName": "Prova",
        *			"attrName": "ID",
        *				"items": "1"
        *			},
        *			"options": {
         *				"zoom": false,
         *				"hiliteOnly": false
        *			}
        *		};
        *   (end)
        *
        */

		selectFeature : selectFeature,

        /**
        *
        * Function: unselectFeature
        *
        * Deselezione programmatica feature di un layer vettoriali.
        *
        * Se pi� feature soddisfano il criterio di selezione solo la prima viene deselezionata.
        *
        * Se impostato il parametro options.hiliteOnly=true viene fatto solo l'unhighlight della feaure.
        *
        * Se impostato il parametro feature viene deselezionata la feature,
        * altrimenti viene fatta una ricerca della feature sul layer in base alla configurazione del parametro config
        *
        *
         * Parameters:
         * config - {Object} Oggetto di configurazione dell'hilite
         *  - layerName - {String} Nome del layer
         *  - attrName - {String} Nome dell'attributo
         *  - item - {String}/{Number} Valore
         *  - options - {Object} Oggetto configurazione delle opzioni
         *  -  - hiliteOnly - {Boolean} Flag per effettuare solo l'highlight della feature (default: false)
          * feature - {OpenLayers.Feature} Feature da selezionare
         *
         *  Esempio:
         *  (start code)
         * var selectConf = {
         *			"layerName": "Prova",
         *			"attrName": "ID",
         *				"items": "1"
         *			},
         *			"options": {
          *				"hiliteOnly": false
         *			}
         *		};
         *   (end)
         *
         */

        unselectFeature : unselectFeature


	};

}());


/**
 *
 * Class: LdMaps.LayerManager
 *
 * Oggetto per la gestione dei layer:
 *
* -	Inizializzare i repository dei layer
* -	Fornire informazioni sui layer disponibili ai moduli che lo richiedono, in particolare i metodi getBaseLayersConfig e getLayersConfig forniscono le configurazioni dei layer di base e overlay
* -	Aggiungere layer ai repository
* -	Rimuovere i layer dai repository
* -	Creazione di layer di servizio (per esempio per le operazioni di find o calcolo percorsi)
 *
 *
 */
LdMaps.LayerManager = function(baseLayers,overlayLayers,appId) {

    /*global LdMaps:false, Ext:false, window:false, OpenLayers:false */
    "use strict";

    LdMaps.Util.log("LdMaps.LayerManager");

    /*
        Proprietà Pubbliche
     */
    this.overlayLayerStore = null;
    this.baseLayerStore = null;
    this.overlayLayersConfig = overlayLayers;
    this.baseLayersConfig = baseLayers;

    var app = LdMaps.appRegistry.get(appId);

    /*
        Metodi
     */


    // imposta il flag isBaseLayer e la visibilità sui base layer
    this.setBaseLayers = function() {

        // imposto la proprietà isBaseLayer a true per i baseLayers
        var visible,i, len = this.baseLayersConfig.length;
        visible = false;
        for (i = 0; i < len; i ++) {
            if (this.baseLayersConfig[i].visible) {
                visible = true;
            }
            this.baseLayersConfig[i].isBaseLayer = true;
        }

        // se non esiste nessun baseLayer visibile rendo visibile l'ultimo
        if (!visible) {
            this.baseLayersConfig[len - 1].visible = true;
        }

    };

    /**
    *
    * Function: getLayerConfigByName
    *
    * Ritorna la configurazione di un layer
    *
    * Parameters:
    * name - {String} Nome del layer
    *
    * Returns:
    * {Object} Configurazione del layer
    *
    */
    this.getLayerConfigByName = function(layerName) {
        var i,len = this.overlayLayersConfig.length;
        for (i = 0; i < len; i++) {
            if (this.overlayLayersConfig[i].name===layerName) {
                return this.overlayLayersConfig[i];
            }
        }
        return null;
    };

    /**
    *
    * Function: getLayerIndexByName
    *
    * Ritorna l'indice di un layer in configurazione
    *
    * Parameters:
    * name - {String} Nome del layer
    *
    * Returns:
    * {Integer}
    *
    */
    this.getLayerIndexByName = function(layerName) {
        var i , len = this.overlayLayersConfig.length;
        for (i = 0; i < len; i++) {
            if (this.overlayLayersConfig[i].name===layerName) {
                return i;
            }
        }
        return -1;
    };

    /**
    *
    * Function: isbaseLayerInConfig
    *
    * Indica se il baseLayer è in configurazione
    *
    * Parameters:
    * name - {String} Nome del layer
    *
    * Returns:
    * {Boolean}
    *
    */
    this.isBaseLayerInConfig = function(layerName) {
        var i , len;
        len = this.baseLayersConfig.length;
        for (i = 0; i < len; i++) {
            if (layerName === this.baseLayersConfig[i].name) {
                return true;
            }
        }
        return false;
    };

    /**
    *
    * Function: isLayerInConfig
    *
    * Indica se il layer è in configurazione
    *
    * Parameters:
    * name - {String} Nome del layer
    *
    * Returns:
    * {Boolean}
    */
    this.isLayerInConfig = function(layerName) {
        var i , len;
        len = this.overlayLayersConfig.length;
        for (i = 0; i < len; i++) {
            if (layerName === this.overlayLayersConfig[i].name) {
                return true;
            }
        }
        return false;
    };

    // costruisce lo store dei layer in base al tipo
    this.buildLayerStoreByType = function(type) {
        var layers = [],
        layersConfig,
        i,
        len,
        idStore = type + "-layer-store",
        layerStore;

        if (type === "overlay") {
            layersConfig = this.overlayLayersConfig;
        } else {
            layersConfig = this.baseLayersConfig;
        }

          if (layersConfig) {
              len = layersConfig.length;
            for (i = 0; i < len; i++) {
                if ((layersConfig[i].showInLegend === undefined) || (layersConfig[i].showInLegend === true)) {
                    layers.push(layersConfig[i]);
                }
            }
        }
        layers.reverse();


        layerStore = new Ext.data.JsonStore({
            id: idStore,
            data: layers,
            fields: [{
                name: "name", mapping: "name"
            },{
                name: "legend", mapping: "legend"
            }
            ]
        });

        if (type === "overlay") {
              this.overlayLayerStore = layerStore;
        } else {
              this.baseLayerStore = layerStore;
        }
    };

    // rimuove un layer dallo store
    this.removeLayerFromStore = function(layerName) {

        LdMaps.Util.log("LdMaps.LayerManager.removeLayerFromStore");

        var storeItems = this.overlayLayerStore.data.items,
            item,
            len2 = storeItems.length,
            rec;

        for (item = 0; item < len2; item++) {
            if (storeItems[item]) {
                if (storeItems[item].data.name === layerName) {
                    rec = this.overlayLayerStore.getAt(item);
                    this.overlayLayerStore.remove(rec);
                }
            }
        }
    };

    // aggiunge un layer allo store
    this.addLayerToStore = function(layerConfig) {

        LdMaps.Util.log("LdMaps.LayerManager.addLayerToStore");

        if ((layerConfig.showInLegend === undefined) || (layerConfig.showInLegend === true)) {
            if (this.overlayLayerStore) {
                var rec = new this.overlayLayerStore.recordType(layerConfig);
                this.overlayLayerStore.insert(0, rec);
            } else {
                this.initStore();
            }
        }
    };

    // aggiunge un base layer allo store
    this.addBaseLayerToStore = function(layerConfig) {

        LdMaps.Util.log("LdMaps.LayerManager.addBaseLayerToStore");

        if ((layerConfig.showInLegend === undefined) || (layerConfig.showInLegend === true)) {
            if (this.baseLayerStore) {
                var rec = new this.baseLayerStore.recordType(layerConfig);
                  this.baseLayerStore.insert(0, rec);
            } else {
                this.initStore();
            }
        }
    };

    /**
    *
    * Function: getOverlayLayersNameFromStore
    *
    * Ritorna un array con i nomi dei layer nello store
    *
    * Returns:
    * layerNames - {Array} Array contenente i nomi dei layer nello store
    *
    */
    this.getOverlayLayersNameFromStore = function() {

        LdMaps.Util.log("LdMaps.LayerManager.getOverlayLayersNameFromStore");

        if(this.overlayLayerStore) {
            var layersName = [],
                storeItems = this.overlayLayerStore.data.items,
                item,
                len2 = storeItems.length;

            for (item = 0; item < len2; item++) {
                layersName.push(storeItems[item].data.name);
            }

            return layersName;
        }

    };

    /**
    *
    * Function: getLayerStore
    *
    * Ritorna lo store dei layer
    *
    * Parameters:
    * type  - {String} Tipo di store ("base"/"overlay")
    *
    * Returns:
    * store - {Ext.data.JsonStore}
    *
    */
    this.getLayerStore = function(type) {

        LdMaps.Util.log("LdMaps.LayerManager.getLayerStore");

        if (type === "base") {
            return this.baseLayerStore;
        } else {
            return this.overlayLayerStore;
        }

    };

    function updateSelectControls(layers) {
// aggiorno il controllo per la selezione delle feature dei livelli vettoriali
        if (app.map) {
            // ATTENZIONE:
            // NON MODIFICARE L'ORDINE DI AGGIORNAMENTO DEI CONTROLLI
            app.map.featureManager.hoverFeatureControl.setLayer(layers);
            app.map.featureManager.hiliteFeatureControl.setLayer(layers);
            app.map.featureManager.selectFeatureControl.setLayer(layers);
        }
    }

    /**
    *
    * Function: addLayers
    *
    * Aggiunge i layer alla applicazione (aggiorna configurazione, store, mappa e legenda)
    *
    * Parameters:
    * layers - {Array/Object} Array oppure singolo oggetto contenente la configurazione dei layer
    *
    *
    */
    this.addLayers = function(layersIn) {

        LdMaps.Util.log("LdMaps.LayerManager.addLayers");

        LdMaps.Util.assert(layersIn,
            {
                name: "BadParameter",
                message: "LdMaps.LayerManager.addLayers: parametro deve essere valorizzato",
                level: 1
            }
        );

        var layers;

        if (layersIn instanceof Array) {
            layers = layersIn;
        } else {
            layers = [layersIn];
        }

        var i,
            len = layers.length,
            layer;

        // aggiungo i layer alla configurazione (se non sono già presenti)
        for (i = 0; i < len; i++) {
            layer = layers[i];
            if (!this.isLayerInConfig(layer.name)) {
                // aggiorno la configurazione
                this.overlayLayersConfig.push(layer);
                // aggiorno la mappa
                var olLayer = app.map.loadLayer(layer);
                // aggiorno gli store
                this.addLayerToStore(layer);
                if (layer.name.indexOf("_INFO") < 0) {
                    // registro le action sugli eventi delle feature per i livelli vettoriali
                    app.map.featureManager.registerAction([layer]);
                }
                // aggiorno il controllo per la getFeatureInfo dei livelli WMS se il layer è interrogabile
                if (layer.type === "WMS" && layer.queryable) {
                    var infoWmsControl = app.map.getControl("infoWmsControl");
                    if (infoWmsControl) {
                        infoWmsControl.addLayers([olLayer]);
                    }
                }
            }
        }

        // aggiorno il controllo per la selezione delle feature dei livelli vettoriali
        if (app.map) {
            app.map.featureManager.updateControlLayer();
        }


    };

    /**
    *
    * Function: addBaseLayers
    *
    * Aggiunge i baseLayer alla applicazione (aggiorna configurazione, store, mappa e legenda)
    *
    * Parameters:
    * layers - {Array/Object} Array oppure singolo oggetto contenente la configurazione dei layer
    *
    *
    */
    this.addBaseLayers = function(layersIn) {

        LdMaps.Util.log("LdMaps.LayerManager.addBaseLayers");

        LdMaps.Util.assert(layersIn,
            {
                name: "BadParameter",
                message: "LdMaps.LayerManager.addBaseLayers: parametro deve essere valorizzato",
                level: 1
            }
        );

        var layers;

        if (layersIn instanceof Array) {
            layers = layersIn;
        } else {
            layers = [layersIn];
        }


        var i,
            len = layers.length,
            layer;


        // aggiungo i layer alla configurazione (se non sono già presenti)
        for (i = 0; i < len; i++) {
            layer = layers[i];
            if (!this.isBaseLayerInConfig(layer.name)) {
                layer.isBaseLayer = true;
                // aggiorno la configurazione
                this.baseLayersConfig.push(layer);
                // aggiorno la mappa
                app.map.loadLayer(layer);
                // aggiorno gli store
                this.addBaseLayerToStore(layer);
            }
        }

    };

    /**
    *
    * Function: remove
    *
    * Rimuove i layer dalla applicazione
    *
    * Parameters:
    * layersName - {Array} Array contenente i nomi dei layer
    *
    *
    */
    this.remove = function(layersName) {
        LdMaps.Util.log("LdMaps.LayerManager.remove");

        var layers = (Ext.isArray(layersName))? layersName : [layersName];

        var me = this;

        Ext.each(layers, function(layerName,i) {
            // aggiorno la configurazione
            var index = this.getLayerIndexByName(layerName);
            if (index !== -1){
                this.overlayLayersConfig.splice(index,1);
            }
            // aggiorno la mappa
            app.map.removeLayerByName(layerName);
            //Se il layer ha un hilite sld rimuovo anche il layer dell'hilite
            if (app.map.wmsSldHiliter && app.map.wmsSldHiliter.hilitedLayerName === layerName) {
                app.map.removeLayerByName(app.map.wmsSldHiliter.hiliteLayerName);
            }
            // aggiorno il controllo per la getFeatureInfo dei livelli WMS se il layer è interrogabile
            var infoWmsControl = app.map.getControl("infoWmsControl");
            if (infoWmsControl) {
                var infoWmsControlLayers = infoWmsControl.layers;
                if (infoWmsControlLayers) {
                    for (var j = 0; j < infoWmsControlLayers.length; j++) {
                        if (infoWmsControlLayers[j].name === layerName) {
                            infoWmsControlLayers.splice(j,1);
                        }
                    }
                }
            }
            // aggiorno lo store dei layer
            me.removeLayerFromStore(layersName[i]);
        });


        if (app.map) {
            app.map.featureManager.updateControlLayer();
        }

    };

    /**
    *
    * Function: createVectorLayer
    *
    * Crea un layer vettoriale. Utilizzato da Find, CalcoloPercorsi per creare il layer delle evidenziazioni
    *
    * Parameters:
    * config - {Object} Oggetto configurazione della combo.
    *
    * - layerName - {String} Nome del layer
    * - format - {String} Formato del layer (GeoJSON/WFS)
    * - classes - {Array} Array delle classi
    * - infoOptions - {Object} Oggetto contentente le opzioni per la info
    * - legend - {Object} Oggetto contentente la configurazione della legenda
    *
    * Returns:
    * layer - {OpenLayers.Layer.Vector} Il layer vettoriale creato
    *
    */
    this.createVectorLayer = function(config) {

        LdMaps.Util.log("LdMaps.LayerManager.createVectorLayer");

        var format = config.format;
        var layerName = config.name;
        var classes = config.classes;
        var infoOptions = config.infoOptions;
        var legend = config.legend;
        var showInLegend = false;
        var projection = config.projection || "EPSG:4326";

        if (format !== "GeoJSON") {
            if(LdMaps.debug) {
                LdMaps.Util.log("ERRORE: LdMaps.LayerManager.createVectorLayer: formato non supportato");
            }
            return null;
        }

        if (legend) {
            showInLegend = true;
        }

        // se non esiste creo il layer vettoriale
        if (!this.isLayerInConfig(layerName)) {
            var layerConfig = {
                "type": "GeoJSON",
                "name": layerName,
                "projection": projection,
                "isBaseLayer": false,
                "url": null,
                "visible": true,
                "showInLegend": showInLegend,
                "classes": classes,
                "infoOptions": infoOptions,
                "legend" : legend
            };
            this.addLayers(layerConfig);
        }

        // ritorno il layer
        return app.map.getLayerByName(layerName);

    };

    /**
    *
    * Function: createWMSLayer
    *
    * Crea un layer WMS. Utilizzato da Info per creare il layer delle evidenziazioni
    *
    * Parameters:
    * config - {Object} Oggetto configurazione del layer WMS.
    *
    *
    * Returns:
    * layer - {OpenLayers.Layer.WMS} Il layer WMS creato
    *
    */
    this.createWMSLayer = function(layerConfig) {

        LdMaps.Util.log("LdMaps.LayerManager.createWMSLayer");

        // se non esiste creo il layer WMS
        if (!this.isLayerInConfig(layerConfig.name)) {
            this.addLayers(layerConfig);
        }

        // ritorno il layer
        return app.map.getLayerByName(layerConfig.name);

    };

    // inizializza gli store dei layer
    this.initStore = function() {

        LdMaps.Util.log("LdMaps.LayerManager.initStore");

        // inizializzo gli store
        if (app.extRequired) {
            this.buildLayerStoreByType("base");
            this.buildLayerStoreByType("overlay");
        }

    };

    /**
    *
    * Function: getLayersConfig
    *
    * Ritorna la configurazione dei layer
    *
    * Returns:
    * config - {Array} Array contenente la configurazione del layer
    */
    this.getLayersConfig = function() {
        return this.overlayLayersConfig;
    };

    /**
    *
    * Function: getHiliteLayers
    *
    * Ritorna i layer di tipo hilite (hiliteLayer = true)
    *
    * Returns:
    * config - {Array} Array contenente i layer di hilite (nome e hilitedLayerName)
    */
    this.getHiliteLayers = function(hilitedLayerName) {

        var i,
            len = app.map.layers.length,
            hiliteLayers = [];

        for (i = 0; i < len; i++) {
            if (app.map.layers[i].hiliteLayer && app.map.layers[i].hilitedLayerName === hilitedLayerName) {
                hiliteLayers.push(app.map.layers[i]);
            }
        }

        return hiliteLayers;

    };
    /**
    *
    * Function: getBaseLayersConfig
    *
    * Ritorna la configurazione dei baseLayer
    *
    * Returns:
    * config - {Array} Array contenente la configurazione del layer
    */
    this.getBaseLayersConfig = function() {
        return this.baseLayersConfig;
    };

    /*
        Inizializzazione
    */

    LdMaps.Util.assert(baseLayers,
        {
            name: "BadConfiguration",
            message: "LdMaps.LayerManager.init: baseLayers deve essere valorizzato",
            level: 2
        }
    );

    LdMaps.Util.assert(baseLayers.length > 0,
        {
            name: "BadConfiguration",
            message: "LdMaps.LayerManager.init: baseLayers deve contenere almeno un layer",
            level: 2
        }
    );


    // Imposto le proprietà dei baseLayer
    this.setBaseLayers();


    // inizializzo gli store
    if (app.extRequired) {
        this.buildLayerStoreByType("base");
        this.buildLayerStoreByType("overlay");
    }

};
LdMaps.LayerManager.setLayerVisible = function(name,visible,appId) {

    /*global LdMaps:false, Ext:false, window:false, OpenLayers:false */
    "use strict";

    LdMaps.Util.log("LdMaps.LayerManager.setLayerVisible");

    var app = LdMaps.appRegistry.get(appId),
        layer = app.map.getLayerByName(name),
        layerConfig = app.map.layerManager.getLayerConfigByName(name),
        i,
        hilitedLayer,
        hilitedLayerConfig;

    // guardo se ci sono layer di hilite collegati al layer in oggetto
    var hilitedLayers = app.map.layerManager.getHiliteLayers(name);

    if (layer) {
        layer.setVisibility(visible);
        for (i = 0; i < hilitedLayers.length; i++) {
            hilitedLayers[i].setVisibility(visible);
        }
    }

    if (layerConfig) {
        layerConfig.visible = visible;
    }

};

/**
 * Class: LdMaps.Layout
 *
 *
 * Costruisce il layout della applicazione
 *
 *
 * Constructor: LdMaps.Layout
 *
 * Parameters:
 * layoutConfig - {Object} Hashtable con la configurazione del layout
 * appId - {string} Id della applicazione
 *
 */
LdMaps.Layout = function(layoutConfig,appId) {

    /*global LdMaps:false, Ext:false, window:false, OpenLayers:false */
    "use strict";

    /*
       Proprietà
     */

    this.layout = null;
    this.mapPanel = null;




    /*
        Funzioni private
     */

    function buildPanels(layoutConfig,layout) {

        var panels = [],
               legendPanel,
               mapPanel;

        // pannello legenda
        if (layoutConfig.legend) {
               // creo una legenda di tipo simple
            legendPanel = new LdMaps.SimpleLegendPanel(layoutConfig.legend,appId);
            panels.push(legendPanel);
        }

        // pannello mappa
        if (LdMaps.MapPanel) {
            layout.mapPanel = new LdMaps.MapPanel(layoutConfig,appId);
           panels.push(layout.mapPanel);
        }

        // header
        if (layoutConfig.header) {
            var style = layoutConfig.header.style || null;
            var titlePanel = new Ext.BoxComponent({
                id: "LdMaps-layout-title",
                region: 'north',
                style: style,
                autoEl: {
                    tag: 'div',
                    html: layoutConfig.header.html
                }
            });
            if (layoutConfig.header.height) {
                titlePanel.setHeight(layoutConfig.header.height);
            }
            panels.push(titlePanel);
        }

        return panels;

    }


    LdMaps.Util.log("LdMaps.Layout");

    // costruisco i pannelli (map, legend, title)
    var panelItems = buildPanels(layoutConfig,this);

    // costruisco le opzioni di base
    var basicOptions = {
        defaults: {
            frame: true,
            split: true
        },
        id: "LdMaps-container-" + appId,
        layout: "border",
        hideBorders: false,
        forceLayout: true,
        closeAction: "hide",
        items: panelItems
    };

    // construisco il layout
    switch (layoutConfig.type) {
        case "simple":
            LdMaps.appRegistry.get(appId).map.render(layoutConfig.divID);
            break;
        case "viewport":
            this.layout =  new LdMaps.ViewportLayout(layoutConfig,basicOptions);
            break;
        case "panel":
            this.layout =  new LdMaps.PanelLayout(layoutConfig,basicOptions);
            break;
        case "window":
            this.layout =  new LdMaps.WindowLayout(layoutConfig,basicOptions);
            break;
    }

};
LdMaps.Layout.prototype.setMapTitle = function(title) {

    /*global LdMaps:false, window:false, OpenLayers:false */
    "use strict";

    Ext.getCmp("LdMaps-map-panel-1").setTitle(title);

};

LdMaps.Map = OpenLayers.Class(OpenLayers.Map, {



    /*
     * Constant: BASE_CONTROL_CONFIG
     * {Object} Hashtable dei controlli di base
     */
	BASE_CONTROL_CONFIG: [
		{
			"type": "control",
			"name": "ArgParser"
		},
		{
			"type": "control",
			"name": "Attribution"
		},
		{
			"type": "control",
			"name": "KeyboardDefaults"
		},
		{
			"type": "control",
			"name": "Navigation"
		},
		{
			"type": "control",
			"name": "LoadingPanel"
		}
	],

    /**
     * Property: mapOptions
     * {Object} Opzioni mappa - Oggetto configuration.application.mapOptions
     */
    mapOptions: null,

    /**
     * Proprietà Privata: baseLayersConfig
     * {Array} Array delle configurazioni dei baseLayer
     */
    baseLayersConfig: null,

    /**
     * Proprietà Privata: layersConfig
     * {Array} Array delle configurazioni dei layer
     */
    layersConfig: null,

    // Nome del base layer
    baseLayerName: null,

    // layer manager
    layerManager: null,

    // feature manager
    featureManager: null,

    previousExtent: null,

    // livello massimo di zoom ammesso per la mappa
    maxZoomLevel: null,

    appId: null,
    /*
     * Constructor: LdMaps.Map
     *
     * Parameters:
     * configMapOptions - {Object} Hashtable of options
     * layerManager - {LdMaps.LayerManager} Oggetto layerManager
     */


    initialize: function(configMapOptions,layerManager,appId) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        LdMaps.Util.log("LdMaps.Map");

        this.setMapOptions(configMapOptions);

        this.appId = appId;

        OpenLayers.Map.prototype.initialize.apply(this, [this.mapOptions]);

        this.load(configMapOptions,layerManager);

    },

    setMapOptions: function(configMapOptions) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        this.mapOptions = {};

        this.setProjection(configMapOptions);

        this.setExtent(configMapOptions);

        this.setUnits(configMapOptions);

        // azzero i controlli della mappa OL - altrimenti fa vedere il controllo PanZoom sempre
        this.mapOptions.controls = [];

    },

    setProjection: function(configMapOptions) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        if(configMapOptions.projection) {
            this.mapOptions.projection = configMapOptions.projection;
        } else {
            this.mapOptions.projection = "EPSG:3857";
        }

        // creo la displayProjection
        if(configMapOptions.displayProjection) {
            this.mapOptions.displayProjection = new OpenLayers.Projection(configMapOptions.displayProjection);
        } else {
            this.mapOptions.displayProjection = new OpenLayers.Projection(this.mapOptions.projection);
        }
    },

    setExtent: function(configMapOptions) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        this.mapOptions.maxExtent = OpenLayers.Bounds.fromString("-20037508, -20037508, 20037508, 20037508.34");

        if (configMapOptions.restrictedExtent) {
            this.mapOptions.restrictedExtent = new OpenLayers.Bounds.fromString(configMapOptions.restrictedExtent);
        }

        this.setMapOptionsInitialExtent(configMapOptions);

    },

    setMapOptionsInitialExtent: function(configMapOptions) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        var bound,
            exception,
            LIG_BOUND_STR,
            boundsStr,
            initialExtentParam,
            fromPrj;

        // Se definito in QueryString lo imposto
        // altrimenti se definito in config lo imposto
        // altrimenti lo imposto sulla liguria
        if (LdMaps.Util.getUrlParam("initialExtent")) {
            this.mapOptions.initialExtent = this.calculateInitialExtent(this.getInitialExtentFromUrlParam());
        } else if (configMapOptions.initialExtent){
            this.mapOptions.initialExtent = this.calculateInitialExtent(configMapOptions.initialExtent);
        } else {
            this.mapOptions.initialExtent = this.calculateInitialExtent("830036,5402959,1123018,5597635");
        }

    },

    // deve essere impostato nella forma proj,x1,y1,x2,y2
    // esempio ?initialExtent=EPSG:3857,955508,5496093,1065424,5576964
    getInitialExtentFromUrlParam: function() {
        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        var initialExtentParam = LdMaps.Util.getUrlParam("initialExtent").split(",");
        var fromPrj = initialExtentParam.splice(0,1)[0];
        var boundsStr = initialExtentParam.join(",");
        if (this.mapOptions.projection !== fromPrj) {
            boundsStr = LdMaps.Util.transformStrBounds(fromPrj,this.mapOptions.projection,boundsStr);
        }
        return boundsStr;
    },

    calculateInitialExtent: function(boundsStr) {
        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        var bound = new OpenLayers.Bounds.fromString(boundsStr);

        if(this.restrictedExtent && !this.restrictedExtent.containsBounds(bound)) {
            var exception = {
                name: "BadInitialExtent",
                message: "LdMaps.Map: initialExtent deve essere compreso in restrictedExtent",
                level: 0
            };
            LdMaps.Util.handleException(exception);
            return this.maxExtent;
        } else {
            return bound;
        }

    },

    setUnits: function(configMapOptions) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        if (configMapOptions.units) {
            this.mapOptions.units = configMapOptions.units;
        } else {
            this.mapOptions.units = "m";
        }
    },

    load: function(configMapOptions,layerManager) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        this.maxZoomLevel = configMapOptions.maxZoomLevel || 19;
        this.layerManager = layerManager;
        this.baseLayersConfig = this.layerManager.getBaseLayersConfig();
        this.layersConfig = this.layerManager.getLayersConfig();


        // Carico i baseLayers
        this.loadLayers(this.baseLayersConfig);

        // Carico i layers
        this.loadLayers(this.layersConfig);

        // Imposto il base layer
        for (var i = 0; i < this.baseLayersConfig.length; i++) {
            if (this.baseLayersConfig[i].visible) {
                this.baseLayerName = this.baseLayersConfig[i].name;
                var baseLayer = this.getLayerByName(this.baseLayersConfig[i].name);
                this.setBaseLayer(baseLayer);
            }
        }

        // Inizializzo i controlli per la mappa OL
        this.initControls(configMapOptions);

        this.events.register("moveend", null, function() {
            if (this.restrictedExtent && this.zoom < this.getZoomForExtent(this.restrictedExtent)) {
                this.zoomToExtent(this.restrictedExtent);
            }
            if (this.maxZoomLevel && this.zoom > this.maxZoomLevel) {
                this.zoomTo(this.maxZoomLevel);
            }
        });

        // imposto il fractionalZoom
        //TODO non imposto fractional zoom perchè non funziona con TMS
        //this.setFractionalZoom();


    },

    /**
    *
    * Function: setFractionalZoom
    *
    * Imposta fractionalZoom della mappa a true se non ci sono layer google
    *
     * Parameters:
     * baseLayersConfig - {Array} Array di oggetti configurazione dei layer di base
    *
    */

    setFractionalZoom: function() {

        "use strict";

        LdMaps.Util.log("LdMaps.Map.setFractionalZoom");

        var isNotFractionalLayer = false,
            i,
            len = this.baseLayersConfig.length;

        for (i = 0; i < len; i++) {
            if (this.baseLayersConfig[i].type.indexOf("google_") !== -1 || this.baseLayersConfig[i].type.indexOf("TMS") !== -1 ) {
                isNotFractionalLayer = true;
                break;
            }
        }
        if (!isNotFractionalLayer) {
            this.fractionalZoom = true;
        }

    },
    /**
    *
    * Function: loadLayers
    *
    * Aggiunge un array di livelli alla mappa
    *
    *
    * Parameters:
    * layersconfig - {Array} Array di oggetti configurazione dei layer
    *
    */

    loadLayers: function(layersConfig) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        LdMaps.Util.log("LdMaps.Map.loadLayers");

        // aggiungo i layers alla mappa OL
        if (layersConfig) {
            for (var i = 0; i < layersConfig.length; i++) {
                this.loadLayer(layersConfig[i]);
            }
        }

	},

    /**
    *
    * Function: loadLayer
    *
    * Aggiunge un livello alla mappa
    *
    * Parameters:
    * layerConfig - {Object} Oggetto configurazione del layer
    *
    */

    loadLayer: function(layerConfig) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        LdMaps.Util.log("LdMaps.Map.loadLayer");

         var layer;

         // creo il layer OL e lo aggiungo alla mappa
         try {
             layer = LdMaps.layerFactory.create(layerConfig,this);
         }
         catch (exception) {
             LdMaps.Util.handleException(exception);
         }

         if (layer) {
             this.addLayer(layer);
             // Imposto la visibilità del layer
             layer.setVisibility(layerConfig.visible);
             // Se il layer è vettoriale registro l'evento loadend
             // Quando il layer è caricato imposto l'attributo loadend a true;
             // Serve per gestire l'hilite delle features all'avvio della applicazione
             if (layer.CLASS_NAME==="OpenLayers.Layer.Vector") {
                 layer.loadend=false;
                 layer.events.on({
                     "loadend": function(){
                         layer.loadend = true;
                     },
                     scope: layer
                 });
             }
             return layer;
         }
	},


    /**
     *
     * Function: initControls
     *
     * Inizializza i controlli OpenLayers della mappa.
     *
     */

    initControls: function(configMapOptions) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        // inizializzo i controlli per la selezione delle feature dei livelli vettoriali
        this.featureManager = new LdMaps.FeatureManager(this);

        // carico i controlli opzionali definiti in configurazione
        this.loadControls(configMapOptions.olControls);

        // Carico i controlli base
        // Se impostato noBaseControls a true non carica i controlli di base (mappa bloccata)
        if (!this.mapOptions.noBaseControls) {
            this.loadControls(this.BASE_CONTROL_CONFIG);
        }

        if (configMapOptions.disableScrollWheel) {
            var navControls = this.getControlsByClass("OpenLayers.Control.Navigation");
            for(var i = 0; i < navControls.length; ++i)
                navControls[i].disableZoomWheel();
        }

	},

    /**
    *
    * Function: loadControls
    *
    * Carica i controlli OL sulla mappa.
    *
    * Parameters:
    * controlsConfig - {Array} cArray oggetti configurazione dei controlli
    *
    */

    loadControls: function(controls) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        LdMaps.Util.log("LdMaps.Map.loadControls");

        // aggiungo i controlli alla mappa OL
        if (controls) {
            for (var i = 0; i < controls.length; i++) {
                this.loadControl(controls[i]);
            }
        }
	},

    /**
    *
    * Function: loadControl
    *
    * Carica un controllo OL sulla mappa.
    *
    * Parameters:
    * controlConfig - {Object} Oggetto di configurazione del controllo
    *
    */

    loadControl: function(controlConfig) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        LdMaps.Util.log("LdMaps.Map.loadControl");

        // creo il controllo OL e lo aggiungo alla mappa

        try {
            var olControl = LdMaps.controlFactory.create(controlConfig);
            this.addControl(olControl);
            return olControl;
        }
        catch (exception) {
            LdMaps.Util.handleException(exception);
            return null;
        }

	},

    /**
    * Function: isBaseLayer
    *
    * Ritorna true se il layer è il layer base della mappa
    *
    * Parameters:
    * name - {string} Nome del layer
    *
    * Returns:
    * {Boolean}
    */

    isBaseLayer: function(name) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        return name === this.baseLayerName;

    },

    /**
    * Function: getLayerByName
    *
    * Ritorna il layer OL con un certo nome
    *
    * Parameters:
    * name - {String} Name of the layer
    *
    * Returns:
    * layer - {OpenLayers.Layer}
    *
    */
    getLayerByName: function(name) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        var layers = this.getLayersByName(name);
        if (layers.length > 0) {
            return layers[0];
        } else {
            return null;
        }
    },

    /**
     * Function: removeLayerByName
    *
    * Rimuove un layer dalla mappa
    *
    * Parameters:
     * name - {string} Name of the layer
    *
    */
    removeLayerByName: function(name) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        var layers = this.getLayerByName(name);
        if(layers) {
            this.removeLayer(layers);
        }

    },

    /**
    * Function: zoomToStringExtent
    *
    * Effettua lo zoom su un bound, eventualmente converte il bound nel sistema di coordinate della mappa
    *
    * Parameters:
    * boundsString - {string} Bound in formato "x1,y1,x2,y2"
    * epsgCode - {string} Codice EPSG in formato "EPSG:XXXX"
    *
    */
    zoomToStringExtent: function(boundsString,epsgCode) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        var boundStr = boundsString;

        // se boundsString è in una proiezione diversa dalla mappa converto in proiezione mappa
        if ((epsgCode) && (this.projection !== epsgCode)) {
            boundStr = LdMaps.Util.transformStrBounds(epsgCode,this.projection,boundsString);
        }

        var bounds = new OpenLayers.Bounds.fromString(boundStr);

        this.zoomToExtent(bounds);

    },

    /**
    * Function: zoomToInitialExtent
    *
    * Effettua lo zoom sull'initialExtent
    *
    */
    zoomToInitialExtent: function() {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        // devo richiamare due volte altrimenti non fa zoom ???
        this.zoomToExtent(this.initialExtent);
        this.zoomToExtent(this.initialExtent);
    },


    /**
    * Function: zoomToInitialExtent
    *
    * Effettua lo zoom sull'initialExtent
    *
    */
    zoomToPoint: function(x,y,zoomLevel) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";
        var geom = new OpenLayers.Geometry.Point(x,y);
        var bounds = geom.getBounds().clone();

        this.zoomToExtent(bounds, false);
        if (zoomLevel && this.zoom > zoomLevel) {
            if (!this.baseLayer.maxZoomLevel || zoomLevel < this.baseLayer.maxZoomLevel) {
                this.zoomTo(zoomLevel);
            }
        }

    },
    /**
    * Function: setInitialExtent
    *
    * Imposta l'initialExtent della mappa
    *
    */
    setInitialExtent: function(extent) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        this.initialExtent = extent;
    },

    /**
    * Function: zoomToFeatures
    *
    * Effettua uno zoom sulle feature
    *
    * Parameters:
    * features - {Array} Array di features openlayer
    * zoomLevel - {Number} Livello di zoom.
    *
    */
    zoomToFeatures : function(features,zoomLevel) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        var numFeatures,
            i,
            bounds;

        if(features && features.length) {
            numFeatures = features.length;
        }

        if (numFeatures) {
            bounds = features[0].geometry.getBounds().clone();
            for (i = 1; i < numFeatures; i++) {
                bounds.extend(features[i].geometry.getBounds());
            }

            this.zoomToExtent(bounds, false);


            // se zoomlevel è negativo faccio zoom all'indietro
            if (zoomLevel && zoomLevel < 0) {
                this.zoomTo(this.zoom + zoomLevel)
            } else {
                if (zoomLevel && this.zoom > zoomLevel) {
                    this.zoomTo(zoomLevel);
                }
            }
        }
    },

    /**
    * Function: zoomToLonlat
    *
    * Effettua uno zoom su un punto ad un determinato zoomLevel
    *
    * Parameters:
    * xy - {lonlat} oggetto lonlat openlayer
    * zoom - {Number} Livello di zoom.
    *
    */
    zoomToLonlat : function(lonlat,zoom) {

        /*global LdMaps:false, window:false, OpenLayers:false */
        "use strict";

        if (this.isValidZoomLevel(zoom)) {
            this.setCenter(lonlat, zoom);
        }
    },

	CLASS_NAME: "LdMaps.Map"
});



